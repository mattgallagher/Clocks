//
//  This file is part of a concatenation of the CwlViews framework with internal
//  interfaces for direct inclusion in projects instead of library inclusion).
//  For details, visit: https://github.com/mattgallagher/CwlViews
//
//  Copyright © 2015-2018 Matt Gallagher ( https://www.cocoawithlove.com ). All rights reserved.
//
//  Permission to use, copy, modify, and/or distribute this software for any
//  purpose with or without fee is hereby granted, provided that the above
//  copyright notice and this permission notice appear in all copies.
//
//  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
//  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
//  SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
//  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
//  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR
//  IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
//
//  This file was generated by the CwlConcat tool on 2018-10-25 10:12:07 +0000 from the following files:
//   CwlTableView.swift
//   CwlTextField.swift
//   CwlSwipeGestureRecognizer.swift
//   CwlSetOrAnimate.swift
//   CwlTapGestureRecognizer.swift
//   CwlBarItem.swift
//   CwlNavigationController.swift
//   CwlView.swift
//   CwlLabel.swift
//   CwlTableSection.swift
//   CwlNavigationItem.swift
//   CwlTabBar.swift
//   CwlApplication.swift
//   CwlTabBarController.swift
//   CwlImageView.swift
//   CwlAlertController.swift
//   CwlPageViewController.swift
//   CwlTableViewCell.swift
//   CwlTabBarItem.swift
//   CwlNavigationBar.swift
//   CwlLongPressGestureRecognizer.swift
//   CwlAlertAction.swift
//   CwlSlider.swift
//   CwlWindow.swift
//   CwlSwitch.swift
//   CwlPanGestureRecognizer.swift
//   CwlSplitViewController.swift
//   CwlTextView.swift
//   CwlPinchGestureRecognizer.swift
//   CwlScrollView.swift
//   CwlGestureRecognizer.swift
//   CwlControl.swift
//   CwlButton.swift
//   CwlTextInputTraits.swift
//   CwlViewController.swift
//   CwlSearchBar.swift
//   CwlScreenEdgePanGestureRecognizer.swift
//   CwlRotationGestureRecognizer.swift
//   CwlBarButtonItem.swift
//   CwlBackingLayer.swift
//   CwlGradientLayer.swift
//   CwlWebView.swift
//   CwlStackView.swift
//   CwlLayer.swift

import UIKit

class TableView<RowData>: ConstructingBinder, TableViewConvertible {
	typealias Instance = UITableView
	typealias Inherited = ScrollView
	
	var state: ConstructingBinderState<Instance, Binding>
	required init(state: ConstructingBinderState<Instance, Binding>) {
		self.state = state
	}
	static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	func uiTableView() -> Instance { return instance() }

	enum Binding: TableViewBinding {
		typealias RowDataType = RowData
		typealias EnclosingBinder = TableView
		static func tableViewBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case tableViewStyle(Constant<UITableView.Style>)

		//	1. Value bindings may be applied at construction and may subsequently change.
		case allowsMultipleSelection(Dynamic<Bool>)
		case allowsMultipleSelectionDuringEditing(Dynamic<Bool>)
		case allowsSelection(Dynamic<Bool>)
		case allowsSelectionDuringEditing(Dynamic<Bool>)
		case backgroundView(Dynamic<ViewConvertible?>)
		case cellLayoutMarginsFollowReadableWidth(Dynamic<Bool>)
		case isEditing(Signal<SetOrAnimate<Bool>>)
		case estimatedRowHeight(Dynamic<CGFloat>)
		case estimatedSectionFooterHeight(Dynamic<CGFloat>)
		case estimatedSectionHeaderHeight(Dynamic<CGFloat>)
		case remembersLastFocusedIndexPath(Dynamic<Bool>)
		case rowHeight(Dynamic<CGFloat>)
		case sectionFooterHeight(Dynamic<CGFloat>)
		case sectionHeaderHeight(Dynamic<CGFloat>)
		case sectionIndexBackgroundColor(Dynamic<UIColor?>)
		case sectionIndexColor(Dynamic<UIColor?>)
		case sectionIndexMinimumDisplayRowCount(Dynamic<Int>)
		case sectionIndexTrackingBackgroundColor(Dynamic<UIColor?>)
		case sectionIndexTitles(Dynamic<[String]?>)
		case separatorColor(Dynamic<UIColor?>)
		case separatorEffect(Dynamic<UIVisualEffect?>)
		case separatorInset(Dynamic<UIEdgeInsets>)
		case separatorStyle(Dynamic<UITableViewCell.SeparatorStyle>)
		case tableFooterView(Dynamic<ViewConvertible?>)
		case tableHeaderView(Dynamic<ViewConvertible?>)
		case tableData(Dynamic<TableData<RowData>>)
		
		//	2. Signal bindings are performed on the object after construction.
		case deselectRow(Signal<SetOrAnimate<IndexPath>>)
		case scrollToNearestSelectedRow(Signal<SetOrAnimate<UITableView.ScrollPosition>>)
		case scrollToRow(Signal<SetOrAnimate<TableScrollPosition>>)
		case selectRow(Signal<SetOrAnimate<TableScrollPosition?>>)
		
		//	3. Action bindings are triggered by the object after construction.
		case userDidScrollToRow(SignalInput<TableRow<RowData>>)
		case accessoryButtonTapped(SignalInput<TableRow<RowData>>)
		case didDeselectRow(SignalInput<TableRow<RowData>>)
		case didEndDisplayingFooter(SignalInput<Int>)
		case didEndDisplayingHeader(SignalInput<Int>)
		case didEndDisplayingRow(SignalInput<TableRow<RowData>>)
		case didEndEditingRow(SignalInput<TableRow<RowData>?>)
		case didHightlightRow(SignalInput<TableRow<RowData>>)
		case didSelectRow(SignalInput<TableRow<RowData>>)
		case didUnhighlightRow(SignalInput<TableRow<RowData>>)
		case moveRow(SignalInput<(from: TableRow<RowData>, to: IndexPath)>)
		case selectionDidChange(SignalInput<[TableRow<RowData>]?>)
		case visibleRowsChanged(SignalInput<[TableRow<RowData>]>)
		case commit(SignalInput<(editingStyle: UITableViewCell.EditingStyle, row: TableRow<RowData>)>)
		
		//	4. Delegate bindings require synchronous evaluation within the object's context.
		case cellIdentifier((TableRow<RowData>) -> String?)
		case canEditRow((_ tableRowData: TableRow<RowData>) -> Bool)
		case canFocusRow((_ tableRowData: TableRow<RowData>) -> Bool)
		case canMoveRow((_ tableRowData: TableRow<RowData>) -> Bool)
		case canPerformAction((_ action: Selector, _ tableRowData: TableRow<RowData>, _ sender: Any?) -> Bool)
		case cellConstructor((_ identifier: String?, _ rowSignal: SignalMulti<RowData>) -> TableViewCellConvertible)
		case dataMissingCell((IndexPath) -> TableViewCellConvertible)
		case didUpdateFocus((UITableView, UITableViewFocusUpdateContext, UIFocusAnimationCoordinator) -> Void)
		case editActionsForRow((_ tableRowData: TableRow<RowData>) -> [UITableViewRowAction]?)
		case editingStyleForRow((_ tableRowData: TableRow<RowData>) -> UITableViewCell.EditingStyle)
		case estimatedHeightForFooter((_ section: Int) -> CGFloat)
		case estimatedHeightForHeader((_ section: Int) -> CGFloat)
		case estimatedHeightForRow((_ tableRowData: TableRow<RowData>) -> CGFloat)
		case footerHeight((_ section: Int) -> CGFloat)
		case footerView((_ section: Int, _ title: String?) -> ViewConvertible?)
		case headerHeight((_ section: Int) -> CGFloat)
		case headerView((_ section: Int, _ title: String?) -> ViewConvertible?)
		case heightForRow((_ tableRowData: TableRow<RowData>) -> CGFloat)
		case indentationLevelForRow((_ tableRowData: TableRow<RowData>) -> Int)
		case indexPathForPreferredFocusedView((UITableView) -> IndexPath)
		case shouldHighlightRow((_ tableRowData: TableRow<RowData>) -> Bool)
		case shouldIndentWhileEditingRow((_ tableRowData: TableRow<RowData>) -> Bool)
		case shouldShowMenuForRow((_ tableRowData: TableRow<RowData>) -> Bool)
		case shouldUpdateFocus((UITableView, UITableViewFocusUpdateContext) -> Bool)
		case targetIndexPathForMoveFromRow((_ tableView: UITableView, _ sourceIndexPath: IndexPath, _ proposedIndexPath: IndexPath) -> IndexPath)
		case titleForDeleteConfirmationButtonForRow((_ tableRowData: TableRow<RowData>) -> String?)
		case willBeginEditingRow((_ tableView: UITableView, _ tableRowData: TableRow<RowData>) -> Void)
		case willDeselectRow((_ tableView: UITableView, _ tableRowData: TableRow<RowData>) -> IndexPath?)
		case willDisplayFooter((_ tableView: UITableView, _ section: Int, _ view: UIView) -> Void)
		case willDisplayHeader((_ tableView: UITableView, _ section: Int, _ view: UIView) -> Void)
		case willDisplayRow((_ tableView: UITableView, _ tableRowData: TableRow<RowData>, _ cell: UITableViewCell) -> Void)
		case willSelectRow((_ tableView: UITableView, _ tableRowData: TableRow<RowData>) -> IndexPath?)
	}

	struct Preparer: ConstructingPreparer {
		typealias EnclosingBinder = TableView
		var linkedPreparer = Inherited.Preparer()
		
		func constructStorage() -> EnclosingBinder.Storage { return Storage(cellIdentifier: cellIdentifier) }
		func constructInstance(subclass: EnclosingBinder.Instance.Type) -> EnclosingBinder.Instance {
			return subclass.init(frame: CGRect.zero, style: tableViewStyle)
		}
		
		// Actual delegate construction is handled by the scroll view preparer
		init() {
			self.init(delegateClass: Delegate.self)
		}
		init(delegateClass: Delegate.Type) {
			linkedPreparer = Inherited.Preparer(delegateClass: delegateClass)
		}
		var possibleDelegate: Delegate? { return linkedPreparer.possibleDelegate as? Delegate }
		mutating func delegate() -> Delegate { return linkedPreparer.delegate() as! Delegate }
		
		var tableViewStyle: UITableView.Style = .plain
		var rowsChangedInput: SignalInput<[TableRow<RowData>]>? = nil
		var cellIdentifier: (TableRow<RowData>) -> String? = { _ in nil }
		
		mutating func prepareBinding(_ binding: Binding) {
			switch binding {
			case .cellIdentifier(let x): cellIdentifier = x
			case .tableViewStyle(let x): tableViewStyle = x.value
			case .userDidScrollToRow(let x):
				let s1 = #selector(UIScrollViewDelegate.scrollViewDidScrollToTop(_:))
				let s2 = #selector(UIScrollViewDelegate.scrollViewDidEndDragging(_:willDecelerate:))
				let s3 = #selector(UIScrollViewDelegate.scrollViewDidEndDecelerating(_:))
				delegate().addSelector(s1).userDidScrollToRow = x
				_ = delegate().addSelector(s2)
				_ = delegate().addSelector(s3)
			case .accessoryButtonTapped(let x):
				let s = #selector(UITableViewDelegate.tableView(_:accessoryButtonTappedForRowWith:))
				delegate().addSelector(s).accessoryButtonTapped = x
			case .canEditRow(let x):
				let s = #selector(UITableViewDataSource.tableView(_:canEditRowAt:))
				delegate().addSelector(s).canEditRow = x
			case .canFocusRow(let x):
				let s = #selector(UITableViewDelegate.tableView(_:canFocusRowAt:))
				delegate().addSelector(s).canFocusRow = x
			case .canMoveRow(let x):
				let s = #selector(UITableViewDataSource.tableView(_:canMoveRowAt:))
				delegate().addSelector(s).canMoveRow = x
			case .canPerformAction(let x):
				let s = #selector(UITableViewDelegate.tableView(_:canPerformAction:forRowAt:withSender:))
				delegate().addSelector(s).canPerformAction = x
			case .didDeselectRow(let x):
				let s = #selector(UITableViewDelegate.tableView(_:didDeselectRowAt:))
				delegate().addSelector(s).didDeselectRow = x
			case .didEndDisplayingFooter(let x):
				let s = #selector(UITableViewDelegate.tableView(_:didEndDisplayingFooterView:forSection:))
				delegate().addSelector(s).didEndDisplayingFooter = x
			case .didEndDisplayingHeader(let x):
				let s = #selector(UITableViewDelegate.tableView(_:didEndDisplayingHeaderView:forSection:))
				delegate().addSelector(s).didEndDisplayingHeader = x
			case .didEndDisplayingRow(let x):
				let s = #selector(UITableViewDelegate.tableView(_:didEndDisplaying:forRowAt:))
				delegate().addSelector(s).didEndDisplayingRow = x
			case .didEndEditingRow(let x):
				let s = #selector(UITableViewDelegate.tableView(_:didEndEditingRowAt:))
				delegate().addSelector(s).didEndEditingRow = x
			case .didHightlightRow(let x):
				let s = #selector(UITableViewDelegate.tableView(_:didHighlightRowAt:))
				delegate().addSelector(s).didHightlightRow = x
			case .commit(let x):
				let s = #selector(UITableViewDataSource.tableView(_:commit:forRowAt:))
				delegate().addSelector(s).commit = x
			case .didSelectRow(let x):
				let s = #selector(UITableViewDelegate.tableView(_:didSelectRowAt:))
				delegate().addSelector(s).didSelectRow = x
			case .didUnhighlightRow(let x):
				let s = #selector(UITableViewDelegate.tableView(_:didUnhighlightRowAt:))
				delegate().addSelector(s).didUnhighlightRow = x
			case .didUpdateFocus(let x):
				let s = #selector(UITableViewDelegate.tableView(_:didUpdateFocusIn:with:))
				delegate().addSelector(s).didUpdateFocus = x
			case .editActionsForRow(let x):
				let s = #selector(UITableViewDelegate.tableView(_:editActionsForRowAt:))
				delegate().addSelector(s).editActionsForRow = x
			case .editingStyleForRow(let x):
				let s = #selector(UITableViewDelegate.tableView(_:editingStyleForRowAt:))
				delegate().addSelector(s).editingStyleForRow = x
			case .estimatedHeightForFooter(let x):
				let s = #selector(UITableViewDelegate.tableView(_:estimatedHeightForFooterInSection:))
				delegate().addSelector(s).estimatedHeightForFooter = x
			case .estimatedHeightForHeader(let x):
				let s = #selector(UITableViewDelegate.tableView(_:estimatedHeightForHeaderInSection:))
				delegate().addSelector(s).estimatedHeightForHeader = x
			case .estimatedHeightForRow(let x):
				let s = #selector(UITableViewDelegate.tableView(_:estimatedHeightForRowAt:))
				delegate().addSelector(s).estimatedHeightForRow = x
			case .footerHeight(let x):
				let s = #selector(UITableViewDelegate.tableView(_:heightForFooterInSection:))
				delegate().addSelector(s).footerHeight = x
			case .footerView(let x):
				let s = #selector(UITableViewDelegate.tableView(_:viewForFooterInSection:))
				delegate().addSelector(s).footerView = x
			case .headerHeight(let x):
				let s = #selector(UITableViewDelegate.tableView(_:heightForHeaderInSection:))
				delegate().addSelector(s).headerHeight = x
			case .headerView(let x):
				let s = #selector(UITableViewDelegate.tableView(_:viewForHeaderInSection:))
				delegate().addSelector(s).headerView = x
			case .heightForRow(let x):
				let s = #selector(UITableViewDelegate.tableView(_:heightForRowAt:))
				delegate().addSelector(s).heightForRow = x
			case .indentationLevelForRow(let x):
				let s = #selector(UITableViewDelegate.tableView(_:indentationLevelForRowAt:))
				delegate().addSelector(s).indentationLevelForRow = x
			case .indexPathForPreferredFocusedView(let x):
				let s = #selector(UITableViewDelegate.indexPathForPreferredFocusedView(in:))
				delegate().addSelector(s).indexPathForPreferred = x
			case .moveRow(let x):
				let s = #selector(UITableViewDataSource.tableView(_:moveRowAt:to:))
				delegate().addSelector(s).moveRow = x
			case .shouldHighlightRow(let x):
				let s = #selector(UITableViewDelegate.tableView(_:shouldHighlightRowAt:))
				delegate().addSelector(s).shouldHighlightRow = x
			case .shouldIndentWhileEditingRow(let x):
				let s = #selector(UITableViewDelegate.tableView(_:shouldIndentWhileEditingRowAt:))
				delegate().addSelector(s).shouldIndentWhileEditingRow = x
			case .shouldShowMenuForRow(let x):
				let s = #selector(UITableViewDelegate.tableView(_:shouldShowMenuForRowAt:))
				delegate().addSelector(s).shouldShowMenuForRow = x
			case .shouldUpdateFocus(let x):
				let s = #selector(UITableViewDelegate.tableView(_:shouldUpdateFocusIn:))
				delegate().addSelector(s).shouldUpdateFocus = x
			case .targetIndexPathForMoveFromRow(let x):
				let s = #selector(UITableViewDelegate.tableView(_:targetIndexPathForMoveFromRowAt:toProposedIndexPath:))
				delegate().addSelector(s).targetIndexPathForMoveFromRow = x
			case .titleForDeleteConfirmationButtonForRow(let x):
				let s = #selector(UITableViewDelegate.tableView(_:titleForDeleteConfirmationButtonForRowAt:))
				delegate().addSelector(s).titleForDeleteConfirmationButtonForRow = x
			case .visibleRowsChanged(let x):
				let s1 = #selector(UITableViewDelegate.tableView(_:willDisplay:forRowAt:))
				let s2 = #selector(UITableViewDelegate.tableView(_:didEndDisplaying:forRowAt:))
				delegate().addSelector(s1)
				delegate().addSelector(s2)
				rowsChangedInput = x
			case .inheritedBinding(let x): linkedPreparer.prepareBinding(x)
			default: break
			}
		}
		
		func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
			switch binding {
			case .cellIdentifier: return nil
			case .tableViewStyle: return nil
			case .allowsMultipleSelection(let x): return x.apply(instance, storage) { i, s, v in i.allowsMultipleSelection = v }
			case .allowsMultipleSelectionDuringEditing(let x): return x.apply(instance, storage) { i, s, v in i.allowsMultipleSelectionDuringEditing = v }
			case .allowsSelection(let x): return x.apply(instance, storage) { i, s, v in i.allowsSelection = v }
			case .allowsSelectionDuringEditing(let x): return x.apply(instance, storage) { i, s, v in i.allowsSelectionDuringEditing = v }
			case .backgroundView(let x): return x.apply(instance, storage) { i, s, v in i.backgroundView = v?.uiView() }
			case .cellLayoutMarginsFollowReadableWidth(let x): return x.apply(instance, storage) { i, s, v in i.cellLayoutMarginsFollowReadableWidth = v }
			case .deselectRow(let x): return x.apply(instance, storage) { i, s, v in i.deselectRow(at: v.value, animated: v.isAnimated) }
			case .isEditing(let x): return x.apply(instance, storage) { i, s, v in i.setEditing(v.value, animated: v.isAnimated) }
			case .estimatedRowHeight(let x): return x.apply(instance, storage) { i, s, v in i.estimatedRowHeight = v }
			case .estimatedSectionFooterHeight(let x): return x.apply(instance, storage) { i, s, v in i.estimatedSectionFooterHeight = v }
			case .estimatedSectionHeaderHeight(let x): return x.apply(instance, storage) { i, s, v in i.estimatedSectionHeaderHeight = v }
			case .remembersLastFocusedIndexPath(let x): return x.apply(instance, storage) { i, s, v in i.remembersLastFocusedIndexPath = v }
			case .rowHeight(let x): return x.apply(instance, storage) { i, s, v in i.rowHeight = v }
			case .scrollToNearestSelectedRow(let x): return x.apply(instance, storage) { i, s, v in i.scrollToNearestSelectedRow(at: v.value, animated: v.isAnimated) }
			case .scrollToRow(let x):
				// You can't scroll a table view until *after* the number of sections and rows has been read from the data source.
				// This occurs on didAddToWindow but the easiest way to track it is by waiting for the contentSize to be set (which is set for the first time immediately after the row count is read). This makes assumptions about internal logic of UITableView – if this logic changes in future, scrolls set on load might be lost (not a catastrophic problem).
				// Capture the scroll signal to stall it
				let capture = x.capture()
				
				// Create a signal pair that will join the capture to the destination *after* the first `contentSize` change is observed
				let pair = Signal<SetOrAnimate<TableScrollPosition>>.create()
				var kvo: NSKeyValueObservation? = instance.observe(\.contentSize) { (i, change) in
					_ = try? capture.bind(to: pair.input, resend: true)
				}
				
				// Use the output of the pair to apply the effects as normal
				return pair.signal.apply(instance, storage) { i, s, v in
					// Remove the key value observing after the first value is received.
					if let k = kvo {
						k.invalidate()
						kvo = nil
					}
					
					// Clamp to the number of actual sections and rows
					var indexPath = v.value.indexPath
					if indexPath.section >= i.numberOfSections {
						indexPath.section = i.numberOfSections - 1
					}
					if indexPath.section < 0 {
						return
					}
					if indexPath.row >= i.numberOfRows(inSection: indexPath.section) {
						indexPath.row = i.numberOfRows(inSection: indexPath.section) - 1
					}
					if indexPath.row < 0 {
						return
					}
					
					// Finally, perform the scroll
					i.scrollToRow(at: indexPath, at: v.value.position, animated: v.isAnimated)
				}
			case .sectionFooterHeight(let x): return x.apply(instance, storage) { i, s, v in i.sectionFooterHeight = v }
			case .sectionHeaderHeight(let x): return x.apply(instance, storage) { i, s, v in i.sectionHeaderHeight = v }
			case .sectionIndexBackgroundColor(let x): return x.apply(instance, storage) { i, s, v in i.sectionIndexBackgroundColor = v }
			case .sectionIndexColor(let x): return x.apply(instance, storage) { i, s, v in i.sectionIndexColor = v }
			case .sectionIndexMinimumDisplayRowCount(let x): return x.apply(instance, storage) { i, s, v in i.sectionIndexMinimumDisplayRowCount = v }
			case .sectionIndexTrackingBackgroundColor(let x): return x.apply(instance, storage) { i, s, v in i.sectionIndexTrackingBackgroundColor = v }
			case .selectRow(let x): return x.apply(instance, storage) { i, s, v in i.selectRow(at: v.value?.indexPath, animated: v.isAnimated, scrollPosition: v.value?.position ?? .none) }
			case .separatorColor(let x): return x.apply(instance, storage) { i, s, v in i.separatorColor = v }
			case .separatorEffect(let x): return x.apply(instance, storage) { i, s, v in i.separatorEffect = v }
			case .separatorInset(let x): return x.apply(instance, storage) { i, s, v in i.separatorInset = v }
			case .separatorStyle(let x): return x.apply(instance, storage) { i, s, v in i.separatorStyle = v }
			case .tableFooterView(let x): return x.apply(instance, storage) { i, s, v	in i.tableFooterView = v?.uiView() }
			case .tableHeaderView(let x): return x.apply(instance, storage) { i, s, v in i.tableHeaderView = v?.uiView() }
			case .selectionDidChange(let x):
				return Signal.notifications(name: UITableView.selectionDidChangeNotification, object: instance).map { n -> ([TableRow<RowData>])? in
					if let tableView = n.object as? UITableView, let selection = tableView.indexPathsForSelectedRows {
						if let rows = (tableView.delegate as? Storage)?.sections.rows {
							return selection.map { TableRow<RowData>(indexPath: $0, data: rows.at($0.section)?.rows.at($0.row)) }
						} else {
							return selection.map { TableRow<RowData>(indexPath: $0, data: nil) }
						}
					} else {
						return nil
					}
				}.cancellableBind(to: x)
			case .sectionIndexTitles(let x):
				return x.apply(instance, storage) { i, s, v in
					s.indexTitles = v
					i.reloadSectionIndexTitles()
				}
			case .tableData(let x):
				return x.apply(instance, storage) { i, s, v in
					s.applyTableRowMutation(v, to: i)
				}
			case .cellConstructor(let x):
				storage.cellConstructor = x
				return nil
			case .dataMissingCell(let x):
				storage.dataMissingCell = x
				return nil
			case .userDidScrollToRow: return nil
			case .accessoryButtonTapped: return nil
			case .canEditRow: return nil
			case .canFocusRow: return nil
			case .canMoveRow: return nil
			case .canPerformAction: return nil
			case .didDeselectRow: return nil
			case .didEndDisplayingFooter: return nil
			case .didEndDisplayingHeader: return nil
			case .didEndDisplayingRow: return nil
			case .didEndEditingRow: return nil
			case .didHightlightRow: return nil
			case .didSelectRow: return nil
			case .commit: return nil
			case .didUnhighlightRow: return nil
			case .didUpdateFocus: return nil
			case .editActionsForRow: return nil
			case .editingStyleForRow: return nil
			case .estimatedHeightForFooter: return nil
			case .estimatedHeightForHeader: return nil
			case .estimatedHeightForRow: return nil
			case .footerHeight: return nil
			case .footerView: return nil
			case .headerHeight: return nil
			case .headerView: return nil
			case .heightForRow: return nil
			case .indentationLevelForRow: return nil
			case .indexPathForPreferredFocusedView: return nil
			case .moveRow: return nil
			case .shouldHighlightRow: return nil
			case .shouldIndentWhileEditingRow: return nil
			case .shouldShowMenuForRow: return nil
			case .shouldUpdateFocus: return nil
			case .targetIndexPathForMoveFromRow: return nil
			case .titleForDeleteConfirmationButtonForRow: return nil
			case .visibleRowsChanged: return nil
			case .willBeginEditingRow: return nil
			case .willDeselectRow: return nil
			case .willDisplayFooter: return nil
			case .willDisplayHeader: return nil
			case .willDisplayRow: return nil
			case .willSelectRow: return nil
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: instance, storage: storage)
			}
		}

		mutating func prepareInstance(_ instance: Instance, storage: Storage) {
			storage.rowsChangedInput = rowsChangedInput

			linkedPreparer.prepareInstance(instance, storage: storage)
			instance.dataSource = storage
		}
	}

	class Storage: ScrollView.Storage, UITableViewDelegate, UITableViewDataSource {
		override var inUse: Bool { return true }
		var sections = TableRowState<TableSectionState<RowData>>()
		var indexTitles: [String]? = nil
		var scrollJunction: (SignalCapture<SetOrAnimate<(IndexPath, UITableView.ScrollPosition)>>, SignalInput<SetOrAnimate<(IndexPath, UITableView.ScrollPosition)>>)? = nil
		var cellIdentifier: (TableRow<RowData>) -> String?
		var cellConstructor: ((_ identifier: String?, _ rowSignal: SignalMulti<RowData>) -> TableViewCellConvertible)?
		var dataMissingCell: (IndexPath) -> TableViewCellConvertible = { _ in return TableViewCell() }
		
		init(cellIdentifier: @escaping (TableRow<RowData>) -> String?) {
			self.cellIdentifier = cellIdentifier
			super.init()
		}
		
		func numberOfSections(in tableView: UITableView) -> Int {
			return sections.globalCount
		}
		
		func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
			return sections.rows.at(section)?.globalCount ?? 0
		}
		
		func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
			let data = sections.rows.at(indexPath.section).flatMap { s in s.rows.at(indexPath.row - s.localOffset) }
			let identifier = cellIdentifier(TableRow(indexPath: indexPath, data: data))
			
			let cellView: UITableViewCell
			let cellInput: SignalInput<RowData>?
			if let i = identifier, let reusedView = tableView.dequeueReusableCell(withIdentifier: i) {
				cellView = reusedView
				cellInput = getSignalInput(for: reusedView, valueType: RowData.self)
			} else if let cc = cellConstructor {
				let dataTuple = Signal<RowData>.channel().multicast()
				let constructed = cc(identifier, dataTuple.signal).uiTableViewCell(reuseIdentifier: identifier)
				cellView = constructed
				cellInput = dataTuple.input
				setSignalInput(for: constructed, to: dataTuple.input)
			} else {
				return dataMissingCell(indexPath).uiTableViewCell(reuseIdentifier: nil)
			}
			
			if let d = data {
				_ = cellInput?.send(value: d)
			}
			
			return cellView
		}
		
		func tableView(_ tableView: UITableView, titleForHeaderInSection: Int) -> String? {
			return sections.rows.at(titleForHeaderInSection)?.metadata.header
		}
		
		func tableView(_ tableView: UITableView, titleForFooterInSection: Int) -> String? {
			return sections.rows.at(titleForFooterInSection)?.metadata.footer
		}
		
		func sectionIndexTitles(for tableView: UITableView) -> [String]? {
			return indexTitles
		}
		
		var rowsChangedInput: SignalInput<[TableRow<RowData>]>?
		func notifyVisibleRowsChanged(in tableView: UITableView) {
			Exec.mainAsync.invoke {
				if let input = self.rowsChangedInput {
					let indexPaths = tableView.indexPathsForVisibleRows
					if let ip = indexPaths, ip.count > 0 {
						input.send(value: ip.map { TableRow<RowData>(indexPath: $0, data: self.sections.rows.at($0.section)?.rows.at($0.row)) })
					} else {
						input.send(value: [])
					}
				}
			}
		}
		
		func applyTableRowMutation(_ v: TableRowMutation<TableSectionMutation<RowData>>, to i: UITableView) {
			v.apply(to: &sections)
			
			switch v.arrayMutation.kind {
			case .delete:
				i.deleteSections(v.arrayMutation.indexSet.offset(by: sections.localOffset), with: v.animation)
			case .move(let destination):
				i.beginUpdates()
				for (count, index) in v.arrayMutation.indexSet.offset(by: sections.localOffset).enumerated() {
					i.moveSection(index, toSection: destination + count)
				}
				i.endUpdates()
			case .insert:
				i.insertSections(v.arrayMutation.indexSet.offset(by: sections.localOffset), with: v.animation)
			case .scroll:
				i.reloadSections(v.arrayMutation.indexSet.offset(by: sections.localOffset), with: v.animation)
			case .update:
				for (sectionIndex, change) in zip(v.arrayMutation.indexSet.offset(by: sections.localOffset), v.arrayMutation.values) {
					if change.metadata != nil {
						i.reloadSections([sectionIndex], with: v.animation)
					} else {
						let mappedIndices = change.rowMutation.arrayMutation.indexSet.map { IndexPath(row: $0, section: sectionIndex) }
						switch change.rowMutation.arrayMutation.kind {
						case .delete: i.deleteRows(at: mappedIndices, with: change.rowMutation.animation)
						case .move(let destination):
							for (count, index) in mappedIndices.enumerated() {
								i.moveRow(at: index, to: IndexPath(row: destination + count, section: sectionIndex))
							}
						case .insert: i.insertRows(at: mappedIndices, with: change.rowMutation.animation)
						case .scroll:
							i.reloadRows(at: mappedIndices, with: change.rowMutation.animation)
						case .update:
							guard let section = sections.rows.at(sectionIndex - sections.localOffset) else { continue }
							for indexPath in mappedIndices {
								guard let cell = i.cellForRow(at: indexPath), let value = section.rows.at(indexPath.row - section.rowState.localOffset) else { continue }
								getSignalInput(for: cell, valueType: RowData.self)?.send(value: value)
							}
							notifyVisibleRowsChanged(in: i)
						case .reload:
							i.reloadSections([sectionIndex], with: change.rowMutation.animation)
						}
					}
				}
			case .reload:
				i.reloadData()
			}
		}
	}

	class Delegate: ScrollView.Delegate, UITableViewDataSource, UITableViewDelegate {
		required init() {
			super.init()
		}
		
		var userDidScrollToRow: SignalInput<TableRow<RowData>>?

		override func scrollViewDidEndDragging(_ scrollView: UIScrollView, willDecelerate decelerate: Bool) {
			super.scrollViewDidEndDragging(scrollView, willDecelerate: decelerate)
			if !decelerate, let tableView = scrollView as? UITableView, let topVisibleRow = tableView.indexPathsForVisibleRows?.last {
				userDidScrollToRow?.send(value: tableRowData(at: topVisibleRow, in: tableView))
			}
		}
		
		override func scrollViewDidScrollToTop(_ scrollView: UIScrollView) {
			super.scrollViewDidScrollToTop(scrollView)
			if let tableView = scrollView as? UITableView, let topVisibleRow = tableView.indexPathsForVisibleRows?.last {
				userDidScrollToRow?.send(value: tableRowData(at: topVisibleRow, in: tableView))
			}
		}
		
		override func scrollViewDidEndDecelerating(_ scrollView: UIScrollView) {
			super.scrollViewDidEndDecelerating(scrollView)
			if let tableView = scrollView as? UITableView, let topVisibleRow = tableView.indexPathsForVisibleRows?.last {
				userDidScrollToRow?.send(value: tableRowData(at: topVisibleRow, in: tableView))
			}
		}

		private func tableRowData(at indexPath: IndexPath, in tableView: UITableView) -> TableRow<RowData> {
			return TableRow<RowData>(indexPath: indexPath, data: (tableView.delegate as? Storage)?.sections.rows.at(indexPath.section)?.rows.at(indexPath.row))
		}
		
		func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
			return 0
		}
		func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
			return UITableViewCell()
		}
		
		var accessoryButtonTapped: SignalInput<TableRow<RowData>>?
		func tableView(_ tableView: UITableView, accessoryButtonTappedForRowWith indexPath: IndexPath) {
			accessoryButtonTapped?.send(value: tableRowData(at: indexPath, in: tableView))
		}
		
		var canEditRow: ((_ tableRowData: TableRow<RowData>) -> Bool)?
		func tableView(_ tableView: UITableView, canEditRowAt indexPath: IndexPath) -> Bool {
			return canEditRow!(tableRowData(at: indexPath, in: tableView))
		}
		
		var canFocusRow: ((_ tableRowData: TableRow<RowData>) -> Bool)?
		func tableView(_ tableView: UITableView, canFocusRowAt indexPath: IndexPath) -> Bool {
			return canFocusRow!(tableRowData(at: indexPath, in: tableView))
		}
		
		var canMoveRow: ((_ tableRowData: TableRow<RowData>) -> Bool)?
		func tableView(_ tableView: UITableView, canMoveRowAt indexPath: IndexPath) -> Bool {
			return canMoveRow!(tableRowData(at: indexPath, in: tableView))
		}
		
		var canPerformAction: ((_ action: Selector, _ tableRowData: TableRow<RowData>, _ sender: Any?) -> Bool)?
		func tableView(_ tableView: UITableView, canPerformAction action: Selector, forRowAt indexPath: IndexPath, withSender sender: Any?) -> Bool {
			return canPerformAction!(action, tableRowData(at: indexPath, in: tableView), sender)
		}
		
		var didDeselectRow: SignalInput<TableRow<RowData>>?
		func tableView(_ tableView: UITableView, didDeselectRowAt indexPath: IndexPath) {
			didDeselectRow?.send(value: tableRowData(at: indexPath, in: tableView))
		}
		
		var didEndDisplayingHeader: SignalInput<Int>?
		func tableView(_ tableView: UITableView, didEndDisplayingHeaderView view: UIView, forSection section: Int) {
			didEndDisplayingHeader?.send(value: section)
		}
		
		var didEndDisplayingFooter: SignalInput<Int>?
		func tableView(_ tableView: UITableView, didEndDisplayingFooterView view: UIView, forSection section: Int) {
			didEndDisplayingFooter?.send(value: section)
		}
		
		var didEndDisplayingRow: SignalInput<TableRow<RowData>>?
		func tableView(_ tableView: UITableView, didEndDisplaying cell: UITableViewCell, forRowAt indexPath: IndexPath) {
			didEndDisplayingRow?.send(value: tableRowData(at: indexPath, in: tableView))
			
			(tableView.delegate as? Storage)?.notifyVisibleRowsChanged(in: tableView)
		}
		
		var didEndEditingRow: SignalInput<TableRow<RowData>?>?
		func tableView(_ tableView: UITableView, didEndEditingRowAt indexPath: IndexPath?) {
			didEndEditingRow?.send(value: indexPath.map { tableRowData(at: $0, in: tableView) })
		}
		
		var didHightlightRow: SignalInput<TableRow<RowData>>?
		func tableView(_ tableView: UITableView, didHighlightRowAt indexPath: IndexPath) {
			didHightlightRow?.send(value: tableRowData(at: indexPath, in: tableView))
		}
		
		var didSelectRow: SignalInput<TableRow<RowData>>?
		func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
			didSelectRow?.send(value: tableRowData(at: indexPath, in: tableView))
		}
		
		var didUnhighlightRow: SignalInput<TableRow<RowData>>?
		func tableView(_ tableView: UITableView, didUnhighlightRowAt indexPath: IndexPath) {
			didUnhighlightRow?.send(value: tableRowData(at: indexPath, in: tableView))
		}
		
		var didUpdateFocus: ((UITableView, UITableViewFocusUpdateContext, UIFocusAnimationCoordinator) -> Void)?
		func tableView(_ tableView: UITableView, didUpdateFocusIn context: UITableViewFocusUpdateContext, with coordinator: UIFocusAnimationCoordinator) {
			return didUpdateFocus!(tableView, context, coordinator)
		}
		
		var editActionsForRow: ((_ tableRowData: TableRow<RowData>) -> [UITableViewRowAction]?)?
		func tableView(_ tableView: UITableView, editActionsForRowAt indexPath: IndexPath) -> [UITableViewRowAction]? {
			return editActionsForRow!(tableRowData(at: indexPath, in: tableView))
		}
		
		var editingStyleForRow: ((_ tableRowData: TableRow<RowData>) -> UITableViewCell.EditingStyle)?
		func tableView(_ tableView: UITableView, editingStyleForRowAt indexPath: IndexPath) -> UITableViewCell.EditingStyle {
			return editingStyleForRow!(tableRowData(at: indexPath, in: tableView))
		}
		
		var estimatedHeightForFooter: ((_ section: Int) -> CGFloat)?
		func tableView(_ tableView: UITableView, estimatedHeightForFooterInSection section: Int) -> CGFloat {
			return estimatedHeightForFooter!(section)
		}
		
		var estimatedHeightForHeader: ((_ section: Int) -> CGFloat)?
		func tableView(_ tableView: UITableView, estimatedHeightForHeaderInSection section: Int) -> CGFloat {
			return estimatedHeightForHeader!(section)
		}
		
		var estimatedHeightForRow: ((_ tableRowData: TableRow<RowData>) -> CGFloat)?
		func tableView(_ tableView: UITableView, estimatedHeightForRowAt indexPath: IndexPath) -> CGFloat {
			return estimatedHeightForRow!(tableRowData(at: indexPath, in: tableView))
		}
		
		var footerHeight: ((_ section: Int) -> CGFloat)?
		func tableView(_ tableView: UITableView, heightForFooterInSection section: Int) -> CGFloat {
			return footerHeight!(section)
		}
		
		var footerView: ((_ section: Int, _ title: String?) -> ViewConvertible?)?
		func tableView(_ tableView: UITableView, viewForFooterInSection section: Int) -> UIView? {
			return footerView!(section, tableView.dataSource?.tableView?(tableView, titleForFooterInSection: section))?.uiView()
		}
		
		var headerHeight: ((_ section: Int) -> CGFloat)?
		func tableView(_ tableView: UITableView, heightForHeaderInSection section: Int) -> CGFloat {
			return headerHeight!(section)
		}
		
		var headerView: ((_ section: Int, _ title: String?) -> ViewConvertible?)?
		func tableView(_ tableView: UITableView, viewForHeaderInSection section: Int) -> UIView? {
			return headerView!(section, tableView.dataSource?.tableView?(tableView, titleForHeaderInSection: section))?.uiView()
		}
		
		var heightForRow: ((_ tableRowData: TableRow<RowData>) -> CGFloat)?
		func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {
			return heightForRow!(tableRowData(at: indexPath, in: tableView))
		}
		
		var indentationLevelForRow: ((_ tableRowData: TableRow<RowData>) -> Int)?
		func tableView(_ tableView: UITableView, indentationLevelForRowAt indexPath: IndexPath) -> Int {
			return indentationLevelForRow!(tableRowData(at: indexPath, in: tableView))
		}
		
		var indexPathForPreferred: ((UITableView) -> IndexPath)?
		func indexPathForPreferredFocusedView(in tableView: UITableView) -> IndexPath? {
			return indexPathForPreferred!(tableView)
		}
		
		var moveRow: SignalInput<(from: TableRow<RowData>, to: IndexPath)>?
		func tableView(_ tableView: UITableView, moveRowAt sourceIndexPath: IndexPath, to destinationIndexPath: IndexPath) {
			moveRow!.send(value: (from: tableRowData(at: sourceIndexPath, in: tableView), to: destinationIndexPath))
		}
		
		var shouldHighlightRow: ((_ tableRowData: TableRow<RowData>) -> Bool)?
		func tableView(_ tableView: UITableView, shouldHighlightRowAt indexPath: IndexPath) -> Bool {
			return shouldHighlightRow!(tableRowData(at: indexPath, in: tableView))
		}
		
		var shouldIndentWhileEditingRow: ((_ tableRowData: TableRow<RowData>) -> Bool)?
		func tableView(_ tableView: UITableView, shouldIndentWhileEditingRowAt indexPath: IndexPath) -> Bool {
			return shouldIndentWhileEditingRow!(tableRowData(at: indexPath, in: tableView))
		}
		
		var shouldShowMenuForRow: ((_ tableRowData: TableRow<RowData>) -> Bool)?
		func tableView(_ tableView: UITableView, shouldShowMenuForRowAt indexPath: IndexPath) -> Bool {
			return shouldShowMenuForRow!(tableRowData(at: indexPath, in: tableView))
		}
		
		var shouldUpdateFocus: ((UITableView, UITableViewFocusUpdateContext) -> Bool)?
		func tableView(_ tableView: UITableView, shouldUpdateFocusIn context: UITableViewFocusUpdateContext) -> Bool {
			return shouldUpdateFocus!(tableView, context)
		}
		
		var targetIndexPathForMoveFromRow: ((_ tableView: UITableView, _ sourceIndexPath: IndexPath, _ proposedIndexPath: IndexPath) -> IndexPath)?
		func tableView(_ tableView: UITableView, targetIndexPathForMoveFromRowAt sourceIndexPath: IndexPath, toProposedIndexPath proposedDestinationIndexPath: IndexPath) -> IndexPath {
			return targetIndexPathForMoveFromRow!(tableView, sourceIndexPath, proposedDestinationIndexPath)
		}
		
		var titleForDeleteConfirmationButtonForRow: ((_ tableRowData: TableRow<RowData>) -> String?)?
		func tableView(_ tableView: UITableView, titleForDeleteConfirmationButtonForRowAt indexPath: IndexPath) -> String? {
			return titleForDeleteConfirmationButtonForRow!(tableRowData(at: indexPath, in: tableView))
		}
		
		var willBeginEditingRow: ((_ tableView: UITableView, _ tableRowData: TableRow<RowData>) -> Void)?
		func tableView(_ tableView: UITableView, willBeginEditingRowAt indexPath: IndexPath) {
			willBeginEditingRow!(tableView, tableRowData(at: indexPath, in: tableView))
		}
		
		var willDeselectRow: ((_ tableView: UITableView, _ tableRowData: TableRow<RowData>) -> IndexPath?)?
		func tableView(_ tableView: UITableView, willDeselectRowAt indexPath: IndexPath) -> IndexPath? {
			return willDeselectRow!(tableView, tableRowData(at: indexPath, in: tableView))
		}
		
		var willDisplayFooter: ((_ tableView: UITableView, _ section: Int, _ view: UIView) -> Void)?
		func tableView(_ tableView: UITableView, willDisplayFooterView view: UIView, forSection section: Int) {
			willDisplayFooter!(tableView, section, view)
		}
		
		var willDisplayHeader: ((_ tableView: UITableView, _ section: Int, _ view: UIView) -> Void)?
		func tableView(_ tableView: UITableView, willDisplayHeaderView view: UIView, forSection section: Int) {
			willDisplayHeader!(tableView, section, view)
		}
		
		var willDisplayRow: ((_ tableView: UITableView, _ indexPath: IndexPath, _ cell: UITableViewCell) -> Void)?
		func tableView(_ tableView: UITableView, willDisplay cell: UITableViewCell, forRowAt indexPath: IndexPath) {
			willDisplayRow?(tableView, indexPath, cell)
			(tableView.delegate as? Storage)?.notifyVisibleRowsChanged(in: tableView)
		}
		
		var willSelectRow: ((_ tableView: UITableView, _ tableRowData: TableRow<RowData>) -> IndexPath?)?
		func tableView(_ tableView: UITableView, willSelectRowAt indexPath: IndexPath) -> IndexPath? {
			return willSelectRow!(tableView, tableRowData(at: indexPath, in: tableView))
		}
		
		var commit: SignalInput<(editingStyle: UITableViewCell.EditingStyle, row: TableRow<RowData>)>?
		func tableView(_ tableView: UITableView, commit editingStyle: UITableViewCell.EditingStyle, forRowAt indexPath: IndexPath) {
			commit?.send(value: (editingStyle, tableRowData(at: indexPath, in: tableView)))
		}
	}
}

extension BindingName where Binding: TableViewBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .tableViewBinding(TableView.Binding.$1(v)) }) }
	static var cellIdentifier: BindingName<(TableRow<Binding.RowDataType>) -> String?, Binding> { return BindingName<(TableRow<Binding.RowDataType>) -> String?, Binding>({ v in .tableViewBinding(TableView.Binding.cellIdentifier(v)) }) }
	static var tableViewStyle: BindingName<Constant<UITableView.Style>, Binding> { return BindingName<Constant<UITableView.Style>, Binding>({ v in .tableViewBinding(TableView.Binding.tableViewStyle(v)) }) }
	static var allowsMultipleSelection: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .tableViewBinding(TableView.Binding.allowsMultipleSelection(v)) }) }
	static var allowsMultipleSelectionDuringEditing: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .tableViewBinding(TableView.Binding.allowsMultipleSelectionDuringEditing(v)) }) }
	static var allowsSelection: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .tableViewBinding(TableView.Binding.allowsSelection(v)) }) }
	static var allowsSelectionDuringEditing: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .tableViewBinding(TableView.Binding.allowsSelectionDuringEditing(v)) }) }
	static var backgroundView: BindingName<Dynamic<ViewConvertible?>, Binding> { return BindingName<Dynamic<ViewConvertible?>, Binding>({ v in .tableViewBinding(TableView.Binding.backgroundView(v)) }) }
	static var cellLayoutMarginsFollowReadableWidth: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .tableViewBinding(TableView.Binding.cellLayoutMarginsFollowReadableWidth(v)) }) }
	static var isEditing: BindingName<Signal<SetOrAnimate<Bool>>, Binding> { return BindingName<Signal<SetOrAnimate<Bool>>, Binding>({ v in .tableViewBinding(TableView.Binding.isEditing(v)) }) }
	static var estimatedRowHeight: BindingName<Dynamic<CGFloat>, Binding> { return BindingName<Dynamic<CGFloat>, Binding>({ v in .tableViewBinding(TableView.Binding.estimatedRowHeight(v)) }) }
	static var estimatedSectionFooterHeight: BindingName<Dynamic<CGFloat>, Binding> { return BindingName<Dynamic<CGFloat>, Binding>({ v in .tableViewBinding(TableView.Binding.estimatedSectionFooterHeight(v)) }) }
	static var estimatedSectionHeaderHeight: BindingName<Dynamic<CGFloat>, Binding> { return BindingName<Dynamic<CGFloat>, Binding>({ v in .tableViewBinding(TableView.Binding.estimatedSectionHeaderHeight(v)) }) }
	static var remembersLastFocusedIndexPath: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .tableViewBinding(TableView.Binding.remembersLastFocusedIndexPath(v)) }) }
	static var rowHeight: BindingName<Dynamic<CGFloat>, Binding> { return BindingName<Dynamic<CGFloat>, Binding>({ v in .tableViewBinding(TableView.Binding.rowHeight(v)) }) }
	static var sectionFooterHeight: BindingName<Dynamic<CGFloat>, Binding> { return BindingName<Dynamic<CGFloat>, Binding>({ v in .tableViewBinding(TableView.Binding.sectionFooterHeight(v)) }) }
	static var sectionHeaderHeight: BindingName<Dynamic<CGFloat>, Binding> { return BindingName<Dynamic<CGFloat>, Binding>({ v in .tableViewBinding(TableView.Binding.sectionHeaderHeight(v)) }) }
	static var sectionIndexBackgroundColor: BindingName<Dynamic<UIColor?>, Binding> { return BindingName<Dynamic<UIColor?>, Binding>({ v in .tableViewBinding(TableView.Binding.sectionIndexBackgroundColor(v)) }) }
	static var sectionIndexColor: BindingName<Dynamic<UIColor?>, Binding> { return BindingName<Dynamic<UIColor?>, Binding>({ v in .tableViewBinding(TableView.Binding.sectionIndexColor(v)) }) }
	static var sectionIndexMinimumDisplayRowCount: BindingName<Dynamic<Int>, Binding> { return BindingName<Dynamic<Int>, Binding>({ v in .tableViewBinding(TableView.Binding.sectionIndexMinimumDisplayRowCount(v)) }) }
	static var sectionIndexTrackingBackgroundColor: BindingName<Dynamic<UIColor?>, Binding> { return BindingName<Dynamic<UIColor?>, Binding>({ v in .tableViewBinding(TableView.Binding.sectionIndexTrackingBackgroundColor(v)) }) }
	static var sectionIndexTitles: BindingName<Dynamic<[String]?>, Binding> { return BindingName<Dynamic<[String]?>, Binding>({ v in .tableViewBinding(TableView.Binding.sectionIndexTitles(v)) }) }
	static var separatorColor: BindingName<Dynamic<UIColor?>, Binding> { return BindingName<Dynamic<UIColor?>, Binding>({ v in .tableViewBinding(TableView.Binding.separatorColor(v)) }) }
	static var separatorEffect: BindingName<Dynamic<UIVisualEffect?>, Binding> { return BindingName<Dynamic<UIVisualEffect?>, Binding>({ v in .tableViewBinding(TableView.Binding.separatorEffect(v)) }) }
	static var separatorInset: BindingName<Dynamic<UIEdgeInsets>, Binding> { return BindingName<Dynamic<UIEdgeInsets>, Binding>({ v in .tableViewBinding(TableView.Binding.separatorInset(v)) }) }
	static var separatorStyle: BindingName<Dynamic<UITableViewCell.SeparatorStyle>, Binding> { return BindingName<Dynamic<UITableViewCell.SeparatorStyle>, Binding>({ v in .tableViewBinding(TableView.Binding.separatorStyle(v)) }) }
	static var tableFooterView: BindingName<Dynamic<ViewConvertible?>, Binding> { return BindingName<Dynamic<ViewConvertible?>, Binding>({ v in .tableViewBinding(TableView.Binding.tableFooterView(v)) }) }
	static var tableHeaderView: BindingName<Dynamic<ViewConvertible?>, Binding> { return BindingName<Dynamic<ViewConvertible?>, Binding>({ v in .tableViewBinding(TableView.Binding.tableHeaderView(v)) }) }
	static var tableData: BindingName<Dynamic<TableData<Binding.RowDataType>>, Binding> { return BindingName<Dynamic<TableData<Binding.RowDataType>>, Binding>({ v in .tableViewBinding(TableView.Binding.tableData(v)) }) }
	static var deselectRow: BindingName<Signal<SetOrAnimate<IndexPath>>, Binding> { return BindingName<Signal<SetOrAnimate<IndexPath>>, Binding>({ v in .tableViewBinding(TableView.Binding.deselectRow(v)) }) }
	static var scrollToNearestSelectedRow: BindingName<Signal<SetOrAnimate<UITableView.ScrollPosition>>, Binding> { return BindingName<Signal<SetOrAnimate<UITableView.ScrollPosition>>, Binding>({ v in .tableViewBinding(TableView.Binding.scrollToNearestSelectedRow(v)) }) }
	static var scrollToRow: BindingName<Signal<SetOrAnimate<TableScrollPosition>>, Binding> { return BindingName<Signal<SetOrAnimate<TableScrollPosition>>, Binding>({ v in .tableViewBinding(TableView.Binding.scrollToRow(v)) }) }
	static var selectRow: BindingName<Signal<SetOrAnimate<TableScrollPosition?>>, Binding> { return BindingName<Signal<SetOrAnimate<TableScrollPosition?>>, Binding>({ v in .tableViewBinding(TableView.Binding.selectRow(v)) }) }
	static var userDidScrollToRow: BindingName<SignalInput<TableRow<Binding.RowDataType>>, Binding> { return BindingName<SignalInput<TableRow<Binding.RowDataType>>, Binding>({ v in .tableViewBinding(TableView.Binding.userDidScrollToRow(v)) }) }
	static var accessoryButtonTapped: BindingName<SignalInput<TableRow<Binding.RowDataType>>, Binding> { return BindingName<SignalInput<TableRow<Binding.RowDataType>>, Binding>({ v in .tableViewBinding(TableView.Binding.accessoryButtonTapped(v)) }) }
	static var didDeselectRow: BindingName<SignalInput<TableRow<Binding.RowDataType>>, Binding> { return BindingName<SignalInput<TableRow<Binding.RowDataType>>, Binding>({ v in .tableViewBinding(TableView.Binding.didDeselectRow(v)) }) }
	static var didEndDisplayingFooter: BindingName<SignalInput<Int>, Binding> { return BindingName<SignalInput<Int>, Binding>({ v in .tableViewBinding(TableView.Binding.didEndDisplayingFooter(v)) }) }
	static var didEndDisplayingHeader: BindingName<SignalInput<Int>, Binding> { return BindingName<SignalInput<Int>, Binding>({ v in .tableViewBinding(TableView.Binding.didEndDisplayingHeader(v)) }) }
	static var didEndDisplayingRow: BindingName<SignalInput<TableRow<Binding.RowDataType>>, Binding> { return BindingName<SignalInput<TableRow<Binding.RowDataType>>, Binding>({ v in .tableViewBinding(TableView.Binding.didEndDisplayingRow(v)) }) }
	static var didEndEditingRow: BindingName<SignalInput<TableRow<Binding.RowDataType>?>, Binding> { return BindingName<SignalInput<TableRow<Binding.RowDataType>?>, Binding>({ v in .tableViewBinding(TableView.Binding.didEndEditingRow(v)) }) }
	static var didHightlightRow: BindingName<SignalInput<TableRow<Binding.RowDataType>>, Binding> { return BindingName<SignalInput<TableRow<Binding.RowDataType>>, Binding>({ v in .tableViewBinding(TableView.Binding.didHightlightRow(v)) }) }
	static var didSelectRow: BindingName<SignalInput<TableRow<Binding.RowDataType>>, Binding> { return BindingName<SignalInput<TableRow<Binding.RowDataType>>, Binding>({ v in .tableViewBinding(TableView.Binding.didSelectRow(v)) }) }
	static var didUnhighlightRow: BindingName<SignalInput<TableRow<Binding.RowDataType>>, Binding> { return BindingName<SignalInput<TableRow<Binding.RowDataType>>, Binding>({ v in .tableViewBinding(TableView.Binding.didUnhighlightRow(v)) }) }
	static var moveRow: BindingName<SignalInput<(from: TableRow<Binding.RowDataType>, to: IndexPath)>, Binding> { return BindingName<SignalInput<(from: TableRow<Binding.RowDataType>, to: IndexPath)>, Binding>({ v in .tableViewBinding(TableView.Binding.moveRow(v)) }) }
	static var selectionDidChange: BindingName<SignalInput<[TableRow<Binding.RowDataType>]?>, Binding> { return BindingName<SignalInput<[TableRow<Binding.RowDataType>]?>, Binding>({ v in .tableViewBinding(TableView.Binding.selectionDidChange(v)) }) }
	static var visibleRowsChanged: BindingName<SignalInput<[TableRow<Binding.RowDataType>]>, Binding> { return BindingName<SignalInput<[TableRow<Binding.RowDataType>]>, Binding>({ v in .tableViewBinding(TableView.Binding.visibleRowsChanged(v)) }) }
	static var commit: BindingName<SignalInput<(editingStyle: UITableViewCell.EditingStyle, row: TableRow<Binding.RowDataType>)>, Binding> { return BindingName<SignalInput<(editingStyle: UITableViewCell.EditingStyle, row: TableRow<Binding.RowDataType>)>, Binding>({ v in .tableViewBinding(TableView.Binding.commit(v)) }) }
	static var canEditRow: BindingName<(_ tableRowData: TableRow<Binding.RowDataType>) -> Bool, Binding> { return BindingName<(_ tableRowData: TableRow<Binding.RowDataType>) -> Bool, Binding>({ v in .tableViewBinding(TableView.Binding.canEditRow(v)) }) }
	static var canFocusRow: BindingName<(_ tableRowData: TableRow<Binding.RowDataType>) -> Bool, Binding> { return BindingName<(_ tableRowData: TableRow<Binding.RowDataType>) -> Bool, Binding>({ v in .tableViewBinding(TableView.Binding.canFocusRow(v)) }) }
	static var canMoveRow: BindingName<(_ tableRowData: TableRow<Binding.RowDataType>) -> Bool, Binding> { return BindingName<(_ tableRowData: TableRow<Binding.RowDataType>) -> Bool, Binding>({ v in .tableViewBinding(TableView.Binding.canMoveRow(v)) }) }
	static var canPerformAction: BindingName<(_ action: Selector, _ tableRowData: TableRow<Binding.RowDataType>, _ sender: Any?) -> Bool, Binding> { return BindingName<(_ action: Selector, _ tableRowData: TableRow<Binding.RowDataType>, _ sender: Any?) -> Bool, Binding>({ v in .tableViewBinding(TableView.Binding.canPerformAction(v)) }) }
	static var cellConstructor: BindingName<(_ identifier: String?, _ rowSignal: Signal<Binding.RowDataType>) -> TableViewCellConvertible, Binding> { return BindingName<(_ identifier: String?, _ rowSignal: Signal<Binding.RowDataType>) -> TableViewCellConvertible, Binding>({ v in .tableViewBinding(TableView.Binding.cellConstructor(v)) }) }
	static var dataMissingCell: BindingName<(IndexPath) -> TableViewCellConvertible, Binding> { return BindingName<(IndexPath) -> TableViewCellConvertible, Binding>({ v in .tableViewBinding(TableView.Binding.dataMissingCell(v)) }) }
	static var didUpdateFocus: BindingName<(UITableView, UITableViewFocusUpdateContext, UIFocusAnimationCoordinator) -> Void, Binding> { return BindingName<(UITableView, UITableViewFocusUpdateContext, UIFocusAnimationCoordinator) -> Void, Binding>({ v in .tableViewBinding(TableView.Binding.didUpdateFocus(v)) }) }
	static var editActionsForRow: BindingName<(_ tableRowData: TableRow<Binding.RowDataType>) -> [UITableViewRowAction]?, Binding> { return BindingName<(_ tableRowData: TableRow<Binding.RowDataType>) -> [UITableViewRowAction]?, Binding>({ v in .tableViewBinding(TableView.Binding.editActionsForRow(v)) }) }
	static var editingStyleForRow: BindingName<(_ tableRowData: TableRow<Binding.RowDataType>) -> UITableViewCell.EditingStyle, Binding> { return BindingName<(_ tableRowData: TableRow<Binding.RowDataType>) -> UITableViewCell.EditingStyle, Binding>({ v in .tableViewBinding(TableView.Binding.editingStyleForRow(v)) }) }
	static var estimatedHeightForFooter: BindingName<(_ section: Int) -> CGFloat, Binding> { return BindingName<(_ section: Int) -> CGFloat, Binding>({ v in .tableViewBinding(TableView.Binding.estimatedHeightForFooter(v)) }) }
	static var estimatedHeightForHeader: BindingName<(_ section: Int) -> CGFloat, Binding> { return BindingName<(_ section: Int) -> CGFloat, Binding>({ v in .tableViewBinding(TableView.Binding.estimatedHeightForHeader(v)) }) }
	static var estimatedHeightForRow: BindingName<(_ tableRowData: TableRow<Binding.RowDataType>) -> CGFloat, Binding> { return BindingName<(_ tableRowData: TableRow<Binding.RowDataType>) -> CGFloat, Binding>({ v in .tableViewBinding(TableView.Binding.estimatedHeightForRow(v)) }) }
	static var footerHeight: BindingName<(_ section: Int) -> CGFloat, Binding> { return BindingName<(_ section: Int) -> CGFloat, Binding>({ v in .tableViewBinding(TableView.Binding.footerHeight(v)) }) }
	static var footerView: BindingName<(_ section: Int, _ title: String?) -> ViewConvertible?, Binding> { return BindingName<(_ section: Int, _ title: String?) -> ViewConvertible?, Binding>({ v in .tableViewBinding(TableView.Binding.footerView(v)) }) }
	static var headerHeight: BindingName<(_ section: Int) -> CGFloat, Binding> { return BindingName<(_ section: Int) -> CGFloat, Binding>({ v in .tableViewBinding(TableView.Binding.headerHeight(v)) }) }
	static var headerView: BindingName<(_ section: Int, _ title: String?) -> ViewConvertible?, Binding> { return BindingName<(_ section: Int, _ title: String?) -> ViewConvertible?, Binding>({ v in .tableViewBinding(TableView.Binding.headerView(v)) }) }
	static var heightForRow: BindingName<(_ tableRowData: TableRow<Binding.RowDataType>) -> CGFloat, Binding> { return BindingName<(_ tableRowData: TableRow<Binding.RowDataType>) -> CGFloat, Binding>({ v in .tableViewBinding(TableView.Binding.heightForRow(v)) }) }
	static var indentationLevelForRow: BindingName<(_ tableRowData: TableRow<Binding.RowDataType>) -> Int, Binding> { return BindingName<(_ tableRowData: TableRow<Binding.RowDataType>) -> Int, Binding>({ v in .tableViewBinding(TableView.Binding.indentationLevelForRow(v)) }) }
	static var indexPathForPreferredFocusedView: BindingName<(UITableView) -> IndexPath, Binding> { return BindingName<(UITableView) -> IndexPath, Binding>({ v in .tableViewBinding(TableView.Binding.indexPathForPreferredFocusedView(v)) }) }
	static var shouldHighlightRow: BindingName<(_ tableRowData: TableRow<Binding.RowDataType>) -> Bool, Binding> { return BindingName<(_ tableRowData: TableRow<Binding.RowDataType>) -> Bool, Binding>({ v in .tableViewBinding(TableView.Binding.shouldHighlightRow(v)) }) }
	static var shouldIndentWhileEditingRow: BindingName<(_ tableRowData: TableRow<Binding.RowDataType>) -> Bool, Binding> { return BindingName<(_ tableRowData: TableRow<Binding.RowDataType>) -> Bool, Binding>({ v in .tableViewBinding(TableView.Binding.shouldIndentWhileEditingRow(v)) }) }
	static var shouldShowMenuForRow: BindingName<(_ tableRowData: TableRow<Binding.RowDataType>) -> Bool, Binding> { return BindingName<(_ tableRowData: TableRow<Binding.RowDataType>) -> Bool, Binding>({ v in .tableViewBinding(TableView.Binding.shouldShowMenuForRow(v)) }) }
	static var shouldUpdateFocus: BindingName<(UITableView, UITableViewFocusUpdateContext) -> Bool, Binding> { return BindingName<(UITableView, UITableViewFocusUpdateContext) -> Bool, Binding>({ v in .tableViewBinding(TableView.Binding.shouldUpdateFocus(v)) }) }
	static var targetIndexPathForMoveFromRow: BindingName<(_ tableView: UITableView, _ sourceIndexPath: IndexPath, _ proposedIndexPath: IndexPath) -> IndexPath, Binding> { return BindingName<(_ tableView: UITableView, _ sourceIndexPath: IndexPath, _ proposedIndexPath: IndexPath) -> IndexPath, Binding>({ v in .tableViewBinding(TableView.Binding.targetIndexPathForMoveFromRow(v)) }) }
	static var titleForDeleteConfirmationButtonForRow: BindingName<(_ tableRowData: TableRow<Binding.RowDataType>) -> String?, Binding> { return BindingName<(_ tableRowData: TableRow<Binding.RowDataType>) -> String?, Binding>({ v in .tableViewBinding(TableView.Binding.titleForDeleteConfirmationButtonForRow(v)) }) }
	static var willBeginEditingRow: BindingName<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> Void, Binding> { return BindingName<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> Void, Binding>({ v in .tableViewBinding(TableView.Binding.willBeginEditingRow(v)) }) }
	static var willDeselectRow: BindingName<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> IndexPath?, Binding> { return BindingName<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> IndexPath?, Binding>({ v in .tableViewBinding(TableView.Binding.willDeselectRow(v)) }) }
	static var willDisplayFooter: BindingName<(_ tableView: UITableView, _ section: Int, _ view: UIView) -> Void, Binding> { return BindingName<(_ tableView: UITableView, _ section: Int, _ view: UIView) -> Void, Binding>({ v in .tableViewBinding(TableView.Binding.willDisplayFooter(v)) }) }
	static var willDisplayHeader: BindingName<(_ tableView: UITableView, _ section: Int, _ view: UIView) -> Void, Binding> { return BindingName<(_ tableView: UITableView, _ section: Int, _ view: UIView) -> Void, Binding>({ v in .tableViewBinding(TableView.Binding.willDisplayHeader(v)) }) }
	static var willDisplayRow: BindingName<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>, _ cell: UITableViewCell) -> Void, Binding> { return BindingName<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>, _ cell: UITableViewCell) -> Void, Binding>({ v in .tableViewBinding(TableView.Binding.willDisplayRow(v)) }) }
	static var willSelectRow: BindingName<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> IndexPath?, Binding> { return BindingName<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> IndexPath?, Binding>({ v in .tableViewBinding(TableView.Binding.willSelectRow(v)) }) }
}

protocol TableViewConvertible: ScrollViewConvertible {
	func uiTableView() -> UITableView
}
extension TableViewConvertible {
	func uiScrollView() -> ScrollView.Instance { return uiTableView() }
}
extension TableView.Instance: TableViewConvertible {
	func uiTableView() -> UITableView { return self }
}

protocol TableViewBinding: ScrollViewBinding {
	associatedtype RowDataType
	static func tableViewBinding(_ binding: TableView<RowDataType>.Binding) -> Self
}
extension TableViewBinding {
	static func scrollViewBinding(_ binding: ScrollView.Binding) -> Self {
		return tableViewBinding(.inheritedBinding(binding))
	}
}

typealias TableData<RowData> = TableRowMutation<TableSectionMutation<RowData>>

struct TableScrollPosition {
	let indexPath: IndexPath
	let position: UITableView.ScrollPosition
	init(indexPath: IndexPath, position: UITableView.ScrollPosition = .none) {
		self.indexPath = indexPath
		self.position = position
	}
	
	static func none(_ indexPath: IndexPath) -> TableScrollPosition {
		return TableScrollPosition(indexPath: indexPath, position: .none)
	}
	
	static func top(_ indexPath: IndexPath) -> TableScrollPosition {
		return TableScrollPosition(indexPath: indexPath, position: .top)
	}
	
	static func middle(_ indexPath: IndexPath) -> TableScrollPosition {
		return TableScrollPosition(indexPath: indexPath, position: .middle)
	}
	
	static func bottom(_ indexPath: IndexPath) -> TableScrollPosition {
		return TableScrollPosition(indexPath: indexPath, position: .bottom)
	}
}

func updateFirstRow<RowData>(_ storage: Var<IndexPath?>) -> SignalInput<[TableRow<RowData>]> {
	return Input().map { $0.first?.indexPath }.bind(to: storage.updatingInput)
}

extension SignalInterface where OutputValue == IndexPath? {
	func restoreFirstRow() -> Signal<SetOrAnimate<TableScrollPosition>> {
		return compactMap { $0.map { .top($0) } }.animate(.none)
	}
}

struct TableRow<RowData> {
	let indexPath: IndexPath
	let data: RowData?
	
	init(indexPath: IndexPath, data: RowData?) {
		self.indexPath = indexPath
		self.data = data
	}
}

class TextField: ConstructingBinder, TextFieldConvertible {
	typealias Instance = UITextField
	typealias Inherited = Control
	
	var state: ConstructingBinderState<Instance, Binding>
	required init(state: ConstructingBinderState<Instance, Binding>) {
		self.state = state
	}
	static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	func uiTextField() -> Instance { return instance() }
	
	enum Binding: TextFieldBinding {
		typealias EnclosingBinder = TextField
		static func textFieldBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case textInputTraits(Constant<TextInputTraits>)
		
		//	1. Value bindings may be applied at construction and may subsequently change.
		case text(Dynamic<String>)
		case attributedText(Dynamic<NSAttributedString?>)
		case placeholder(Dynamic<String?>)
		case attributedPlaceholder(Dynamic<NSAttributedString?>)
		case defaultTextAttributes(Dynamic<[NSAttributedString.Key: Any]>)
		case font(Dynamic<UIFont?>)
		case textColor(Dynamic<UIColor?>)
		case textAlignment(Dynamic<NSTextAlignment>)
		case typingAttributes(Dynamic<[NSAttributedString.Key: Any]?>)
		case adjustsFontSizeToFitWidth(Dynamic<Bool>)
		case minimumFontSize(Dynamic<CGFloat>)
		case clearsOnBeginEditing(Dynamic<Bool>)
		case clearsOnInsertion(Dynamic<Bool>)
		case allowsEditingTextAttributes(Dynamic<Bool>)
		case borderStyle(Dynamic<UITextField.BorderStyle>)
		case background(Dynamic<UIImage?>)
		case disabledBackground(Dynamic<UIImage?>)
		case clearButtonMode(Dynamic<UITextField.ViewMode>)
		case leftView(Dynamic<ViewConvertible?>)
		case leftViewMode(Dynamic<UITextField.ViewMode>)
		case rightView(Dynamic<ViewConvertible?>)
		case rightViewMode(Dynamic<UITextField.ViewMode>)
		case inputView(Dynamic<ViewConvertible?>)
		case inputAccessoryView(Dynamic<ViewConvertible?>)
		
		//	2. Signal bindings are performed on the object after construction.
		case resignFirstResponder(Signal<Void>)
		
		//	3. Action bindings are triggered by the object after construction.
		
		//	4. Delegate bindings require synchronous evaluation within the object's context.
		case didBeginEditing((_ textField: UITextField) -> Void)
		case didChange((_ textField: UITextField) -> Void)
		case didEndEditing((_ textField: UITextField) -> Void)
		@available(iOS 10.0, *)
		case didEndEditingWithReason((_ textField: UITextField, _ reason: UITextField.DidEndEditingReason) -> Void)
		case shouldBeginEditing((_ textField: UITextField) -> Bool)
		case shouldEndEditing((_ textField: UITextField) -> Bool)
		case shouldChangeCharacters((_ textField: UITextField, _ range: NSRange, _ replacementString: String) -> Bool)
		case shouldClear((_ textField: UITextField) -> Bool)
		case shouldReturn((_ textField: UITextField) -> Bool)
	}
	
	struct Preparer: ConstructingPreparer {
		typealias EnclosingBinder = TextField
		var linkedPreparer = Inherited.Preparer()
		
		func constructStorage() -> EnclosingBinder.Storage { return Storage() }
		func constructInstance(subclass: EnclosingBinder.Instance.Type) -> EnclosingBinder.Instance { return subclass.init() }
		
		init() {
			self.init(delegateClass: Delegate.self)
		}
		init<Value>(delegateClass: Value.Type) where Value: Delegate {
			self.delegateClass = delegateClass
		}
		let delegateClass: Delegate.Type
		var possibleDelegate: Delegate? = nil
		mutating func delegate() -> Delegate {
			if let d = possibleDelegate {
				return d
			} else {
				let d = delegateClass.init()
				possibleDelegate = d
				return d
			}
		}
		
		mutating func prepareBinding(_ binding: Binding) {
			switch binding {
			case .didEndEditingWithReason(let x):
				if #available(iOS 10.0, *) {
					let s = #selector(UITextFieldDelegate.textFieldDidEndEditing(_:reason:))
					delegate().addSelector(s).didEndEditingWithReason = x
				}
			case .shouldBeginEditing(let x):
				let s = #selector(UITextFieldDelegate.textFieldShouldBeginEditing(_:))
				delegate().addSelector(s).shouldBeginEditing = x
			case .shouldEndEditing(let x):
				let s = #selector(UITextFieldDelegate.textFieldShouldEndEditing(_:))
				delegate().addSelector(s).shouldEndEditing = x
			case .shouldChangeCharacters(let x):
				let s = #selector(UITextFieldDelegate.textField(_:shouldChangeCharactersIn:replacementString:))
				delegate().addSelector(s).shouldChangeCharacters = x
			case .shouldClear(let x):
				let s = #selector(UITextFieldDelegate.textFieldShouldClear(_:))
				delegate().addSelector(s).shouldClear = x
			case .shouldReturn(let x):
				let s = #selector(UITextFieldDelegate.textFieldShouldReturn(_:))
				delegate().addSelector(s).shouldReturn = x
			case .inheritedBinding(let x): linkedPreparer.prepareBinding(x)
			default: break
			}
		}
		
		mutating func prepareInstance(_ instance: Instance, storage: Storage) {
			precondition(instance.delegate == nil, "Conflicting delegate applied to instance")
			storage.dynamicDelegate = possibleDelegate
			if storage.inUse {
				instance.delegate = storage
			}
			
			linkedPreparer.prepareInstance(instance, storage: storage)
		}
		
		func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
			switch binding {
			case .textInputTraits(let x):
				return AggregateLifetime(lifetimes: x.value.bindings.lazy.compactMap { trait in
					switch trait {
					case .autocapitalizationType(let y): return y.apply(instance, storage) { i, s, v in i.autocapitalizationType = v }
					case .autocorrectionType(let y): return y.apply(instance, storage) { i, s, v in i.autocorrectionType = v }
					case .spellCheckingType(let y): return y.apply(instance, storage) { i, s, v in i.spellCheckingType = v }
					case .enablesReturnKeyAutomatically(let y): return y.apply(instance, storage) { i, s, v in i.enablesReturnKeyAutomatically = v }
					case .keyboardAppearance(let y): return y.apply(instance, storage) { i, s, v in i.keyboardAppearance = v }
					case .keyboardType(let y): return y.apply(instance, storage) { i, s, v in i.keyboardType = v }
					case .returnKeyType(let y): return y.apply(instance, storage) { i, s, v in i.returnKeyType = v }
					case .isSecureTextEntry(let y): return y.apply(instance, storage) { i, s, v in i.isSecureTextEntry = v }
					case .textContentType(let y):
						return y.apply(instance, storage) { i, s, v in
							if #available(iOS 10.0, *) {
								i.textContentType = v
							}
						}
					case .smartDashesType(let x):
						return x.apply(instance, storage) { i, s, v in
							if #available(iOS 11.0, *) {
								i.smartDashesType = v
							}
						}
					case .smartQuotesType(let x):
						return x.apply(instance, storage) { i, s, v in
							if #available(iOS 11.0, *) {
								i.smartQuotesType = v
							}
						}
					case .smartInsertDeleteType(let x):
						return x.apply(instance, storage) { i, s, v in
							if #available(iOS 11.0, *) {
								i.smartInsertDeleteType = v
							}
						}
					}
				})
			case .text(let x): return x.apply(instance, storage) { i, s, v in i.text = v }
			case .attributedText(let x): return x.apply(instance, storage) { i, s, v in i.attributedText = v }
			case .placeholder(let x): return x.apply(instance, storage) { i, s, v in i.placeholder = v }
			case .attributedPlaceholder(let x): return x.apply(instance, storage) { i, s, v in i.attributedPlaceholder = v }
			case .defaultTextAttributes(let x): return x.apply(instance, storage) { i, s, v in i.defaultTextAttributes = v }
			case .font(let x): return x.apply(instance, storage) { i, s, v in i.font = v }
			case .textColor(let x): return x.apply(instance, storage) { i, s, v in i.textColor = v }
			case .textAlignment(let x): return x.apply(instance, storage) { i, s, v in i.textAlignment = v }
			case .typingAttributes(let x): return x.apply(instance, storage) { i, s, v in i.typingAttributes = v }
			case .adjustsFontSizeToFitWidth(let x): return x.apply(instance, storage) { i, s, v in i.adjustsFontSizeToFitWidth = v }
			case .minimumFontSize(let x): return x.apply(instance, storage) { i, s, v in i.minimumFontSize = v }
			case .clearsOnBeginEditing(let x): return x.apply(instance, storage) { i, s, v in i.clearsOnBeginEditing = v }
			case .clearsOnInsertion(let x): return x.apply(instance, storage) { i, s, v in i.clearsOnInsertion = v }
			case .allowsEditingTextAttributes(let x): return x.apply(instance, storage) { i, s, v in i.allowsEditingTextAttributes = v }
			case .borderStyle(let x): return x.apply(instance, storage) { i, s, v in i.borderStyle = v }
			case .background(let x): return x.apply(instance, storage) { i, s, v in i.background = v }
			case .disabledBackground(let x): return x.apply(instance, storage) { i, s, v in i.disabledBackground = v }
			case .clearButtonMode(let x): return x.apply(instance, storage) { i, s, v in i.clearButtonMode = v }
			case .leftView(let x): return x.apply(instance, storage) { i, s, v in i.leftView = v?.uiView() }
			case .leftViewMode(let x): return x.apply(instance, storage) { i, s, v in i.leftViewMode = v }
			case .rightView(let x): return x.apply(instance, storage) { i, s, v in i.rightView = v?.uiView() }
			case .rightViewMode(let x): return x.apply(instance, storage) { i, s, v in i.rightViewMode = v }
			case .inputView(let x): return x.apply(instance, storage) { i, s, v in i.inputView = v?.uiView() }
			case .inputAccessoryView(let x): return x.apply(instance, storage) { i, s, v in i.inputAccessoryView = v?.uiView() }
			case .resignFirstResponder(let x): return x.apply(instance, storage) { i, s, v in i.resignFirstResponder() }
			case .didBeginEditing(let x):
				return Signal
					.notifications(name: UITextField.textDidBeginEditingNotification, object: instance)
					.compactMap { notification in return notification.object as? UITextField }
					.subscribeValues { field in x(field) }
			case .didEndEditing(let x):
				return Signal
					.notifications(name: UITextField.textDidEndEditingNotification, object: instance)
					.compactMap { notification in return notification.object as? UITextField }
					.subscribeValues { field in x(field) }
			case .didChange(let x):
				return Signal
					.notifications(name: UITextField.textDidChangeNotification, object: instance)
					.compactMap { notification in return notification.object as? UITextField }
					.subscribeValues { field in x(field) }
			case .didEndEditingWithReason: return nil
			case .shouldBeginEditing: return nil
			case .shouldEndEditing: return nil
			case .shouldChangeCharacters: return nil
			case .shouldClear: return nil
			case .shouldReturn: return nil
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: instance, storage: storage)
			}
		}
	}
	
	class Storage: Control.Storage, UITextFieldDelegate {}
	
	class Delegate: DynamicDelegate, UITextFieldDelegate {
		required override init() {
			super.init()
		}
		
		var shouldBeginEditing: ((_ textField: UITextField) -> Bool)?
		func textFieldShouldBeginEditing(_ textField: UITextField) -> Bool {
			return shouldBeginEditing!(textField)
		}
		
		var shouldEndEditing: ((_ textField: UITextField) -> Bool)?
		func textFieldShouldEndEditing(_ textField: UITextField) -> Bool {
			return shouldEndEditing!(textField)
		}
		
		var shouldChangeCharacters: ((_ textField: UITextField, _ range: NSRange, _ replacementString: String) -> Bool)?
		func textField(_ textField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String) -> Bool {
			return shouldChangeCharacters!(textField, range, string)
		}
		
		var shouldClear: ((_ textField: UITextField) -> Bool)?
		func textFieldShouldClear(_ textField: UITextField) -> Bool {
			return shouldClear!(textField)
		}
		
		var shouldReturn: ((_ textField: UITextField) -> Bool)?
		func textFieldShouldReturn(_ textField: UITextField) -> Bool {
			return shouldReturn!(textField)
		}
		
		var didEndEditingWithReason: Any?
		@available(iOS 10.0, *)
		func textFieldDidEndEditing(_ textField: UITextField, reason: UITextField.DidEndEditingReason) {
			(didEndEditingWithReason as! (UITextField, UITextField.DidEndEditingReason) -> Void)(textField, reason)
		}
	}
}

extension BindingName where Binding: TextFieldBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .textFieldBinding(TextField.Binding.$1(v)) }) }
	static var textInputTraits: BindingName<Constant<TextInputTraits>, Binding> { return BindingName<Constant<TextInputTraits>, Binding>({ v in .textFieldBinding(TextField.Binding.textInputTraits(v)) }) }
	static var text: BindingName<Dynamic<String>, Binding> { return BindingName<Dynamic<String>, Binding>({ v in .textFieldBinding(TextField.Binding.text(v)) }) }
	static var attributedText: BindingName<Dynamic<NSAttributedString?>, Binding> { return BindingName<Dynamic<NSAttributedString?>, Binding>({ v in .textFieldBinding(TextField.Binding.attributedText(v)) }) }
	static var placeholder: BindingName<Dynamic<String?>, Binding> { return BindingName<Dynamic<String?>, Binding>({ v in .textFieldBinding(TextField.Binding.placeholder(v)) }) }
	static var attributedPlaceholder: BindingName<Dynamic<NSAttributedString?>, Binding> { return BindingName<Dynamic<NSAttributedString?>, Binding>({ v in .textFieldBinding(TextField.Binding.attributedPlaceholder(v)) }) }
	static var defaultTextAttributes: BindingName<Dynamic<[NSAttributedString.Key: Any]>, Binding> { return BindingName<Dynamic<[NSAttributedString.Key: Any]>, Binding>({ v in .textFieldBinding(TextField.Binding.defaultTextAttributes(v)) }) }
	static var font: BindingName<Dynamic<UIFont?>, Binding> { return BindingName<Dynamic<UIFont?>, Binding>({ v in .textFieldBinding(TextField.Binding.font(v)) }) }
	static var textColor: BindingName<Dynamic<UIColor?>, Binding> { return BindingName<Dynamic<UIColor?>, Binding>({ v in .textFieldBinding(TextField.Binding.textColor(v)) }) }
	static var textAlignment: BindingName<Dynamic<NSTextAlignment>, Binding> { return BindingName<Dynamic<NSTextAlignment>, Binding>({ v in .textFieldBinding(TextField.Binding.textAlignment(v)) }) }
	static var typingAttributes: BindingName<Dynamic<[NSAttributedString.Key: Any]?>, Binding> { return BindingName<Dynamic<[NSAttributedString.Key: Any]?>, Binding>({ v in .textFieldBinding(TextField.Binding.typingAttributes(v)) }) }
	static var adjustsFontSizeToFitWidth: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .textFieldBinding(TextField.Binding.adjustsFontSizeToFitWidth(v)) }) }
	static var minimumFontSize: BindingName<Dynamic<CGFloat>, Binding> { return BindingName<Dynamic<CGFloat>, Binding>({ v in .textFieldBinding(TextField.Binding.minimumFontSize(v)) }) }
	static var clearsOnBeginEditing: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .textFieldBinding(TextField.Binding.clearsOnBeginEditing(v)) }) }
	static var clearsOnInsertion: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .textFieldBinding(TextField.Binding.clearsOnInsertion(v)) }) }
	static var allowsEditingTextAttributes: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .textFieldBinding(TextField.Binding.allowsEditingTextAttributes(v)) }) }
	static var borderStyle: BindingName<Dynamic<UITextField.BorderStyle>, Binding> { return BindingName<Dynamic<UITextField.BorderStyle>, Binding>({ v in .textFieldBinding(TextField.Binding.borderStyle(v)) }) }
	static var background: BindingName<Dynamic<UIImage?>, Binding> { return BindingName<Dynamic<UIImage?>, Binding>({ v in .textFieldBinding(TextField.Binding.background(v)) }) }
	static var disabledBackground: BindingName<Dynamic<UIImage?>, Binding> { return BindingName<Dynamic<UIImage?>, Binding>({ v in .textFieldBinding(TextField.Binding.disabledBackground(v)) }) }
	static var clearButtonMode: BindingName<Dynamic<UITextField.ViewMode>, Binding> { return BindingName<Dynamic<UITextField.ViewMode>, Binding>({ v in .textFieldBinding(TextField.Binding.clearButtonMode(v)) }) }
	static var leftView: BindingName<Dynamic<ViewConvertible?>, Binding> { return BindingName<Dynamic<ViewConvertible?>, Binding>({ v in .textFieldBinding(TextField.Binding.leftView(v)) }) }
	static var leftViewMode: BindingName<Dynamic<UITextField.ViewMode>, Binding> { return BindingName<Dynamic<UITextField.ViewMode>, Binding>({ v in .textFieldBinding(TextField.Binding.leftViewMode(v)) }) }
	static var rightView: BindingName<Dynamic<ViewConvertible?>, Binding> { return BindingName<Dynamic<ViewConvertible?>, Binding>({ v in .textFieldBinding(TextField.Binding.rightView(v)) }) }
	static var rightViewMode: BindingName<Dynamic<UITextField.ViewMode>, Binding> { return BindingName<Dynamic<UITextField.ViewMode>, Binding>({ v in .textFieldBinding(TextField.Binding.rightViewMode(v)) }) }
	static var inputView: BindingName<Dynamic<ViewConvertible?>, Binding> { return BindingName<Dynamic<ViewConvertible?>, Binding>({ v in .textFieldBinding(TextField.Binding.inputView(v)) }) }
	static var inputAccessoryView: BindingName<Dynamic<ViewConvertible?>, Binding> { return BindingName<Dynamic<ViewConvertible?>, Binding>({ v in .textFieldBinding(TextField.Binding.inputAccessoryView(v)) }) }
	static var resignFirstResponder: BindingName<Signal<Void>, Binding> { return BindingName<Signal<Void>, Binding>({ v in .textFieldBinding(TextField.Binding.resignFirstResponder(v)) }) }
	static var didBeginEditing: BindingName<(_ textField: UITextField) -> Void, Binding> { return BindingName<(_ textField: UITextField) -> Void, Binding>({ v in .textFieldBinding(TextField.Binding.didBeginEditing(v)) }) }
	static var didChange: BindingName<(_ textField: UITextField) -> Void, Binding> { return BindingName<(_ textField: UITextField) -> Void, Binding>({ v in .textFieldBinding(TextField.Binding.didChange(v)) }) }
	static var didEndEditing: BindingName<(_ textField: UITextField) -> Void, Binding> { return BindingName<(_ textField: UITextField) -> Void, Binding>({ v in .textFieldBinding(TextField.Binding.didEndEditing(v)) }) }
	@available(iOS 10.0, *)
	static var didEndEditingWithReason: BindingName<(_ textField: UITextField, _ reason: UITextField.DidEndEditingReason) -> Void, Binding> { return BindingName<(_ textField: UITextField, _ reason: UITextField.DidEndEditingReason) -> Void, Binding>({ v in .textFieldBinding(TextField.Binding.didEndEditingWithReason(v)) }) }
	static var shouldBeginEditing: BindingName<(_ textField: UITextField) -> Bool, Binding> { return BindingName<(_ textField: UITextField) -> Bool, Binding>({ v in .textFieldBinding(TextField.Binding.shouldBeginEditing(v)) }) }
	static var shouldEndEditing: BindingName<(_ textField: UITextField) -> Bool, Binding> { return BindingName<(_ textField: UITextField) -> Bool, Binding>({ v in .textFieldBinding(TextField.Binding.shouldEndEditing(v)) }) }
	static var shouldChangeCharacters: BindingName<(_ textField: UITextField, _ range: NSRange, _ replacementString: String) -> Bool, Binding> { return BindingName<(_ textField: UITextField, _ range: NSRange, _ replacementString: String) -> Bool, Binding>({ v in .textFieldBinding(TextField.Binding.shouldChangeCharacters(v)) }) }
	static var shouldClear: BindingName<(_ textField: UITextField) -> Bool, Binding> { return BindingName<(_ textField: UITextField) -> Bool, Binding>({ v in .textFieldBinding(TextField.Binding.shouldClear(v)) }) }
	static var shouldReturn: BindingName<(_ textField: UITextField) -> Bool, Binding> { return BindingName<(_ textField: UITextField) -> Bool, Binding>({ v in .textFieldBinding(TextField.Binding.shouldReturn(v)) }) }
}

extension BindingName where Binding: TextFieldBinding {
	// Additional helper binding names
	static var textChanged: BindingName<SignalInput<String>, Binding> {
		return BindingName<SignalInput<String>, Binding>({ v in .textFieldBinding(TextField.Binding.didChange { textField in if let t = textField.text { v.send(value: t) } }) })
	}
	static var attributedTextChanged: BindingName<SignalInput<NSAttributedString>, Binding> {
		return BindingName<SignalInput<NSAttributedString>, Binding>({ v in .textFieldBinding(TextField.Binding.didChange { textField in if let t = textField.attributedText { v.send(value: t) } }) })
	}
}

protocol TextFieldConvertible: ControlConvertible {
	func uiTextField() -> TextField.Instance
}
extension TextFieldConvertible {
	func uiControl() -> Control.Instance { return uiTextField() }
}
extension TextField.Instance: TextFieldConvertible {
	func uiTextField() -> TextField.Instance { return self }
}

protocol TextFieldBinding: ControlBinding {
	static func textFieldBinding(_ binding: TextField.Binding) -> Self
}
extension TextFieldBinding {
	static func controlBinding(_ binding: Control.Binding) -> Self {
		return textFieldBinding(.inheritedBinding(binding))
	}
}

func textFieldResignOnReturn(condition: @escaping (UITextField) -> Bool = { _ in return true }) -> (UITextField) -> Bool {
	return { tf in
		if condition(tf) {
			tf.resignFirstResponder()
			return false
		}
		return true
	}
}

class SwipeGestureRecognizer: ConstructingBinder, SwipeGestureRecognizerConvertible {
	typealias Instance = UISwipeGestureRecognizer
	typealias Inherited = GestureRecognizer
	
	var state: ConstructingBinderState<Instance, Binding>
	required init(state: ConstructingBinderState<Instance, Binding>) {
		self.state = state
	}
	static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	func uiSwipeGestureRecognizer() -> Instance { return instance() }
	
	enum Binding: SwipeGestureRecognizerBinding {
		typealias EnclosingBinder = SwipeGestureRecognizer
		static func swipeGestureRecognizerBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case direction(Dynamic<UISwipeGestureRecognizer.Direction>)
		case numberOfTouchesRequired(Dynamic<Int>)
		
		// 2. Signal bindings are performed on the object after construction.
		
		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
	
	struct Preparer: ConstructingPreparer {
		typealias EnclosingBinder = SwipeGestureRecognizer
		var linkedPreparer = Inherited.Preparer()
		
		func constructStorage() -> EnclosingBinder.Storage { return Storage() }
		func constructInstance(subclass: EnclosingBinder.Instance.Type) -> EnclosingBinder.Instance { return subclass.init() }
		
		init() {}
		
		func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
			switch binding {
			case .direction(let x): return x.apply(instance, storage) { i, s, v in i.direction = v }
			case .numberOfTouchesRequired(let x): return x.apply(instance, storage) { i, s, v in i.numberOfTouchesRequired = v }
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: instance, storage: storage)
			}
		}
	}
	
	typealias Storage = GestureRecognizer.Storage
}

extension BindingName where Binding: SwipeGestureRecognizerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .swipeGestureRecognizerBinding(SwipeGestureRecognizer.Binding.$1(v)) }) }
	static var direction: BindingName<Dynamic<UISwipeGestureRecognizer.Direction>, Binding> { return BindingName<Dynamic<UISwipeGestureRecognizer.Direction>, Binding>({ v in .swipeGestureRecognizerBinding(SwipeGestureRecognizer.Binding.direction(v)) }) }
	static var numberOfTouchesRequired: BindingName<Dynamic<Int>, Binding> { return BindingName<Dynamic<Int>, Binding>({ v in .swipeGestureRecognizerBinding(SwipeGestureRecognizer.Binding.numberOfTouchesRequired(v)) }) }
}

protocol SwipeGestureRecognizerConvertible: GestureRecognizerConvertible {
	func uiSwipeGestureRecognizer() -> SwipeGestureRecognizer.Instance
}
extension SwipeGestureRecognizerConvertible {
	func uiGestureRecognizer() -> GestureRecognizer.Instance { return uiSwipeGestureRecognizer() }
}
extension SwipeGestureRecognizer.Instance: SwipeGestureRecognizerConvertible {
	func uiSwipeGestureRecognizer() -> SwipeGestureRecognizer.Instance { return self }
}

protocol SwipeGestureRecognizerBinding: GestureRecognizerBinding {
	static func swipeGestureRecognizerBinding(_ binding: SwipeGestureRecognizer.Binding) -> Self
}
extension SwipeGestureRecognizerBinding {
	static func gestureRecognizerBinding(_ binding: GestureRecognizer.Binding) -> Self {
		return swipeGestureRecognizerBinding(.inheritedBinding(binding))
	}
}

/// A value abstraction of the arguments to some AppKit/UIKit methods with a `setValue(_:,animated:)` structure.
struct SetOrAnimate<Value> {
	let value: Value
	let isAnimated: Bool
	
	static func set(_ value: Value) -> SetOrAnimate<Value> {
		return SetOrAnimate<Value>(value: value, isAnimated: false)
	}
	static func animate(_ value: Value) -> SetOrAnimate<Value> {
		return SetOrAnimate<Value>(value: value, isAnimated: true)
	}
}

extension SignalInterface {
	/// A signal transformation which wraps the output in `SetOrAnimate` with the first value as in `set` but subsequent values as in `animate`
	func animate(_ choice: AnimationChoice = .subsequent) -> Signal<SetOrAnimate<OutputValue>> {
		return map(initialState: false) { (alreadyReceived: inout Bool, value: OutputValue) in
			if alreadyReceived || choice == .all {
				return .animate(value)
			} else {
				if choice == .subsequent {
					alreadyReceived = true
				}
				return .set(value)
			}
		}
	}
}

/// This is currently used in PageViewController but I feel like it should replace SetOrAnimate and possibly the animation in TableRowMution, too.
struct SetAnimatable<Value, Animation> {
	let value: Value
	let animation: Animation?
	
	static func set(_ value: Value) -> SetAnimatable<Value, Animation> {
		return SetAnimatable<Value, Animation>(value: value, animation: nil)
	}
	static func animate(_ value: Value, animation: Animation) -> SetAnimatable<Value, Animation> {
		return SetAnimatable<Value, Animation>(value: value, animation: animation)
	}
}


class TapGestureRecognizer: ConstructingBinder, TapGestureRecognizerConvertible {
	typealias Instance = UITapGestureRecognizer
	typealias Inherited = GestureRecognizer
	
	var state: ConstructingBinderState<Instance, Binding>
	required init(state: ConstructingBinderState<Instance, Binding>) {
		self.state = state
	}
	static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	func uiTapGestureRecognizer() -> Instance { return instance() }
	
	enum Binding: TapGestureRecognizerBinding {
		typealias EnclosingBinder = TapGestureRecognizer
		static func tapGestureRecognizerBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case numberOfTapsRequired(Dynamic<Int>)
		case numberOfTouchesRequired(Dynamic<Int>)
		
		// 2. Signal bindings are performed on the object after construction.
		
		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
	
	struct Preparer: ConstructingPreparer {
		typealias EnclosingBinder = TapGestureRecognizer
		var linkedPreparer = Inherited.Preparer()
		
		func constructStorage() -> EnclosingBinder.Storage { return Storage() }
		func constructInstance(subclass: EnclosingBinder.Instance.Type) -> EnclosingBinder.Instance { return subclass.init() }
		
		init() {}
		
		func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
			switch binding {
			case .numberOfTapsRequired(let x): return x.apply(instance, storage) { i, s, v in i.numberOfTapsRequired = v }
			case .numberOfTouchesRequired(let x): return x.apply(instance, storage) { i, s, v in i.numberOfTouchesRequired = v }
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: instance, storage: storage)
			}
		}
	}
	
	typealias Storage = GestureRecognizer.Storage
}

extension BindingName where Binding: TapGestureRecognizerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .tapGestureRecognizerBinding(TapGestureRecognizer.Binding.$1(v)) }) }
	static var numberOfTapsRequired: BindingName<Dynamic<Int>, Binding> { return BindingName<Dynamic<Int>, Binding>({ v in .tapGestureRecognizerBinding(TapGestureRecognizer.Binding.numberOfTapsRequired(v)) }) }
	static var numberOfTouchesRequired: BindingName<Dynamic<Int>, Binding> { return BindingName<Dynamic<Int>, Binding>({ v in .tapGestureRecognizerBinding(TapGestureRecognizer.Binding.numberOfTouchesRequired(v)) }) }
}

protocol TapGestureRecognizerConvertible: GestureRecognizerConvertible {
	func uiTapGestureRecognizer() -> TapGestureRecognizer.Instance
}
extension TapGestureRecognizerConvertible {
	func uiGestureRecognizer() -> GestureRecognizer.Instance { return uiTapGestureRecognizer() }
}
extension TapGestureRecognizer.Instance: TapGestureRecognizerConvertible {
	func uiTapGestureRecognizer() -> TapGestureRecognizer.Instance { return self }
}

protocol TapGestureRecognizerBinding: GestureRecognizerBinding {
	static func tapGestureRecognizerBinding(_ binding: TapGestureRecognizer.Binding) -> Self
}
extension TapGestureRecognizerBinding {
	static func gestureRecognizerBinding(_ binding: GestureRecognizer.Binding) -> Self {
		return tapGestureRecognizerBinding(.inheritedBinding(binding))
	}
}

class BarItem: ConstructingBinder, BarItemConvertible {
	typealias Instance = UIBarItem
	typealias Inherited = BaseBinder
	
	var state: ConstructingBinderState<Instance, Binding>
	required init(state: ConstructingBinderState<Instance, Binding>) {
		self.state = state
	}
	static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	func uiBarItem() -> Instance { return instance() }
	
	enum Binding: BarItemBinding {
		typealias EnclosingBinder = BarItem
		static func barItemBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		//	1. Value bindings may be applied at construction and may subsequently change.
		case isEnabled(Dynamic<Bool>)
		case image(Dynamic<UIImage?>)
		case landscapeImagePhone(Dynamic<UIImage?>)
		case imageInsets(Dynamic<UIEdgeInsets>)
		case landscapeImagePhoneInsets(Dynamic<UIEdgeInsets>)
		case title(Dynamic<String>)
		case tag(Dynamic<Int>)
		case titleTextAttributes(Dynamic<ScopedValues<UIControl.State, [NSAttributedString.Key: Any]>>)

		//	2. Signal bindings are performed on the object after construction.

		//	3. Action bindings are triggered by the object after construction.

		//	4. Delegate bindings require synchronous evaluation within the object's context.
	}

	struct Preparer: ConstructingPreparer {
		typealias EnclosingBinder = BarItem
		var linkedPreparer = Inherited.Preparer()
		
		func constructStorage() -> EnclosingBinder.Storage { return Storage() }
		func constructInstance(subclass: EnclosingBinder.Instance.Type) -> EnclosingBinder.Instance { return subclass.init() }
		
		init() {}

		func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
			switch binding {
			case .isEnabled(let x): return x.apply(instance, storage) { i, s, v in i.isEnabled = v }
			case .image(let x): return x.apply(instance, storage) { i, s, v in i.image = v }
			case .landscapeImagePhone(let x): return x.apply(instance, storage) { i, s, v in i.landscapeImagePhone = v }
			case .imageInsets(let x): return x.apply(instance, storage) { i, s, v in i.imageInsets = v }
			case .landscapeImagePhoneInsets(let x): return x.apply(instance, storage) { i, s, v in i.landscapeImagePhoneInsets = v }
			case .title(let x): return x.apply(instance, storage) { i, s, v in i.title = v }
			case .tag(let x): return x.apply(instance, storage) { i, s, v in i.tag = v }
			case .titleTextAttributes(let x):
				var previous: ScopedValues<UIControl.State, [NSAttributedString.Key: Any]>? = nil
				return x.apply(instance, storage) { i, s, v in
					if let p = previous {
						for c in p.pairs {
							i.setTitleTextAttributes([:], for: c.0)
						}
					}
					previous = v
					for c in v.pairs {
						i.setTitleTextAttributes(c.1, for: c.0)
					}
				}
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: (), storage: ())
			}
		}
	}

	typealias Storage = ObjectBinderStorage
}

extension BindingName where Binding: BarItemBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .barItemBinding(BarItem.Binding.$1(v)) }) }
	static var isEnabled: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .barItemBinding(BarItem.Binding.isEnabled(v)) }) }
	static var image: BindingName<Dynamic<UIImage?>, Binding> { return BindingName<Dynamic<UIImage?>, Binding>({ v in .barItemBinding(BarItem.Binding.image(v)) }) }
	static var landscapeImagePhone: BindingName<Dynamic<UIImage?>, Binding> { return BindingName<Dynamic<UIImage?>, Binding>({ v in .barItemBinding(BarItem.Binding.landscapeImagePhone(v)) }) }
	static var imageInsets: BindingName<Dynamic<UIEdgeInsets>, Binding> { return BindingName<Dynamic<UIEdgeInsets>, Binding>({ v in .barItemBinding(BarItem.Binding.imageInsets(v)) }) }
	static var landscapeImagePhoneInsets: BindingName<Dynamic<UIEdgeInsets>, Binding> { return BindingName<Dynamic<UIEdgeInsets>, Binding>({ v in .barItemBinding(BarItem.Binding.landscapeImagePhoneInsets(v)) }) }
	static var title: BindingName<Dynamic<String>, Binding> { return BindingName<Dynamic<String>, Binding>({ v in .barItemBinding(BarItem.Binding.title(v)) }) }
	static var tag: BindingName<Dynamic<Int>, Binding> { return BindingName<Dynamic<Int>, Binding>({ v in .barItemBinding(BarItem.Binding.tag(v)) }) }
	static var titleTextAttributes: BindingName<Dynamic<ScopedValues<UIControl.State, [NSAttributedString.Key: Any]>>, Binding> { return BindingName<Dynamic<ScopedValues<UIControl.State, [NSAttributedString.Key: Any]>>, Binding>({ v in .barItemBinding(BarItem.Binding.titleTextAttributes(v)) }) }
}

protocol BarItemConvertible {
	func uiBarItem() -> BarItem.Instance
}
extension BarItem.Instance: BarItemConvertible {
	func uiBarItem() -> BarItem.Instance { return self }
}

protocol BarItemBinding: BaseBinding {
	static func barItemBinding(_ binding: BarItem.Binding) -> Self
}
extension BarItemBinding {
	static func baseBinding(_ binding: BaseBinder.Binding) -> Self {
		return barItemBinding(.inheritedBinding(binding))
	}
}

class NavigationController: ConstructingBinder, NavigationControllerConvertible {
	typealias Instance = UINavigationController
	typealias Inherited = ViewController
	
	var state: ConstructingBinderState<Instance, Binding>
	required init(state: ConstructingBinderState<Instance, Binding>) {
		self.state = state
	}
	static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	func uiNavigationController() -> Instance { return instance() }
	
	enum Binding: NavigationControllerBinding {
		typealias EnclosingBinder = NavigationController
		static func navigationControllerBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case navigationBar(Constant<NavigationBar>)

		// 1. Value bindings may be applied at construction and may subsequently change.
		case stack(Dynamic<StackMutation<ViewControllerConvertible>>)
		case supportedInterfaceOrientations(Dynamic<UIInterfaceOrientationMask>)
		case preferredInterfaceOrientation(Dynamic<UIInterfaceOrientation>)
		case isNavigationBarHidden(Dynamic<SetOrAnimate<Bool>>)
		case isToolbarHidden(Dynamic<SetOrAnimate<Bool>>)
		case hidesBarsOnTap(Dynamic<Bool>)
		case hidesBarsOnSwipe(Dynamic<Bool>)
		case hidesBarsWhenVerticallyCompact(Dynamic<Bool>)
		case hidesBarsWhenKeyboardAppears(Dynamic<Bool>)
		
		// 2. Signal bindings are performed on the object after construction.
		
		// 3. Action bindings are triggered by the object after construction.
		case poppedToCount(SignalInput<Int>)
		case willShow(SignalInput<(viewController: UIViewController, animated: Bool)>)
		case didShow(SignalInput<(viewController: UIViewController, animated: Bool)>)
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case animationController((_ navigationController: UINavigationController, _ operation: UINavigationController.Operation, _ from: UIViewController, _ to: UIViewController) -> UIViewControllerAnimatedTransitioning?)
		case interactionController((_ navigationController: UINavigationController, _ animationController: UIViewControllerAnimatedTransitioning) -> UIViewControllerInteractiveTransitioning?)
	}

	struct Preparer: ConstructingPreparer {
		typealias EnclosingBinder = NavigationController
		var linkedPreparer = Inherited.Preparer()
		
		func constructStorage() -> EnclosingBinder.Storage { return Storage(popSignal: popSignal) }
		func constructInstance(subclass: EnclosingBinder.Instance.Type) -> EnclosingBinder.Instance { return subclass.init(nibName: nil, bundle: nil) }
		
		init() {
			self.init(delegateClass: NavigationControllerDelegate.self)
		}
		init<Value>(delegateClass: Value.Type) where Value: NavigationControllerDelegate {
			self.delegateClass = delegateClass
		}
		let delegateClass: NavigationControllerDelegate.Type
		var possibleDelegate: NavigationControllerDelegate? = nil
		mutating func delegate() -> NavigationControllerDelegate {
			if let d = possibleDelegate {
				return d
			} else {
				let d = delegateClass.init()
				possibleDelegate = d
				return d
			}
		}
		
		var popSignal: SignalInput<Int>? = nil
		
		mutating func prepareBinding(_ binding: Binding) {
			switch binding {
			case .poppedToCount(let x): popSignal = x
			case .supportedInterfaceOrientations:
				delegate().addSelector(#selector(UINavigationControllerDelegate.navigationControllerSupportedInterfaceOrientations(_:)))
			case .preferredInterfaceOrientation:
				delegate().addSelector(#selector(UINavigationControllerDelegate.navigationControllerPreferredInterfaceOrientationForPresentation(_:)))
			case .animationController(let x):
				let s = #selector(UINavigationControllerDelegate.navigationController(_:animationControllerFor:from:to:))
				delegate().addSelector(s).animationController = x
			case .interactionController(let x):
				let s = #selector(UINavigationControllerDelegate.navigationController(_:interactionControllerFor:))
				delegate().addSelector(s).interactionController = x
			case .willShow:
				let s = #selector(UINavigationControllerDelegate.navigationController(_:willShow:animated:))
				delegate().addSelector(s)
			case .inheritedBinding(let x): linkedPreparer.prepareBinding(x)
			default: break
			}
		}
		
		mutating func prepareInstance(_ instance: UINavigationController, storage: Storage) {
			precondition(instance.delegate == nil, "Conflicting delegate applied to instance")
			storage.dynamicDelegate = possibleDelegate
			instance.delegate = storage
			
			linkedPreparer.prepareInstance(instance, storage: storage)
		}
		
		func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
			switch binding {
			case .navigationBar(let x):
				x.value.applyBindings(to: instance.navigationBar)
				return nil
			case .stack(let x):
				return x.apply(instance, storage) { i, s, v in
					switch v {
					case .push(let e):
						s.expectedStackCount += 1
						i.pushViewController(e.uiViewController(), animated: true)
					case .pop:
						s.expectedStackCount -= 1
						i.popViewController(animated: true)
					case .popToCount(let c):
						s.expectedStackCount = c
						i.popToViewController(i.viewControllers[c - 1], animated: true)
					case .reload(let newStack):
						s.expectedStackCount = newStack.count
						i.setViewControllers(newStack.map { $0.uiViewController() }, animated: false)
					}
				}
			case .isNavigationBarHidden(let x): return x.apply(instance, storage) { i, s, v in i.setNavigationBarHidden(v.value, animated: v.isAnimated) }
			case .isToolbarHidden(let x): return x.apply(instance, storage) { i, s, v in i.setToolbarHidden(v.value, animated: v.isAnimated) }
			case .hidesBarsOnTap(let x): return x.apply(instance, storage) { i, s, v in i.hidesBarsOnTap = v }
			case .hidesBarsOnSwipe(let x): return x.apply(instance, storage) { i, s, v in i.hidesBarsOnSwipe = v }
			case .hidesBarsWhenVerticallyCompact(let x): return x.apply(instance, storage) { i, s, v in i.hidesBarsWhenVerticallyCompact = v }
			case .hidesBarsWhenKeyboardAppears(let x): return x.apply(instance, storage) { i, s, v in i.hidesBarsWhenKeyboardAppears = v }
			case .supportedInterfaceOrientations: return nil
			case .preferredInterfaceOrientation: return nil
			case .didShow(let x):
				storage.didShow = x
				return nil
			case .willShow: return nil
			case .animationController: return nil
			case .interactionController: return nil
			case .poppedToCount: return nil
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: instance, storage: storage)
			}
		}
	}

	class Storage: ViewController.Storage, UINavigationControllerDelegate {
		var supportedInterfaceOrientations: UIInterfaceOrientationMask = .all
		var preferredInterfaceOrientation: UIInterfaceOrientation = .portrait
		var expectedStackCount: Int = 0
		let popSignal: SignalInput<Int>?
		weak var collapsedController: UINavigationController?
		
		override var inUse: Bool {
			return true
		}
		
		init(popSignal: SignalInput<Int>?) {
			self.popSignal = popSignal
			super.init()
		}
		
		var didShow: SignalInput<(viewController: UIViewController, animated: Bool)>?
		func navigationController(_ navigationController: UINavigationController, didShow viewController: UIViewController, animated: Bool) {
			// Handle pop operations triggered by the back button
			if animated, navigationController.viewControllers.count < expectedStackCount, let ps = popSignal {
				ps.send(value: navigationController.viewControllers.count)
			}
			
			// Handle removal of collapsed split view details
			if animated, navigationController.viewControllers.count == expectedStackCount, let collapsed = collapsedController, let splitViewStorage = navigationController.splitViewController?.getBinderStorage(type: SplitViewController.Storage.self) {
				collapsedController = nil
				splitViewStorage.collapsedController(collapsed)
			}
			
			// Track when a collapsed split view is added
			if navigationController.viewControllers.count == expectedStackCount + 1, let collapsed = navigationController.viewControllers.last as? UINavigationController {
				collapsedController = collapsed
			}
			
			didShow?.send(value: (viewController: viewController, animated: animated))
		}
	}
}

class NavigationControllerDelegate: DynamicDelegate, UINavigationControllerDelegate {
	required override init() {
		super.init()
	}
	
	var willShow: ((UIViewController, Bool) -> Void)?
	func navigationController(_ navigationController: UINavigationController, willShow viewController: UIViewController, animated: Bool) {
		return willShow!(viewController, animated)
	}
	
	var supportedInterfaceOrientations: (() -> UIInterfaceOrientationMask)?
	func navigationControllerSupportedInterfaceOrientations(_ navigationController: UINavigationController) -> UIInterfaceOrientationMask {
		return supportedInterfaceOrientations!()
	}
	
	var preferredInterfaceOrientationForPresentation: (() -> UIInterfaceOrientation)?
	func navigationControllerPreferredInterfaceOrientationForPresentation(_ navigationController: UINavigationController) -> UIInterfaceOrientation {
		return preferredInterfaceOrientationForPresentation!()
	}
	
	var animationController: ((_ navigationController: UINavigationController, _ operation: UINavigationController.Operation, _ from: UIViewController, _ to: UIViewController) -> UIViewControllerAnimatedTransitioning?)?
	func navigationController(_ navigationController: UINavigationController, animationControllerFor operation: UINavigationController.Operation, from fromVC: UIViewController, to toVC: UIViewController) -> UIViewControllerAnimatedTransitioning? {
		return animationController!(navigationController, operation, fromVC, toVC)
	}
	
	var interactionController: ((_ navigationController: UINavigationController, _ animationController: UIViewControllerAnimatedTransitioning) -> UIViewControllerInteractiveTransitioning?)?
	func navigationController(_ navigationController: UINavigationController, interactionControllerFor animationController: UIViewControllerAnimatedTransitioning) -> UIViewControllerInteractiveTransitioning?
	{
		return interactionController!(navigationController, animationController)
	}
}

extension BindingName where Binding: NavigationControllerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .navigationControllerBinding(NavigationController.Binding.$1(v)) }) }
	static var navigationBar: BindingName<Constant<NavigationBar>, Binding> { return BindingName<Constant<NavigationBar>, Binding>({ v in .navigationControllerBinding(NavigationController.Binding.navigationBar(v)) }) }
	static var stack: BindingName<Dynamic<StackMutation<ViewControllerConvertible>>, Binding> { return BindingName<Dynamic<StackMutation<ViewControllerConvertible>>, Binding>({ v in .navigationControllerBinding(NavigationController.Binding.stack(v)) }) }
	static var supportedInterfaceOrientations: BindingName<Dynamic<UIInterfaceOrientationMask>, Binding> { return BindingName<Dynamic<UIInterfaceOrientationMask>, Binding>({ v in .navigationControllerBinding(NavigationController.Binding.supportedInterfaceOrientations(v)) }) }
	static var preferredInterfaceOrientation: BindingName<Dynamic<UIInterfaceOrientation>, Binding> { return BindingName<Dynamic<UIInterfaceOrientation>, Binding>({ v in .navigationControllerBinding(NavigationController.Binding.preferredInterfaceOrientation(v)) }) }
	static var isNavigationBarHidden: BindingName<Dynamic<SetOrAnimate<Bool>>, Binding> { return BindingName<Dynamic<SetOrAnimate<Bool>>, Binding>({ v in .navigationControllerBinding(NavigationController.Binding.isNavigationBarHidden(v)) }) }
	static var isToolbarHidden: BindingName<Dynamic<SetOrAnimate<Bool>>, Binding> { return BindingName<Dynamic<SetOrAnimate<Bool>>, Binding>({ v in .navigationControllerBinding(NavigationController.Binding.isToolbarHidden(v)) }) }
	static var hidesBarsOnTap: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .navigationControllerBinding(NavigationController.Binding.hidesBarsOnTap(v)) }) }
	static var hidesBarsOnSwipe: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .navigationControllerBinding(NavigationController.Binding.hidesBarsOnSwipe(v)) }) }
	static var hidesBarsWhenVerticallyCompact: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .navigationControllerBinding(NavigationController.Binding.hidesBarsWhenVerticallyCompact(v)) }) }
	static var hidesBarsWhenKeyboardAppears: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .navigationControllerBinding(NavigationController.Binding.hidesBarsWhenKeyboardAppears(v)) }) }
	static var poppedToCount: BindingName<SignalInput<Int>, Binding> { return BindingName<SignalInput<Int>, Binding>({ v in .navigationControllerBinding(NavigationController.Binding.poppedToCount(v)) }) }
	static var willShow: BindingName<SignalInput<(viewController: UIViewController, animated: Bool)>, Binding> { return BindingName<SignalInput<(viewController: UIViewController, animated: Bool)>, Binding>({ v in .navigationControllerBinding(NavigationController.Binding.willShow(v)) }) }
	static var didShow: BindingName<SignalInput<(viewController: UIViewController, animated: Bool)>, Binding> { return BindingName<SignalInput<(viewController: UIViewController, animated: Bool)>, Binding>({ v in .navigationControllerBinding(NavigationController.Binding.didShow(v)) }) }
	static var animationController: BindingName<(_ navigationController: UINavigationController, _ operation: UINavigationController.Operation, _ from: UIViewController, _ to: UIViewController) -> UIViewControllerAnimatedTransitioning?, Binding> { return BindingName<(_ navigationController: UINavigationController, _ operation: UINavigationController.Operation, _ from: UIViewController, _ to: UIViewController) -> UIViewControllerAnimatedTransitioning?, Binding>({ v in .navigationControllerBinding(NavigationController.Binding.animationController(v)) }) }
	static var interactionController: BindingName<(_ navigationController: UINavigationController, _ animationController: UIViewControllerAnimatedTransitioning) -> UIViewControllerInteractiveTransitioning?, Binding> { return BindingName<(_ navigationController: UINavigationController, _ animationController: UIViewControllerAnimatedTransitioning) -> UIViewControllerInteractiveTransitioning?, Binding>({ v in .navigationControllerBinding(NavigationController.Binding.interactionController(v)) }) }
}

protocol NavigationControllerConvertible: ViewControllerConvertible {
	func uiNavigationController() -> NavigationController.Instance
}
extension NavigationControllerConvertible {
	func uiViewController() -> ViewController.Instance { return uiNavigationController() }
}
extension NavigationController.Instance: NavigationControllerConvertible {
	func uiNavigationController() -> NavigationController.Instance { return self }
}

protocol NavigationControllerBinding: ViewControllerBinding {
	static func navigationControllerBinding(_ binding: NavigationController.Binding) -> Self
}
extension NavigationControllerBinding {
	static func viewControllerBinding(_ binding: ViewController.Binding) -> Self {
		return navigationControllerBinding(.inheritedBinding(binding))
	}
}

class View: ConstructingBinder, ViewConvertible {
	typealias Instance = UIView
	typealias Inherited = BaseBinder
	
	var state: ConstructingBinderState<Instance, Binding>
	required init(state: ConstructingBinderState<Instance, Binding>) {
		self.state = state
	}
	static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	func uiView() -> Instance { return instance() }

	enum Binding: ViewBinding {
		typealias EnclosingBinder = View
		static func viewBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case layer(Constant<BackingLayer>)

		// 1. Value bindings may be applied at construction and may subsequently change.
		case layout(Dynamic<Layout>)
		case backgroundColor(Dynamic<(UIColor?)>)
		case isHidden(Dynamic<(Bool)>)
		case alpha(Dynamic<(CGFloat)>)
		case isOpaque(Dynamic<(Bool)>)
		case tintColor(Dynamic<(UIColor)>)
		case tintAdjustmentMode(Dynamic<(UIView.TintAdjustmentMode)>)
		case clipsToBounds(Dynamic<(Bool)>)
		case clearsContextBeforeDrawing(Dynamic<(Bool)>)
		case mask(Dynamic<(ViewConvertible?)>)
		case isUserInteractionEnabled(Dynamic<(Bool)>)
		case isMultipleTouchEnabled(Dynamic<(Bool)>)
		case isExclusiveTouch(Dynamic<(Bool)>)
		case contentMode(Dynamic<(UIView.ContentMode)>)
		case horizontalContentCompressionResistancePriority(Dynamic<UILayoutPriority>)
		case verticalContentCompressionResistancePriority(Dynamic<UILayoutPriority>)
		case horizontalContentHuggingPriority(Dynamic<UILayoutPriority>)
		case verticalContentHuggingPriority(Dynamic<UILayoutPriority>)
		case semanticContentAttribute(Dynamic<(UISemanticContentAttribute)>)
		case layoutMargins(Dynamic<(UIEdgeInsets)>)
		case preservesSuperviewLayoutMargins(Dynamic<(Bool)>)
		case gestureRecognizers(Dynamic<[UIGestureRecognizer]>)
		case motionEffects(Dynamic<([UIMotionEffect])>)
		case tag(Dynamic<Int>)
		case restorationIdentifier(Dynamic<String?>)

		// 2. Signal bindings are performed on the object after construction.
		case endEditing(Signal<Bool>)
		case becomeFirstResponder(Signal<Void>)
		
		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}

	struct Preparer: ConstructingPreparer {
		typealias EnclosingBinder = View
		var linkedPreparer = Inherited.Preparer()
		
		func constructStorage() -> EnclosingBinder.Storage { return Storage() }
		func constructInstance(subclass: EnclosingBinder.Instance.Type) -> EnclosingBinder.Instance { return subclass.init(frame: CGRect.zero) }
		
		init() {}
		
		func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
			switch binding {
			case .layer(let x):
				x.value.applyBindings(to: instance.layer)
				return nil
			case .layout(let x):
				return x.apply(instance, storage) { i, s, v in
					instance.applyLayout(v)
				}
			case .backgroundColor(let x): return x.apply(instance, storage) { i, s, v in i.backgroundColor = v }
			case .isHidden(let x): return x.apply(instance, storage) { i, s, v in i.isHidden = v }
			case .alpha(let x): return x.apply(instance, storage) { i, s, v in i.alpha = v }
			case .isOpaque(let x): return x.apply(instance, storage) { i, s, v in i.isOpaque = v }
			case .tintColor(let x): return x.apply(instance, storage) { i, s, v in i.tintColor = v }
			case .tintAdjustmentMode(let x): return x.apply(instance, storage) { i, s, v in i.tintAdjustmentMode = v }
			case .clipsToBounds(let x): return x.apply(instance, storage) { i, s, v in i.clipsToBounds = v }
			case .clearsContextBeforeDrawing(let x): return x.apply(instance, storage) { i, s, v in i.clearsContextBeforeDrawing = v }
			case .mask(let x): return x.apply(instance, storage) { i, s, v in i.mask = v?.uiView() }
			case .isUserInteractionEnabled(let x): return x.apply(instance, storage) { i, s, v in i.isUserInteractionEnabled = v }
			case .isMultipleTouchEnabled(let x): return x.apply(instance, storage) { i, s, v in i.isMultipleTouchEnabled = v }
			case .isExclusiveTouch(let x): return x.apply(instance, storage) { i, s, v in i.isExclusiveTouch = v }
			case .restorationIdentifier(let x): return x.apply(instance, storage) { i, s, v in i.restorationIdentifier = v }
			case .contentMode(let x): return x.apply(instance, storage) { i, s, v in i.contentMode = v }
			case .horizontalContentCompressionResistancePriority(let x): return x.apply(instance, storage) { i, s, v in i.setContentCompressionResistancePriority(v, for: NSLayoutConstraint.Axis.horizontal) }
			case .verticalContentCompressionResistancePriority(let x): return x.apply(instance, storage) { i, s, v in i.setContentCompressionResistancePriority(v, for: NSLayoutConstraint.Axis.vertical) }
			case .horizontalContentHuggingPriority(let x): return x.apply(instance, storage) { i, s, v in i.setContentHuggingPriority(v, for: NSLayoutConstraint.Axis.horizontal) }
			case .verticalContentHuggingPriority(let x): return x.apply(instance, storage) { i, s, v in i.setContentHuggingPriority(v, for: NSLayoutConstraint.Axis.vertical) }
			case .semanticContentAttribute(let x): return x.apply(instance, storage) { i, s, v in i.semanticContentAttribute = v }
			case .layoutMargins(let x): return x.apply(instance, storage) { i, s, v in i.layoutMargins = v }
			case .preservesSuperviewLayoutMargins(let x): return x.apply(instance, storage) { i, s, v in i.preservesSuperviewLayoutMargins = v }
			case .gestureRecognizers(let x): return x.apply(instance, storage) { i, s, v in i.gestureRecognizers = v }
			case .motionEffects(let x): return x.apply(instance, storage) { i, s, v in i.motionEffects = v }
			case .tag(let x): return x.apply(instance, storage) { i, s, v in i.tag = v }
			case .endEditing(let x): return x.apply(instance, storage) { i, s, v in i.endEditing(v) }
			case .becomeFirstResponder(let x): return x.apply(instance, storage) { i, s, v in i.becomeFirstResponder() }
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: (), storage: ())
			}
		}
	}

	typealias Storage = ObjectBinderStorage
}

extension BindingName where Binding: ViewBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .viewBinding(View.Binding.$1(v)) }) }
	static var layer: BindingName<Constant<BackingLayer>, Binding> { return BindingName<Constant<BackingLayer>, Binding>({ v in .viewBinding(View.Binding.layer(v)) }) }
	static var layout: BindingName<Dynamic<Layout>, Binding> { return BindingName<Dynamic<Layout>, Binding>({ v in .viewBinding(View.Binding.layout(v)) }) }
	static var backgroundColor: BindingName<Dynamic<(UIColor?)>, Binding> { return BindingName<Dynamic<(UIColor?)>, Binding>({ v in .viewBinding(View.Binding.backgroundColor(v)) }) }
	static var isHidden: BindingName<Dynamic<(Bool)>, Binding> { return BindingName<Dynamic<(Bool)>, Binding>({ v in .viewBinding(View.Binding.isHidden(v)) }) }
	static var alpha: BindingName<Dynamic<(CGFloat)>, Binding> { return BindingName<Dynamic<(CGFloat)>, Binding>({ v in .viewBinding(View.Binding.alpha(v)) }) }
	static var isOpaque: BindingName<Dynamic<(Bool)>, Binding> { return BindingName<Dynamic<(Bool)>, Binding>({ v in .viewBinding(View.Binding.isOpaque(v)) }) }
	static var tintColor: BindingName<Dynamic<(UIColor)>, Binding> { return BindingName<Dynamic<(UIColor)>, Binding>({ v in .viewBinding(View.Binding.tintColor(v)) }) }
	static var tintAdjustmentMode: BindingName<Dynamic<(UIView.TintAdjustmentMode)>, Binding> { return BindingName<Dynamic<(UIView.TintAdjustmentMode)>, Binding>({ v in .viewBinding(View.Binding.tintAdjustmentMode(v)) }) }
	static var clipsToBounds: BindingName<Dynamic<(Bool)>, Binding> { return BindingName<Dynamic<(Bool)>, Binding>({ v in .viewBinding(View.Binding.clipsToBounds(v)) }) }
	static var clearsContextBeforeDrawing: BindingName<Dynamic<(Bool)>, Binding> { return BindingName<Dynamic<(Bool)>, Binding>({ v in .viewBinding(View.Binding.clearsContextBeforeDrawing(v)) }) }
	static var mask: BindingName<Dynamic<(ViewConvertible?)>, Binding> { return BindingName<Dynamic<(ViewConvertible?)>, Binding>({ v in .viewBinding(View.Binding.mask(v)) }) }
	static var isUserInteractionEnabled: BindingName<Dynamic<(Bool)>, Binding> { return BindingName<Dynamic<(Bool)>, Binding>({ v in .viewBinding(View.Binding.isUserInteractionEnabled(v)) }) }
	static var isMultipleTouchEnabled: BindingName<Dynamic<(Bool)>, Binding> { return BindingName<Dynamic<(Bool)>, Binding>({ v in .viewBinding(View.Binding.isMultipleTouchEnabled(v)) }) }
	static var isExclusiveTouch: BindingName<Dynamic<(Bool)>, Binding> { return BindingName<Dynamic<(Bool)>, Binding>({ v in .viewBinding(View.Binding.isExclusiveTouch(v)) }) }
	static var contentMode: BindingName<Dynamic<(UIView.ContentMode)>, Binding> { return BindingName<Dynamic<(UIView.ContentMode)>, Binding>({ v in .viewBinding(View.Binding.contentMode(v)) }) }
	static var horizontalContentCompressionResistancePriority: BindingName<Dynamic<UILayoutPriority>, Binding> { return BindingName<Dynamic<UILayoutPriority>, Binding>({ v in .viewBinding(View.Binding.horizontalContentCompressionResistancePriority(v)) }) }
	static var verticalContentCompressionResistancePriority: BindingName<Dynamic<UILayoutPriority>, Binding> { return BindingName<Dynamic<UILayoutPriority>, Binding>({ v in .viewBinding(View.Binding.verticalContentCompressionResistancePriority(v)) }) }
	static var horizontalContentHuggingPriority: BindingName<Dynamic<UILayoutPriority>, Binding> { return BindingName<Dynamic<UILayoutPriority>, Binding>({ v in .viewBinding(View.Binding.horizontalContentHuggingPriority(v)) }) }
	static var verticalContentHuggingPriority: BindingName<Dynamic<UILayoutPriority>, Binding> { return BindingName<Dynamic<UILayoutPriority>, Binding>({ v in .viewBinding(View.Binding.verticalContentHuggingPriority(v)) }) }
	static var semanticContentAttribute: BindingName<Dynamic<(UISemanticContentAttribute)>, Binding> { return BindingName<Dynamic<(UISemanticContentAttribute)>, Binding>({ v in .viewBinding(View.Binding.semanticContentAttribute(v)) }) }
	static var layoutMargins: BindingName<Dynamic<(UIEdgeInsets)>, Binding> { return BindingName<Dynamic<(UIEdgeInsets)>, Binding>({ v in .viewBinding(View.Binding.layoutMargins(v)) }) }
	static var preservesSuperviewLayoutMargins: BindingName<Dynamic<(Bool)>, Binding> { return BindingName<Dynamic<(Bool)>, Binding>({ v in .viewBinding(View.Binding.preservesSuperviewLayoutMargins(v)) }) }
	static var gestureRecognizers: BindingName<Dynamic<[UIGestureRecognizer]>, Binding> { return BindingName<Dynamic<[UIGestureRecognizer]>, Binding>({ v in .viewBinding(View.Binding.gestureRecognizers(v)) }) }
	static var motionEffects: BindingName<Dynamic<([UIMotionEffect])>, Binding> { return BindingName<Dynamic<([UIMotionEffect])>, Binding>({ v in .viewBinding(View.Binding.motionEffects(v)) }) }
	static var tag: BindingName<Dynamic<Int>, Binding> { return BindingName<Dynamic<Int>, Binding>({ v in .viewBinding(View.Binding.tag(v)) }) }
	static var restorationIdentifier: BindingName<Dynamic<String?>, Binding> { return BindingName<Dynamic<String?>, Binding>({ v in .viewBinding(View.Binding.restorationIdentifier(v)) }) }
	static var endEditing: BindingName<Signal<Bool>, Binding> { return BindingName<Signal<Bool>, Binding>({ v in .viewBinding(View.Binding.endEditing(v)) }) }
	static var becomeFirstResponder: BindingName<Signal<Void>, Binding> { return BindingName<Signal<Void>, Binding>({ v in .viewBinding(View.Binding.becomeFirstResponder(v)) }) }
}

protocol ViewBinding: BaseBinding {
	static func viewBinding(_ binding: View.Binding) -> Self
}
extension ViewBinding {
	static func baseBinding(_ binding: BaseBinder.Binding) -> Self {
		return viewBinding(.inheritedBinding(binding))
	}
}


class Label: ConstructingBinder, LabelConvertible {
	typealias Instance = UILabel
	typealias Inherited = View
	
	var state: ConstructingBinderState<Instance, Binding>
	required init(state: ConstructingBinderState<Instance, Binding>) {
		self.state = state
	}
	static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	func uiLabel() -> Instance { return instance() }
	
	enum Binding: LabelBinding {
		typealias EnclosingBinder = Label
		static func labelBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case text(Dynamic<String>)
		case attributedText(Dynamic<NSAttributedString?>)
		case font(Dynamic<UIFont>)
		case textColor(Dynamic<UIColor>)
		case textAlignment(Dynamic<NSTextAlignment>)
		case lineBreakMode(Dynamic<NSLineBreakMode>)
		case isEnabled(Dynamic<Bool>)
		case adjustsFontSizeToFitWidth(Dynamic<Bool>)
		case allowsDefaultTighteningForTruncation(Dynamic<Bool>)
		case baselineAdjustment(Dynamic<UIBaselineAdjustment>)
		case minimumScaleFactor(Dynamic<CGFloat>)
		case numberOfLines(Dynamic<Int>)
		case highlightedTextColor(Dynamic<UIColor?>)
		case isHighlighted(Dynamic<Bool>)
		case shadowColor(Dynamic<UIColor?>)
		case shadowOffset(Dynamic<CGSize>)
		case preferredMaxLayoutWidth(Dynamic<CGFloat>)
		
		// 2. Signal bindings are performed on the object after construction.
		
		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
	
	struct Preparer: ConstructingPreparer {
		typealias EnclosingBinder = Label
		var linkedPreparer = Inherited.Preparer()
		
		func constructStorage() -> EnclosingBinder.Storage { return Storage() }
		func constructInstance(subclass: EnclosingBinder.Instance.Type) -> EnclosingBinder.Instance { return subclass.init() }
		
		init() {}
		
		func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
			switch binding {
			case .text(let x): return x.apply(instance, storage) { i, s, v in i.text = v }
			case .attributedText(let x): return x.apply(instance, storage) { i, s, v in i.attributedText = v }
			case .font(let x): return x.apply(instance, storage) { i, s, v in i.font = v }
			case .textColor(let x): return x.apply(instance, storage) { i, s, v in i.textColor = v }
			case .textAlignment(let x): return x.apply(instance, storage) { i, s, v in i.textAlignment = v }
			case .lineBreakMode(let x): return x.apply(instance, storage) { i, s, v in i.lineBreakMode = v }
			case .isEnabled(let x): return x.apply(instance, storage) { i, s, v in i.isEnabled = v }
			case .adjustsFontSizeToFitWidth(let x): return x.apply(instance, storage) { i, s, v in i.adjustsFontSizeToFitWidth = v }
			case .allowsDefaultTighteningForTruncation(let x): return x.apply(instance, storage) { i, s, v in i.allowsDefaultTighteningForTruncation = v }
			case .baselineAdjustment(let x): return x.apply(instance, storage) { i, s, v in i.baselineAdjustment = v }
			case .minimumScaleFactor(let x): return x.apply(instance, storage) { i, s, v in i.minimumScaleFactor = v }
			case .numberOfLines(let x): return x.apply(instance, storage) { i, s, v in i.numberOfLines = v }
			case .highlightedTextColor(let x): return x.apply(instance, storage) { i, s, v in i.highlightedTextColor = v }
			case .isHighlighted(let x): return x.apply(instance, storage) { i, s, v in i.isHighlighted = v }
			case .shadowColor(let x): return x.apply(instance, storage) { i, s, v in i.shadowColor = v }
			case .shadowOffset(let x): return x.apply(instance, storage) { i, s, v in i.shadowOffset = v }
			case .preferredMaxLayoutWidth(let x): return x.apply(instance, storage) { i, s, v in i.preferredMaxLayoutWidth = v }
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: instance, storage: storage)
			}
		}
	}
	
	typealias Storage = View.Storage
}

extension BindingName where Binding: LabelBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .labelBinding(Label.Binding.$1(v)) }) }
	static var text: BindingName<Dynamic<String>, Binding> { return BindingName<Dynamic<String>, Binding>({ v in .labelBinding(Label.Binding.text(v)) }) }
	static var attributedText: BindingName<Dynamic<NSAttributedString?>, Binding> { return BindingName<Dynamic<NSAttributedString?>, Binding>({ v in .labelBinding(Label.Binding.attributedText(v)) }) }
	static var font: BindingName<Dynamic<UIFont>, Binding> { return BindingName<Dynamic<UIFont>, Binding>({ v in .labelBinding(Label.Binding.font(v)) }) }
	static var textColor: BindingName<Dynamic<UIColor>, Binding> { return BindingName<Dynamic<UIColor>, Binding>({ v in .labelBinding(Label.Binding.textColor(v)) }) }
	static var textAlignment: BindingName<Dynamic<NSTextAlignment>, Binding> { return BindingName<Dynamic<NSTextAlignment>, Binding>({ v in .labelBinding(Label.Binding.textAlignment(v)) }) }
	static var lineBreakMode: BindingName<Dynamic<NSLineBreakMode>, Binding> { return BindingName<Dynamic<NSLineBreakMode>, Binding>({ v in .labelBinding(Label.Binding.lineBreakMode(v)) }) }
	static var isEnabled: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .labelBinding(Label.Binding.isEnabled(v)) }) }
	static var adjustsFontSizeToFitWidth: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .labelBinding(Label.Binding.adjustsFontSizeToFitWidth(v)) }) }
	static var allowsDefaultTighteningForTruncation: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .labelBinding(Label.Binding.allowsDefaultTighteningForTruncation(v)) }) }
	static var baselineAdjustment: BindingName<Dynamic<UIBaselineAdjustment>, Binding> { return BindingName<Dynamic<UIBaselineAdjustment>, Binding>({ v in .labelBinding(Label.Binding.baselineAdjustment(v)) }) }
	static var minimumScaleFactor: BindingName<Dynamic<CGFloat>, Binding> { return BindingName<Dynamic<CGFloat>, Binding>({ v in .labelBinding(Label.Binding.minimumScaleFactor(v)) }) }
	static var numberOfLines: BindingName<Dynamic<Int>, Binding> { return BindingName<Dynamic<Int>, Binding>({ v in .labelBinding(Label.Binding.numberOfLines(v)) }) }
	static var highlightedTextColor: BindingName<Dynamic<UIColor?>, Binding> { return BindingName<Dynamic<UIColor?>, Binding>({ v in .labelBinding(Label.Binding.highlightedTextColor(v)) }) }
	static var isHighlighted: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .labelBinding(Label.Binding.isHighlighted(v)) }) }
	static var shadowColor: BindingName<Dynamic<UIColor?>, Binding> { return BindingName<Dynamic<UIColor?>, Binding>({ v in .labelBinding(Label.Binding.shadowColor(v)) }) }
	static var shadowOffset: BindingName<Dynamic<CGSize>, Binding> { return BindingName<Dynamic<CGSize>, Binding>({ v in .labelBinding(Label.Binding.shadowOffset(v)) }) }
	static var preferredMaxLayoutWidth: BindingName<Dynamic<CGFloat>, Binding> { return BindingName<Dynamic<CGFloat>, Binding>({ v in .labelBinding(Label.Binding.preferredMaxLayoutWidth(v)) }) }
}

protocol LabelConvertible: ViewConvertible {
	func uiLabel() -> Label.Instance
}
extension LabelConvertible {
	func uiView() -> View.Instance { return uiLabel() }
}
extension Label.Instance: LabelConvertible {
	func uiLabel() -> Label.Instance { return self }
}

protocol LabelBinding: ViewBinding {
	static func labelBinding(_ binding: Label.Binding) -> Self
}

extension LabelBinding {
	static func viewBinding(_ binding: View.Binding) -> Self {
		return labelBinding(.inheritedBinding(binding))
	}
}

/// Storage for the string data associated with a `UITableView` section.
struct TableSectionMetadata {
	let header: String?
	let footer: String?
	init(header: String? = nil, footer: String? = nil) {
		(self.header, self.footer) = (header, footer)
	}
}

/// This data type models the most recent change to a section of a `UITableView`. When used as the `Value` type for a `TableRowMutation`, the combined data type can model all the section, header, footer and row data of an entire `UITableView`.
struct TableSectionMutation<Value>: ExpressibleByArrayLiteral {
	let metadata: TableSectionMetadata?
	let rowMutation: TableRowMutation<Value>

	init(metadata: TableSectionMetadata?, rowMutation: TableRowMutation<Value>) {
		self.metadata = metadata
		self.rowMutation = rowMutation
	}
	
	init(header: String? = nil, footer: String? = nil, rowMutation: TableRowMutation<Value>) {
		let metadata = header != nil || footer != nil ? TableSectionMetadata(header: header, footer: footer) : nil
		self.init(metadata: metadata, rowMutation: rowMutation)
	}
	
	init(arrayLiteral elements: Value...) {
		self.init(rowMutation: TableRowMutation(array: elements))
	}
	
	init() {
		self.init(rowMutation: TableRowMutation())
	}
}

/// A data type that can be used to cache the destination end of a `TableSectionMutation<Value>` change stream.
struct TableSectionState<Value> {
	var rowState = TableRowState<Value>()
	var metadata: TableSectionMetadata
	
	init(initial: TableSectionMutation<Value>) {
		self.metadata = initial.metadata ?? TableSectionMetadata()
		initial.rowMutation.apply(to: &rowState)
	}
	
	var rows: Deque<Value> {
		get {
			return rowState.rows
		} set {
			rowState.rows = newValue
		}
	}
	
	var localOffset: Int {
		get {
			return rowState.localOffset
		} set {
			rowState.localOffset = newValue
		}
	}
	
	var globalCount: Int {
		get {
			return rowState.globalCount
		} set {
			rowState.globalCount = newValue
		}
	}
}

/// An extension of the same premise in `TableRowMutation.apply` for `TableRowMutation<TableSectionMutation<Value>>` that maps the `TableSectionMutation` onto a `TableSectionState` and correctly applies the mutation in the nested `TableSectionMutation` to the target on update.
extension TableRowMutation {
	func apply<Row>(to sections: inout TableRowState<TableSectionState<Row>>) where TableSectionMutation<Row> == Value {
		sections.globalCount = self.globalCount
		sections.localOffset = self.localOffset
		let indexSet = self.arrayMutation.indexSet
		let values = self.arrayMutation.values
		switch self.arrayMutation.kind {
		case .delete:
			indexSet.rangeView.reversed().forEach { sections.rows.removeSubrange($0) }
		case .scroll(let offset):
			sections.rows.removeSubrange(offset > 0 ? sections.rows.startIndex..<offset : (sections.rows.endIndex + offset)..<sections.rows.endIndex)
			sections.rows.insert(contentsOf: values.map { TableSectionState<Row>(initial: $0) }, at: offset > 0 ? sections.rows.endIndex : sections.rows.startIndex)
		case .move(let index):
			let moving = indexSet.map { sections.rows[$0] }
			indexSet.rangeView.reversed().forEach { sections.rows.removeSubrange($0) }
			sections.rows.insert(contentsOf: moving, at: index)
		case .insert:
			for (i, v) in zip(indexSet, values) {
				sections.rows.insert(TableSectionState<Row>(initial: v), at: i)
			}
		case .update:
			for (valuesIndex, sectionIndex) in indexSet.enumerated() {
				var section = sections.rows[sectionIndex]
				let mutation = values[valuesIndex]
				if let m = mutation.metadata {
					section.metadata = m
				}
				mutation.rowMutation.apply(to: &section.rowState)
				sections.rows.replaceSubrange(sectionIndex..<(sectionIndex + 1), with: CollectionOfOne(section))
			}
		case .reload:
			sections.rows.replaceSubrange(sections.rows.startIndex..<sections.rows.endIndex, with: values.map { TableSectionState<Row>(initial: $0) })
		}
	}
}


class NavigationItem: ConstructingBinder, NavigationItemConvertible {
	typealias Instance = UINavigationItem
	typealias Inherited = BaseBinder
	
	var state: ConstructingBinderState<Instance, Binding>
	required init(state: ConstructingBinderState<Instance, Binding>) {
		self.state = state
	}
	static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	func uiNavigationItem() -> Instance { return instance() }
	
	enum Binding: NavigationItemBinding {
		typealias EnclosingBinder = NavigationItem
		static func navigationItemBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case title(Dynamic<String>)
		case titleView(Dynamic<ViewConvertible?>)
		case prompt(Dynamic<String?>)
		case backBarButtonItem(Dynamic<BarButtonItemConvertible?>)
		case hidesBackButton(Dynamic<SetOrAnimate<Bool>>)
		case leftBarButtonItems(Dynamic<SetOrAnimate<[BarButtonItemConvertible]>>)
		case rightBarButtonItems(Dynamic<SetOrAnimate<[BarButtonItemConvertible]>>)
		case leftItemsSupplementBackButton(Dynamic<Bool>)

		// 2. Signal bindings are performed on the object after construction.

		// 3. Action bindings are triggered by the object after construction.

		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}

	struct Preparer: ConstructingPreparer {
		typealias EnclosingBinder = NavigationItem
		var linkedPreparer = Inherited.Preparer()
		
		func constructStorage() -> EnclosingBinder.Storage { return Storage() }
		func constructInstance(subclass: EnclosingBinder.Instance.Type) -> EnclosingBinder.Instance { return subclass.init() }
		
		init() {}
		
		func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
			switch binding {
			case .title(let x): return x.apply(instance, storage) { i, s, v in i.title = v }
			case .titleView(let x): return x.apply(instance, storage) { i, s, v in i.titleView = v?.uiView() }
			case .prompt(let x): return x.apply(instance, storage) { i, s, v in i.prompt = v }
			case .backBarButtonItem(let x): return x.apply(instance, storage) { i, s, v in i.backBarButtonItem = v?.uiBarButtonItem() }
			case .hidesBackButton(let x): return x.apply(instance, storage) { i, s, v in i.setHidesBackButton(v.value, animated: v.isAnimated) }
			case .leftBarButtonItems(let x): return x.apply(instance, storage) { i, s, v in i.setLeftBarButtonItems(v.value.map { $0.uiBarButtonItem() }, animated: v.isAnimated) }
			case .rightBarButtonItems(let x): return x.apply(instance, storage) { i, s, v in i.setRightBarButtonItems(v.value.map { $0.uiBarButtonItem() }, animated: v.isAnimated) }
			case .leftItemsSupplementBackButton(let x): return x.apply(instance, storage) { i, s, v in i.leftItemsSupplementBackButton = v }
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: (), storage: ())
			}
		}
	}

	typealias Storage = ObjectBinderStorage
}

extension BindingName where Binding: NavigationItemBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .navigationItemBinding(NavigationItem.Binding.$1(v)) }) }
	static var title: BindingName<Dynamic<String>, Binding> { return BindingName<Dynamic<String>, Binding>({ v in .navigationItemBinding(NavigationItem.Binding.title(v)) }) }
	static var titleView: BindingName<Dynamic<ViewConvertible?>, Binding> { return BindingName<Dynamic<ViewConvertible?>, Binding>({ v in .navigationItemBinding(NavigationItem.Binding.titleView(v)) }) }
	static var prompt: BindingName<Dynamic<String?>, Binding> { return BindingName<Dynamic<String?>, Binding>({ v in .navigationItemBinding(NavigationItem.Binding.prompt(v)) }) }
	static var backBarButtonItem: BindingName<Dynamic<BarButtonItemConvertible?>, Binding> { return BindingName<Dynamic<BarButtonItemConvertible?>, Binding>({ v in .navigationItemBinding(NavigationItem.Binding.backBarButtonItem(v)) }) }
	static var hidesBackButton: BindingName<Dynamic<SetOrAnimate<Bool>>, Binding> { return BindingName<Dynamic<SetOrAnimate<Bool>>, Binding>({ v in .navigationItemBinding(NavigationItem.Binding.hidesBackButton(v)) }) }
	static var leftBarButtonItems: BindingName<Dynamic<SetOrAnimate<[BarButtonItemConvertible]>>, Binding> { return BindingName<Dynamic<SetOrAnimate<[BarButtonItemConvertible]>>, Binding>({ v in .navigationItemBinding(NavigationItem.Binding.leftBarButtonItems(v)) }) }
	static var rightBarButtonItems: BindingName<Dynamic<SetOrAnimate<[BarButtonItemConvertible]>>, Binding> { return BindingName<Dynamic<SetOrAnimate<[BarButtonItemConvertible]>>, Binding>({ v in .navigationItemBinding(NavigationItem.Binding.rightBarButtonItems(v)) }) }
	static var leftItemsSupplementBackButton: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .navigationItemBinding(NavigationItem.Binding.leftItemsSupplementBackButton(v)) }) }
}

extension BindingName where Binding: NavigationItemBinding {
	// Additional helper binding names
	static func leftBarButtonItems(animate: AnimationChoice = .subsequent) -> BindingName<Dynamic<[BarButtonItemConvertible]>, Binding> { return BindingName<Dynamic<[BarButtonItemConvertible]>, Binding>({ (v: Dynamic<[BarButtonItemConvertible]>) -> Binding in
		switch v {
		case .constant(let b) where animate == .all: return Binding.navigationItemBinding(NavigationItem.Binding.leftBarButtonItems(Dynamic.constant(.animate(b))))
		case .constant(let b): return Binding.navigationItemBinding(NavigationItem.Binding.leftBarButtonItems(Dynamic.constant(.set(b))))
		case .dynamic(let b): return Binding.navigationItemBinding(NavigationItem.Binding.leftBarButtonItems(Dynamic.dynamic(b.animate(animate))))
		}
	}) }
	static func rightBarButtonItems(animate: AnimationChoice = .subsequent) -> BindingName<Dynamic<[BarButtonItemConvertible]>, Binding> { return BindingName<Dynamic<[BarButtonItemConvertible]>, Binding>({ (v: Dynamic<[BarButtonItemConvertible]>) -> Binding in
		switch v {
		case .constant(let b) where animate == .all: return Binding.navigationItemBinding(NavigationItem.Binding.rightBarButtonItems(Dynamic.constant(.animate(b))))
		case .constant(let b): return Binding.navigationItemBinding(NavigationItem.Binding.rightBarButtonItems(Dynamic.constant(.set(b))))
		case .dynamic(let b): return Binding.navigationItemBinding(NavigationItem.Binding.rightBarButtonItems(Dynamic.dynamic(b.animate(animate))))
		}
	}) }
}

protocol NavigationItemConvertible {
	func uiNavigationItem() -> NavigationItem.Instance
}
extension NavigationItem.Instance: NavigationItemConvertible {
	func uiNavigationItem() -> NavigationItem.Instance { return self }
}

protocol NavigationItemBinding: BaseBinding {
	static func navigationItemBinding(_ binding: NavigationItem.Binding) -> Self
}
extension NavigationItemBinding {
	static func baseBinding(_ binding: BaseBinder.Binding) -> Self {
		return navigationItemBinding(.inheritedBinding(binding))
	}
}

import UIKit

class TabBar<ItemIdentifier: Hashable>: ConstructingBinder, TabBarConvertible {
	typealias Instance = UITabBar
	typealias Inherited = View
	
	var state: ConstructingBinderState<Instance, Binding>
	required init(state: ConstructingBinderState<Instance, Binding>) {
		self.state = state
	}
	static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	func uiTabBar() -> Instance { return instance() }
	
	enum Binding: TabBarBinding {
		typealias ItemIdentifierType = ItemIdentifier
		typealias EnclosingBinder = TabBar
		static func tabBarBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		// 0. Static bindings are applied at construction and are subsequently immutable.

		// 1. Value bindings may be applied at construction and may subsequently change.
		case items(Dynamic<SetOrAnimate<[ItemIdentifier]>>)
		case barStyle(Dynamic<UIBarStyle>)
		case isTranslucent(Dynamic<Bool>)
		case barTintColor(Dynamic<UIColor>)
		case tintColor(Dynamic<UIColor>)
		@available(iOS 10.0, *)
		case unselectedItemTintColor(Dynamic<UIColor>)
		case backgroundImage(Dynamic<UIImage?>)
		case shadowImage(Dynamic<UIImage?>)
		case selectionIndicatorImage(Dynamic<UIImage?>)
		case itemPositioning(Dynamic<UITabBar.ItemPositioning>)
		case itemSpacing(Dynamic<CGFloat>)
		case itemWidth(Dynamic<CGFloat>)

		// 2. Signal bindings are performed on the object after construction.
		case selectItem(Signal<ItemIdentifier>)
		case customizingItems(Signal<SetOrAnimate<[ItemIdentifier]?>>)

		// 3. Action bindings are triggered by the object after construction.
		case willBeginCustomizing(SignalInput<[ItemIdentifier]>)
		case didBeginCustomizing(SignalInput<[ItemIdentifier]>)
		case willEndCustomizing(SignalInput<([ItemIdentifier], Bool)>)
		case didEndCustomizing(SignalInput<([ItemIdentifier], Bool)>)
		case didSelectItem(SignalInput<ItemIdentifier>)

		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case itemConstructor((ItemIdentifier) -> TabBarItemConvertible)
	}

	struct Preparer: ConstructingPreparer {
		typealias EnclosingBinder = TabBar
		var linkedPreparer = Inherited.Preparer()

		func constructStorage() -> EnclosingBinder.Storage { return Storage() }
		func constructInstance(subclass: EnclosingBinder.Instance.Type) -> EnclosingBinder.Instance { return subclass.init() }

		init() {
			self.init(delegateClass: Delegate.self)
		}
		init<Value>(delegateClass: Value.Type) where Value: Delegate {
			self.delegateClass = delegateClass
		}
		let delegateClass: Delegate.Type
		var possibleDelegate: Delegate? = nil
		mutating func delegate() -> Delegate {
			if let d = possibleDelegate {
				return d
			} else {
				let d = delegateClass.init()
				possibleDelegate = d
				return d
			}
		}
		
		var tabBarItemConstructor: ((ItemIdentifier) -> TabBarItemConvertible)?

		mutating func prepareBinding(_ binding: Binding) {
			switch binding {
			case .itemConstructor(let x): tabBarItemConstructor = x
			case .willBeginCustomizing(let x):
				let s = #selector(UITabBarDelegate.tabBar(_:willBeginCustomizing:))
				delegate().addSelector(s).willBeginCustomizing = x
			case .didBeginCustomizing(let x):
				let s = #selector(UITabBarDelegate.tabBar(_:didBeginCustomizing:))
				delegate().addSelector(s).didBeginCustomizing = x
			case .willEndCustomizing(let x):
				let s = #selector(UITabBarDelegate.tabBar(_:willEndCustomizing:changed:))
				delegate().addSelector(s).willEndCustomizing = x
			case .didEndCustomizing(let x):
				let s = #selector(UITabBarDelegate.tabBar(_:didEndCustomizing:changed:))
				delegate().addSelector(s).didEndCustomizing = x
			case .didSelectItem(let x):
				let s = #selector(UITabBarDelegate.tabBar(_:didSelect:))
				delegate().addSelector(s).didSelectIndex = x
			case .inheritedBinding(let x): linkedPreparer.prepareBinding(x)
			default: break
			}
		}
		
		mutating func prepareInstance(_ instance: Instance, storage: Storage) {
			precondition(instance.delegate == nil, "Conflicting delegate applied to instance")

			storage.dynamicDelegate = possibleDelegate
			storage.tabBarItemConstructor = tabBarItemConstructor
			
			if storage.inUse {
				instance.delegate = storage
			}
			
			linkedPreparer.prepareInstance(instance, storage: storage)
		}
		
		func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
			switch binding {
			// e.g. case .someProperty(let x): return x.apply(instance, storage) { inst, stor, val in inst.someProperty = val }
			case .itemConstructor: return nil
			case .items(let x):
				return x.apply(instance, storage) { inst, stor, val in
					let items = val.value.compactMap { stor.tabBarItem(for: $0) }
					inst.setItems(items, animated: val.isAnimated)
				}
			case .selectItem(let x): return x.apply(instance, storage) { inst, stor, val in inst.selectedItem = stor.tabBarItem(for: val) }
			case .barStyle(let x): return x.apply(instance, storage) { inst, stor, val in inst.barStyle = val }
			case .isTranslucent(let x): return x.apply(instance, storage) { inst, stor, val in inst.isTranslucent = val }
			case .barTintColor(let x): return x.apply(instance, storage) { inst, stor, val in inst.barTintColor = val }
			case .tintColor(let x): return x.apply(instance, storage) { inst, stor, val in inst.tintColor = val }
			case .unselectedItemTintColor(let x): return x.apply(instance, storage) { inst, stor, val in
					if #available(iOS 10.0, *) {
						inst.unselectedItemTintColor = val
					}
				}
			case .backgroundImage(let x): return x.apply(instance, storage) { inst, stor, val in inst.backgroundImage = val }
			case .shadowImage(let x): return x.apply(instance, storage) { inst, stor, val in inst.shadowImage = val }
			case .selectionIndicatorImage(let x): return x.apply(instance, storage) { inst, stor, val in inst.selectionIndicatorImage = val }
			case .itemPositioning(let x): return x.apply(instance, storage) { inst, stor, val in inst.itemPositioning = val }
			case .itemSpacing(let x): return x.apply(instance, storage) { inst, stor, val in inst.itemSpacing = val }
			case .itemWidth(let x): return x.apply(instance, storage) { inst, stor, val in inst.itemWidth = val }
			case .customizingItems(let x): return x.apply(instance, storage) { inst, stor, val in
				if let v = val.value {
					let items = v.compactMap { stor.tabBarItem(for: $0) }
					inst.beginCustomizingItems(items)
				} else {
					inst.endCustomizing(animated: val.isAnimated)
				}
			}
			case .willBeginCustomizing: return nil
			case .didBeginCustomizing: return nil
			case .willEndCustomizing: return nil
			case .didEndCustomizing: return nil
			case .didSelectItem: return nil
			case .inheritedBinding(let b): return linkedPreparer.applyBinding(b, instance: instance, storage: storage)
			}
		}
	}

	class Storage: View.Storage, UITabBarDelegate {
		var tabBarItemConstructor: ((ItemIdentifier) -> TabBarItemConvertible)?
		var allItems: [ItemIdentifier: TabBarItemConvertible] = [:]
		
		override var inUse: Bool { return true }
		
		func identifier(for tabBarItem: UITabBarItem) -> ItemIdentifier? {
			return allItems.first(where: { pair -> Bool in
				pair.value.uiTabBarItem() === tabBarItem
			})?.key
		}
		func tabBarItem(for identifier: ItemIdentifier) -> UITabBarItem? {
			if let existing = allItems[identifier] {
				return existing.uiTabBarItem()
			}
			if let constructor = tabBarItemConstructor {
				let new = constructor(identifier)
				allItems[identifier] = new
				return new.uiTabBarItem()
			}
			return nil
		}
	}
	
	class Delegate: DynamicDelegate, UITabBarDelegate {
		required override init() {
			super.init()
		}

		var didSelectIndex: SignalInput<ItemIdentifier>?
		func tabBar(_ tabBar: UITabBar, didSelect item: UITabBarItem) {
			if let identifier = (tabBar.delegate as? Storage)?.identifier(for: item) {
				didSelectIndex?.send(value: identifier)
			}
		}

		var willBeginCustomizing: SignalInput<[ItemIdentifier]>?
		func tabBar(_ tabBar: UITabBar, willBeginCustomizing items: [UITabBarItem]) {
			if let storage = tabBar.delegate as? Storage {
				willBeginCustomizing?.send(value: items.compactMap { storage.identifier(for: $0) })
			}
		}

		var didBeginCustomizing: SignalInput<[ItemIdentifier]>?
		func tabBar(_ tabBar: UITabBar, didBeginCustomizing items: [UITabBarItem]) {
			if let storage = tabBar.delegate as? Storage {
				didBeginCustomizing?.send(value: items.compactMap { storage.identifier(for: $0) })
			}
		}

		var willEndCustomizing: SignalInput<([ItemIdentifier], Bool)>?
		func tabBar(_ tabBar: UITabBar, willEndCustomizing items: [UITabBarItem], changed: Bool) {
			if let storage = tabBar.delegate as? Storage {
				willEndCustomizing?.send(value: (items.compactMap { storage.identifier(for: $0) }, changed))
			}
		}

		var didEndCustomizing: SignalInput<([ItemIdentifier], Bool)>?
		func tabBar(_ tabBar: UITabBar, didEndCustomizing items: [UITabBarItem], changed: Bool) {
			if let storage = tabBar.delegate as? Storage {
				didEndCustomizing?.send(value: (items.compactMap { storage.identifier(for: $0) }, changed))
			}
		}
	}
}

extension BindingName where Binding: TabBarBinding {
	// You can easily convert the `Binding` cases to `BindingName` by copying them to here and using the following Xcode-style regex:
	// Find:    case ([^\(]+)\((.+)\)$
	// Replace: static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .tabBarBinding(TabBar<Binding.ItemIdentifierType>.Binding.$1(v)) }) }
	static var items: BindingName<Dynamic<SetOrAnimate<[Binding.ItemIdentifierType]>>, Binding> { return BindingName<Dynamic<SetOrAnimate<[Binding.ItemIdentifierType]>>, Binding>({ v in .tabBarBinding(TabBar<Binding.ItemIdentifierType>.Binding.items(v)) }) }
	static var selectItem: BindingName<Signal<Binding.ItemIdentifierType>, Binding> { return BindingName<Signal<Binding.ItemIdentifierType>, Binding>({ v in .tabBarBinding(TabBar<Binding.ItemIdentifierType>.Binding.selectItem(v)) }) }
	static var barStyle: BindingName<Dynamic<UIBarStyle>, Binding> { return BindingName<Dynamic<UIBarStyle>, Binding>({ v in .tabBarBinding(TabBar<Binding.ItemIdentifierType>.Binding.barStyle(v)) }) }
	static var isTranslucent: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .tabBarBinding(TabBar<Binding.ItemIdentifierType>.Binding.isTranslucent(v)) }) }
	static var barTintColor: BindingName<Dynamic<UIColor>, Binding> { return BindingName<Dynamic<UIColor>, Binding>({ v in .tabBarBinding(TabBar<Binding.ItemIdentifierType>.Binding.barTintColor(v)) }) }
	static var tintColor: BindingName<Dynamic<UIColor>, Binding> { return BindingName<Dynamic<UIColor>, Binding>({ v in .tabBarBinding(TabBar<Binding.ItemIdentifierType>.Binding.tintColor(v)) }) }
	@available(iOS 10.0, *)
	static var unselectedItemTintColor: BindingName<Dynamic<UIColor>, Binding> { return BindingName<Dynamic<UIColor>, Binding>({ v in .tabBarBinding(TabBar<Binding.ItemIdentifierType>.Binding.unselectedItemTintColor(v)) }) }
	static var backgroundImage: BindingName<Dynamic<UIImage?>, Binding> { return BindingName<Dynamic<UIImage?>, Binding>({ v in .tabBarBinding(TabBar<Binding.ItemIdentifierType>.Binding.backgroundImage(v)) }) }
	static var shadowImage: BindingName<Dynamic<UIImage?>, Binding> { return BindingName<Dynamic<UIImage?>, Binding>({ v in .tabBarBinding(TabBar<Binding.ItemIdentifierType>.Binding.shadowImage(v)) }) }
	static var selectionIndicatorImage: BindingName<Dynamic<UIImage?>, Binding> { return BindingName<Dynamic<UIImage?>, Binding>({ v in .tabBarBinding(TabBar<Binding.ItemIdentifierType>.Binding.selectionIndicatorImage(v)) }) }
	static var itemPositioning: BindingName<Dynamic<UITabBar.ItemPositioning>, Binding> { return BindingName<Dynamic<UITabBar.ItemPositioning>, Binding>({ v in .tabBarBinding(TabBar<Binding.ItemIdentifierType>.Binding.itemPositioning(v)) }) }
	static var itemSpacing: BindingName<Dynamic<CGFloat>, Binding> { return BindingName<Dynamic<CGFloat>, Binding>({ v in .tabBarBinding(TabBar<Binding.ItemIdentifierType>.Binding.itemSpacing(v)) }) }
	static var itemWidth: BindingName<Dynamic<CGFloat>, Binding> { return BindingName<Dynamic<CGFloat>, Binding>({ v in .tabBarBinding(TabBar<Binding.ItemIdentifierType>.Binding.itemWidth(v)) }) }
	static var customizingItems: BindingName<Signal<SetOrAnimate<[Binding.ItemIdentifierType]?>>, Binding> { return BindingName<Signal<SetOrAnimate<[Binding.ItemIdentifierType]?>>, Binding>({ v in .tabBarBinding(TabBar<Binding.ItemIdentifierType>.Binding.customizingItems(v)) }) }
	static var willBeginCustomizing: BindingName<SignalInput<[Binding.ItemIdentifierType]>, Binding> { return BindingName<SignalInput<[Binding.ItemIdentifierType]>, Binding>({ v in .tabBarBinding(TabBar<Binding.ItemIdentifierType>.Binding.willBeginCustomizing(v)) }) }
	static var didBeginCustomizing: BindingName<SignalInput<[Binding.ItemIdentifierType]>, Binding> { return BindingName<SignalInput<[Binding.ItemIdentifierType]>, Binding>({ v in .tabBarBinding(TabBar<Binding.ItemIdentifierType>.Binding.didBeginCustomizing(v)) }) }
	static var willEndCustomizing: BindingName<SignalInput<([Binding.ItemIdentifierType], Bool)>, Binding> { return BindingName<SignalInput<([Binding.ItemIdentifierType], Bool)>, Binding>({ v in .tabBarBinding(TabBar<Binding.ItemIdentifierType>.Binding.willEndCustomizing(v)) }) }
	static var didEndCustomizing: BindingName<SignalInput<([Binding.ItemIdentifierType], Bool)>, Binding> { return BindingName<SignalInput<([Binding.ItemIdentifierType], Bool)>, Binding>({ v in .tabBarBinding(TabBar<Binding.ItemIdentifierType>.Binding.didEndCustomizing(v)) }) }
	static var didSelectItem: BindingName<SignalInput<Binding.ItemIdentifierType>, Binding> { return BindingName<SignalInput<Binding.ItemIdentifierType>, Binding>({ v in .tabBarBinding(TabBar<Binding.ItemIdentifierType>.Binding.didSelectItem(v)) }) }
	static var itemConstructor: BindingName<(Binding.ItemIdentifierType) -> TabBarItemConvertible, Binding> { return BindingName<(Binding.ItemIdentifierType) -> TabBarItemConvertible, Binding>({ v in .tabBarBinding(TabBar<Binding.ItemIdentifierType>.Binding.itemConstructor(v)) }) }
}

protocol TabBarConvertible {
	func uiTabBar() -> UITabBar
}
extension TabBarConvertible {
	func uiView() -> View.Instance { return uiTabBar() }
}
extension TabBar.Instance: TabBarConvertible {
	func uiTabBar() -> UITabBar { return self }
}

protocol TabBarBinding: ViewBinding {
	associatedtype ItemIdentifierType: Hashable
	static func tabBarBinding(_ binding: TabBar<ItemIdentifierType>.Binding) -> Self
}
extension TabBarBinding {
	static func viewBinding(_ binding: View.Binding) -> Self {
		return tabBarBinding(.inheritedBinding(binding))
	}
}

func applicationMain(subclass: UIApplication.Type = UIApplication.self, application: @escaping () -> Application) -> Never {
	Application.Storage.finish = { () -> Void in
		application().applyBindings(to: UIApplication.shared)
	}
	
	return CommandLine.unsafeArgv.withMemoryRebound(to: Optional<UnsafeMutablePointer<Int8>>.self, capacity: Int(CommandLine.argc)) { argv -> Never in
		_ = UIApplicationMain(CommandLine.argc, argv, NSStringFromClass(subclass), NSStringFromClass(Application.Storage.self))
		fatalError("UIApplicationMain completed unexpectedly")
	}
}

class Application: Binder {
	typealias Inherited = BaseBinder
	typealias Instance = UIApplication
	
	var state: BinderState<Instance, BindingsOnlyParameters<Binding>>
	required init(state: BinderState<Instance, BindingsOnlyParameters<Binding>>) {
		self.state = state
	}
	static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}

	enum Binding: ApplicationBinding {
		typealias EnclosingBinder = Application
		static func applicationBinding(_ binding: Application.Binding) -> Application.Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		//	1. Value bindings may be applied at construction and may subsequently change.
		case ignoreInteractionEvents(Dynamic<Bool>)
		case supportShakeToEdit(Dynamic<Bool>)
		case isIdleTimerDisabled(Dynamic<Bool>)
		case shortcutItems(Dynamic<[UIApplicationShortcutItem]?>)
		case isNetworkActivityIndicatorVisible(Dynamic<Bool>)
		case applicationIconBadgeNumber(Dynamic<Int>)
		case window(Dynamic<WindowConvertible?>)
		case additionalWindows(Dynamic<[WindowConvertible]>)

		//	2. Signal bindings are performed on the object after construction.

		//	3. Action bindings are triggered by the object after construction.
		case didBecomeActive(SignalInput<Void>)
		case willResignActive(SignalInput<Void>)
		case didEnterBackground(SignalInput<Void>)
		case willEnterForeground(SignalInput<Void>)
		case protectedDataWillBecomeUnavailable(SignalInput<Void>)
		case protectedDataDidBecomeAvailable(SignalInput<Void>)
		case didReceiveMemoryWarning(SignalInput<Void>)
		case significantTimeChange(SignalInput<Void>)
		case performFetch(SignalInput<SignalInput<UIBackgroundFetchResult>>)
		case handleEventsForBackgroundURLSession(SignalInput<Callback<String, ()>>)
		@available(iOS, introduced: 8.0, deprecated: 10.0, message: "Use UserNotifications Framework's UNNotificationSettings")
		case registerUserNotificationSettings(Signal<UIUserNotificationSettings>)
		case registerForRemoteNotifications(Signal<Bool>)
		@available(iOS, introduced: 8.0, deprecated: 10.0, message: "Use UserNotifications Framework's UNNotificationSettings")
		case didRegisterUserNotifications(SignalInput<UIUserNotificationSettings>)
		case didRegisterRemoteNotifications(SignalInput<Result<Data>>)
		@available(iOS, introduced: 8.0, deprecated: 10.0, message: "Use UserNotifications Framework's UNNotificationSettings")
		case didReceiveLocalNotification(SignalInput<UILocalNotification>)
		case didReceiveRemoteNotification(SignalInput<Callback<[AnyHashable: Any], UIBackgroundFetchResult>>)
		@available(iOS, introduced: 8.0, deprecated: 10.0, message: "Use UserNotifications Framework's UNNotificationSettings")
		case handleLocalNotificationAction(SignalInput<Callback<(String?, UILocalNotification), ()>>)
		@available(iOS, introduced: 8.0, deprecated: 10.0, message: "Use UserNotifications Framework's UNNotificationSettings")
		case handleRemoteNotificationAction(SignalInput<Callback<(String?, [AnyHashable : Any]), ()>>)
		@available(iOS, introduced: 9.0, deprecated: 10.0, message: "Use UserNotifications Framework's UNNotificationSettings")
		case handleLocalNotificationResponseInfoAction(SignalInput<Callback<(String?, UILocalNotification, [AnyHashable : Any]), ()>>)
		@available(iOS, introduced: 9.0, deprecated: 10.0, message: "Use UserNotifications Framework's UNNotificationSettings")
		case handleRemoteNotificationResponseInfoAction(SignalInput<Callback<(String?, [AnyHashable : Any], [AnyHashable : Any]), ()>>)
		case didFailToContinueUserActivity(SignalInput<(String, Error)>)
		case performAction(SignalInput<Callback<UIApplicationShortcutItem, Bool>>)
		case handleWatchKitExtensionRequest(SignalInput<Callback<[AnyHashable: Any]?, [AnyHashable: Any]?>>)

		//	4. Delegate bindings require synchronous evaluation within the object's context.
		case willContinueUserActivity((String) -> Bool)
		case continueUserActivity((Callback<NSUserActivity, [UIUserActivityRestoring]?>) -> Bool)
		case didUpdate((NSUserActivity) -> Void)
		case willFinishLaunching(([UIApplication.LaunchOptionsKey: Any]?) -> Bool)
		case didFinishLaunching(([UIApplication.LaunchOptionsKey: Any]?) -> Bool)
		case willEncodeRestorableState((NSKeyedArchiver) -> Void)
		case didDecodeRestorableState((NSKeyedUnarchiver) -> Void)
		case willTerminate(() -> Void)
		case shouldSaveApplicationState((_ coder: NSCoder) -> Bool)
		case shouldRestoreApplicationState((_ coder: NSCoder) -> Bool)
		case viewControllerWithRestorationPath((_ path: [String], _ coder: NSCoder) -> UIViewController)
		case open((_ url: URL, _ options: [UIApplication.OpenURLOptionsKey: Any]) -> Bool)
		case shouldAllowExtensionPointIdentifier((UIApplication.ExtensionPointIdentifier) -> Bool)
		case shouldRequestHealthAuthorization(() -> Void)
	}

	struct Preparer: StoragePreparer {
		typealias EnclosingBinder = Application
		var linkedPreparer = Inherited.Preparer()
		
		func constructStorage() -> EnclosingBinder.Storage {
			let storage: Storage
			if let s = Storage.underConstruction {
				storage = s
			} else {
				storage = Storage()
			}
			return storage
		}
		
		init() {
			self.init(delegateClass: Delegate.self)
		}
		init<Value>(delegateClass: Value.Type) where Value: Delegate {
			self.delegateClass = delegateClass
		}
		let delegateClass: Delegate.Type
		var possibleDelegate: Delegate? = nil
		mutating func delegate() -> Delegate {
			if let d = possibleDelegate {
				return d
			} else {
				let d = delegateClass.init()
				possibleDelegate = d
				return d
			}
		}
		
		mutating func prepareBinding(_ binding: Binding) {
			switch binding {
			case .didFinishLaunching(let x):
				let s = #selector(UIApplicationDelegate.application(_:didFinishLaunchingWithOptions:))
				delegate().addSelector(s).didFinishLaunching = x
			case .willTerminate(let x):
				let s = #selector(UIApplicationDelegate.applicationWillTerminate(_:))
				delegate().addSelector(s).willTerminate = x
			case .protectedDataWillBecomeUnavailable(let x):
				let s = #selector(UIApplicationDelegate.applicationProtectedDataWillBecomeUnavailable(_:))
				delegate().addSelector(s).protectedDataWillBecomeUnavailable = x
			case .protectedDataDidBecomeAvailable(let x):
				let s = #selector(UIApplicationDelegate.applicationProtectedDataDidBecomeAvailable(_:))
				delegate().addSelector(s).protectedDataDidBecomeAvailable = x
			case .willEncodeRestorableState(let x):
				let s = #selector(UIApplicationDelegate.application(_:willEncodeRestorableStateWith:))
				delegate().addSelector(s).willEncodeRestorableState = x
				
				// Automatically enable `shouldSaveApplicationState` if `willEncodeRestorableState` is isEnabled
				if delegate().shouldSaveApplicationState == nil {
					let shouldSave = #selector(UIApplicationDelegate.application(_:shouldSaveApplicationState:))
					delegate().addSelector(shouldSave).shouldSaveApplicationState = { _ in return true }
				}
			case .didDecodeRestorableState(let x):
				let s = #selector(UIApplicationDelegate.application(_:didDecodeRestorableStateWith:))
				delegate().addSelector(s).didDecodeRestorableState = x
				
				// Automatically enable `shouldRestoreApplicationState` if `didDecodeRestorableState` is isEnabled
				if delegate().shouldRestoreApplicationState == nil {
					let shouldRestore = #selector(UIApplicationDelegate.application(_:shouldRestoreApplicationState:))
					delegate().addSelector(shouldRestore).shouldRestoreApplicationState = { _ in return true }
				}
			case .performFetch(let x):
				let s = #selector(UIApplicationDelegate.application(_:performFetchWithCompletionHandler:))
				delegate().addSelector(s).performFetch = x
			case .handleEventsForBackgroundURLSession(let x):
				let s = #selector(UIApplicationDelegate.application(_:handleEventsForBackgroundURLSession:completionHandler:))
				delegate().addSelector(s).handleEventsForBackgroundURLSession = x
			case .didRegisterUserNotifications(let x):
				let s = #selector(UIApplicationDelegate.application(_:didRegister:))
				delegate().addSelector(s).didRegisterUserNotifications = x
			case .didRegisterRemoteNotifications(let x):
				let s1 = #selector(UIApplicationDelegate.application(_:didRegisterForRemoteNotificationsWithDeviceToken:))
				let s2 = #selector(UIApplicationDelegate.application(_:didFailToRegisterForRemoteNotificationsWithError:))
				delegate().addSelector(s1).didRegisterRemoteNotifications = x
				delegate().addSelector(s2)
			case .didReceiveLocalNotification(let x):
				let s = #selector(UIApplicationDelegate.application(_:didReceive:))
				delegate().addSelector(s).didReceiveLocalNotification = x
			case .didReceiveRemoteNotification(let x):
				let s = #selector(UIApplicationDelegate.application(_:didReceiveRemoteNotification:fetchCompletionHandler:))
				delegate().addSelector(s).didReceiveRemoteNotification = x
			case .handleLocalNotificationAction(let x):
				let s = #selector(UIApplicationDelegate.application(_:handleActionWithIdentifier:for:completionHandler:))
				delegate().addSelector(s).handleLocalNotificationAction = x
			case .handleRemoteNotificationAction(let x):
				let s = #selector(UIApplicationDelegate.application(_:handleActionWithIdentifier:forRemoteNotification:completionHandler:))
				delegate().addSelector(s).handleRemoteNotificationAction = x
			case .handleLocalNotificationResponseInfoAction(let x):
				let s = #selector(UIApplicationDelegate.application(_:didReceive:))
				delegate().addSelector(s).handleLocalNotificationResponseInfoAction = x
			case .handleRemoteNotificationResponseInfoAction(let x):
				let s = #selector(UIApplicationDelegate.application(_:handleActionWithIdentifier:forRemoteNotification:withResponseInfo:completionHandler:))
				delegate().addSelector(s).handleRemoteNotificationResponseInfoAction = x
			case .didFailToContinueUserActivity(let x):
				let s = #selector(UIApplicationDelegate.application(_:didFailToContinueUserActivityWithType:error:))
				delegate().addSelector(s).didFailToContinueUserActivity = x
			case .performAction(let x):
				let s = #selector(UIApplicationDelegate.application(_:performActionFor:completionHandler:))
				delegate().addSelector(s).performAction = x
			case .handleWatchKitExtensionRequest(let x):
				let s = #selector(UIApplicationDelegate.application(_:handleWatchKitExtensionRequest:reply:))
				delegate().addSelector(s).handleWatchKitExtensionRequest = x
			case .shouldRequestHealthAuthorization(let x):
				let s = #selector(UIApplicationDelegate.applicationShouldRequestHealthAuthorization(_:))
				delegate().addSelector(s).shouldRequestHealthAuthorization = x
			case .willContinueUserActivity(let x):
				let s = #selector(UIApplicationDelegate.application(_:willContinueUserActivityWithType:))
				delegate().addSelector(s).willContinueUserActivity = x
			case .continueUserActivity(let x):
				let s = #selector(UIApplicationDelegate.application(_:continue:restorationHandler:))
				delegate().addSelector(s).continueUserActivity = x
			case .didUpdate(let x):
				let s = #selector(UIApplicationDelegate.application(_:didUpdate:))
				delegate().addSelector(s).didUpdate = x
			case .shouldSaveApplicationState(let x):
				let s = #selector(UIApplicationDelegate.application(_:shouldSaveApplicationState:))
				delegate().addSelector(s).shouldSaveApplicationState = x
			case .shouldRestoreApplicationState(let x):
				let s = #selector(UIApplicationDelegate.application(_:shouldRestoreApplicationState:))
				delegate().addSelector(s).shouldRestoreApplicationState = x
			case .viewControllerWithRestorationPath(let x):
				let s = #selector(UIApplicationDelegate.application(_:viewControllerWithRestorationIdentifierPath:coder:))
				delegate().addSelector(s).viewControllerWithRestorationPath = x
			case .open(let x):
				if #available(iOS 9.0, *) {
					let s = #selector(UIApplicationDelegate.application(_:open:options:))
					delegate().addSelector(s).open = x
				}
			case .shouldAllowExtensionPointIdentifier(let x):
				let s = #selector(UIApplicationDelegate.application(_:shouldAllowExtensionPointIdentifier:))
				delegate().addSelector(s).shouldAllowExtensionPointIdentifier = x
			case .inheritedBinding(let s): linkedPreparer.prepareBinding(s)
			default: break
			}
		}
		
		mutating func prepareInstance(_ instance: Instance, storage: Storage) {
			precondition(instance.delegate == nil, "Conflicting delegate applied to instance")
			storage.dynamicDelegate = possibleDelegate
			instance.delegate = storage

			linkedPreparer.prepareInstance(instance, storage: storage)
		}
		
		func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
			switch binding {
			case .additionalWindows(let x):
				return x.apply(instance, storage) { i, s, v in
					s.additionalWindows = v.map { $0.uiWindow() }
				}
			case .window(let x):
				return x.apply(instance, storage) { i, s, v in
					s.window = v?.uiWindow()
				}
			case .ignoreInteractionEvents(let x):
				return x.apply(instance, storage) { i, s, v in
					switch (i.isIgnoringInteractionEvents, v) {
					case (false, true): i.beginIgnoringInteractionEvents()
					case (true, false): i.endIgnoringInteractionEvents()
					default: break
					}
				}
			case .supportShakeToEdit(let x): return x.apply(instance, storage) { i, s, v in i.applicationSupportsShakeToEdit = v }
			case .isIdleTimerDisabled(let x): return x.apply(instance, storage) { i, s, v in i.isIdleTimerDisabled = v }
			case .shortcutItems(let x): return x.apply(instance, storage) { i, s, v in i.shortcutItems = v }
			case .isNetworkActivityIndicatorVisible(let x): return x.apply(instance, storage) { i, s, v in i.isNetworkActivityIndicatorVisible = v }
			case .applicationIconBadgeNumber(let x): return x.apply(instance, storage) { i, s, v in i.applicationIconBadgeNumber = v }
			case .registerForRemoteNotifications(let x):
				return x.apply(instance, storage) { i, s, v in
					switch (i.isRegisteredForRemoteNotifications, v) {
					case (false, true): i.registerForRemoteNotifications()
					case (true, false): i.unregisterForRemoteNotifications()
					default: break
					}
				}
			case .registerUserNotificationSettings(let x):
				return x.apply(instance, storage) { i, s, v in
					switch i.currentUserNotificationSettings {
					case .some(let a) where a != v: i.registerUserNotificationSettings(v)
					case .none: i.registerUserNotificationSettings(v)
					default: break
					}
				}
			case .didBecomeActive(let x):
				return Signal.notifications(name: UIApplication.didBecomeActiveNotification, object: instance).map { n in return () }.cancellableBind(to: x)
			case .willResignActive(let x):
				return Signal.notifications(name: UIApplication.willResignActiveNotification, object: instance).map { n in return () }.cancellableBind(to: x)
			case .didEnterBackground(let x):
				return Signal.notifications(name: UIApplication.didEnterBackgroundNotification, object: instance).map { n in return () }.cancellableBind(to: x)
			case .willEnterForeground(let x):
				return Signal.notifications(name: UIApplication.willEnterForegroundNotification, object: instance).map { n in return () }.cancellableBind(to: x)
			case .didReceiveMemoryWarning(let x):
				return Signal.notifications(name: UIApplication.didReceiveMemoryWarningNotification, object: instance).map { n in return () }.cancellableBind(to: x)
			case .significantTimeChange(let x):
				return Signal.notifications(name: UIApplication.significantTimeChangeNotification, object: instance).map { n in return () }.cancellableBind(to: x)
			case .willFinishLaunching(let x):
				storage.willFinishLaunching = x
				return nil
			case .didFinishLaunching: return nil
			case .protectedDataWillBecomeUnavailable: return nil
			case .protectedDataDidBecomeAvailable: return nil
			case .performFetch: return nil
			case .handleEventsForBackgroundURLSession: return nil
			case .didRegisterUserNotifications: return nil
			case .didRegisterRemoteNotifications: return nil
			case .didReceiveLocalNotification: return nil
			case .didReceiveRemoteNotification: return nil
			case .handleLocalNotificationAction: return nil
			case .handleRemoteNotificationAction: return nil
			case .handleLocalNotificationResponseInfoAction: return nil
			case .handleRemoteNotificationResponseInfoAction: return nil
			case .didFailToContinueUserActivity: return nil
			case .performAction: return nil
			case .handleWatchKitExtensionRequest: return nil
			case .shouldRequestHealthAuthorization: return nil
				
			case .willContinueUserActivity: return nil
			case .continueUserActivity: return nil
			case .didUpdate: return nil
			case .willEncodeRestorableState: return nil
			case .didDecodeRestorableState: return nil
			case .willTerminate: return nil
			case .shouldSaveApplicationState: return nil
			case .shouldRestoreApplicationState: return nil
			case .viewControllerWithRestorationPath: return nil
			case .open: return nil
			case .shouldAllowExtensionPointIdentifier: return nil
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: instance, storage: storage)
			}
		}
	}

	class Storage: ObjectBinderStorage, UIApplicationDelegate {
		static var finish: (() -> Void)? = nil
		fileprivate static var underConstruction: Storage? = nil
		
		var window: UIWindow? = nil
		var additionalWindows: [UIWindow] = []
		
		var willFinishLaunching: (([UIApplication.LaunchOptionsKey: Any]?) -> Bool)?
		func application(_ application: UIApplication, willFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {
			// Disconnect the delegate since we're about to change behavior
			UIApplication.shared.delegate = nil
			
			// Apply the styles to the application and delegate.
			if let finish = Storage.finish {
				Storage.underConstruction = self
				finish()
				Storage.underConstruction = nil
				Storage.finish = nil
			} else {
				preconditionFailure("Application bindings must be initialized by calling applicationMain.")
			}
			
			assert(UIApplication.shared.delegate === self, "Failed to reconnect delegate")
			
			
			// Apply the view hierarchy
			window?.makeKeyAndVisible()
			
			// Invoke any user-supplied code
			return willFinishLaunching?(launchOptions) ?? true
		}
		
		override var inUse: Bool {
			return true
		}
	}

	class Delegate: DynamicDelegate, UIApplicationDelegate {
		required override init() {
			super.init()
		}
		
		var didFinishLaunching: (([UIApplication.LaunchOptionsKey: Any]?) -> Bool)?
		func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]? = nil) -> Bool {
			return didFinishLaunching!(launchOptions)
		}
		
		var willTerminate: (() -> Void)?
		func applicationWillTerminate(_ application: UIApplication) {
			return willTerminate!()
		}
		
		var protectedDataWillBecomeUnavailable: SignalInput<Void>?
		func applicationProtectedDataWillBecomeUnavailable(_ application: UIApplication) {
			protectedDataWillBecomeUnavailable!.send(value: ())
		}
		
		var protectedDataDidBecomeAvailable: SignalInput<Void>?
		func applicationProtectedDataDidBecomeAvailable(_ application: UIApplication) {
			protectedDataDidBecomeAvailable!.send(value: ())
		}
		
		var willEncodeRestorableState: ((NSKeyedArchiver) -> Void)?
		func application(_ application: UIApplication, willEncodeRestorableStateWith coder: NSCoder) {
			return willEncodeRestorableState!(coder as! NSKeyedArchiver)
		}
		
		var didDecodeRestorableState: ((NSKeyedUnarchiver) -> Void)?
		func application(_ application: UIApplication, didDecodeRestorableStateWith coder: NSCoder) {
			return didDecodeRestorableState!(coder as! NSKeyedUnarchiver)
		}
		
		var performFetch: SignalInput<SignalInput<UIBackgroundFetchResult>>?
		func application(_ application: UIApplication, performFetchWithCompletionHandler completionHandler: @escaping (UIBackgroundFetchResult) -> Void) {
			let (input, _) = Signal<UIBackgroundFetchResult>.create { s in
				s.subscribeUntilEnd { r in
					switch r {
					case .success(let bfr): completionHandler(bfr)
					case .failure: completionHandler(UIBackgroundFetchResult.failed)
					}
				}
			}
			performFetch!.send(value: input)
		}
		
		var handleEventsForBackgroundURLSession: SignalInput<Callback<String, ()>>?
		func application(_ application: UIApplication, handleEventsForBackgroundURLSession session: String, completionHandler: @escaping () -> Void) {
			let (input, _) = Signal<Void>.create { s in s.subscribeWhile { r in completionHandler(); return false } }
			handleEventsForBackgroundURLSession!.send(value: Callback(session, input))
		}
		
		var didRegisterUserNotifications: Any?
		@available(iOS, introduced: 8.0, deprecated: 10.0, message: "Use UserNotifications Framework's UNNotificationSettings")
		func application(_ application: UIApplication, didRegister notificationSettings: UIUserNotificationSettings) {
			(didRegisterUserNotifications as! SignalInput<UIUserNotificationSettings>).send(value: notificationSettings)
		}
		
		var didRegisterRemoteNotifications: SignalInput<Result<Data>>?
		func application(_ application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) {
			didRegisterRemoteNotifications!.send(value: Result.success(deviceToken))
		}
		func application(_ application: UIApplication, didFailToRegisterForRemoteNotificationsWithError error: Error) {
			didRegisterRemoteNotifications!.send(value: Result.failure(error))
		}
		
		var didReceiveLocalNotification: Any?
		@available(iOS, introduced: 4.0, deprecated: 10.0, message: "Use UserNotifications Framework's UNNotificationSettings")
		func application(_ application: UIApplication, didReceive: UILocalNotification) {
			(didReceiveLocalNotification as! SignalInput<UILocalNotification>).send(value: didReceive)
		}
		
		var didReceiveRemoteNotification: SignalInput<Callback<[AnyHashable: Any], UIBackgroundFetchResult>>?
		func application(_ application: UIApplication, didReceiveRemoteNotification userInfo: [AnyHashable : Any], fetchCompletionHandler completionHandler: @escaping (UIBackgroundFetchResult) -> Void) {
			let (input, _) = Signal<UIBackgroundFetchResult>.create { s in
				s.subscribeUntilEnd { r in
					switch r {
					case .success(let bfr): completionHandler(bfr)
					case .failure: completionHandler(UIBackgroundFetchResult.failed)
					}
				}
			}
			didReceiveRemoteNotification!.send(value: Callback(userInfo, input))
		}
		
		var handleLocalNotificationAction: Any?
		@available(iOS, introduced: 4.0, deprecated: 10.0, message: "Use UserNotifications Framework's UNNotificationSettings")
		func application(_ application: UIApplication, handleActionWithIdentifier identifier: String?, for localNotification: UILocalNotification, completionHandler: @escaping () -> Void) {
			let (input, _) = Signal<Void>.create { s in s.subscribeWhile { r in completionHandler(); return false } }
			(handleLocalNotificationAction as! SignalInput<Callback<(String?, UILocalNotification), ()>>).send(value: Callback((identifier, localNotification), input))
		}
		
		var handleRemoteNotificationAction: SignalInput<Callback<(String?, [AnyHashable: Any]), ()>>?
		func application(_ application: UIApplication, handleActionWithIdentifier identifier: String?, forRemoteNotification userInfo: [AnyHashable: Any], completionHandler: @escaping () -> Void) {
			let (input, _) = Signal<Void>.create { s in s.subscribeWhile { r in completionHandler(); return false } }
			handleRemoteNotificationAction!.send(value: Callback((identifier, userInfo), input))
		}
		
		var handleLocalNotificationResponseInfoAction: Any?
		@available(iOS, introduced: 4.0, deprecated: 10.0, message: "Use UserNotifications Framework's UNNotificationSettings")
		func application(_ application: UIApplication, handleActionWithIdentifier identifier: String?, for localNotification: UILocalNotification, withResponseInfo responseInfo: [AnyHashable : Any], completionHandler: @escaping () -> Void) {
			let (input, _) = Signal<Void>.create { s in s.subscribeWhile { r in completionHandler(); return false } }
			(handleLocalNotificationResponseInfoAction as! SignalInput<Callback<(String?, UILocalNotification, [AnyHashable : Any]), ()>>).send(value: Callback((identifier, localNotification, responseInfo), input))
		}
		
		var handleRemoteNotificationResponseInfoAction: SignalInput<Callback<(String?, [AnyHashable: Any], [AnyHashable : Any]), ()>>?
		func application(_ application: UIApplication, handleActionWithIdentifier identifier: String?, forRemoteNotification userInfo: [AnyHashable: Any], withResponseInfo responseInfo: [AnyHashable : Any], completionHandler: @escaping () -> Void) {
			let (input, _) = Signal<Void>.create { s in s.subscribeWhile { r in completionHandler(); return false } }
			handleRemoteNotificationResponseInfoAction!.send(value: Callback((identifier, userInfo, responseInfo), input))
		}
		
		var didFailToContinueUserActivity: SignalInput<(String, Error)>?
		func application(_ application: UIApplication, didFailToContinueUserActivityWithType userActivityType: String, error: Error) {
			didFailToContinueUserActivity!.send(value: (userActivityType, error))
		}
		
		var handleWatchKitExtensionRequest: SignalInput<Callback<[AnyHashable: Any]?, [AnyHashable: Any]?>>?
		func application(_ application: UIApplication, handleWatchKitExtensionRequest userInfo: [AnyHashable : Any]?, reply: @escaping ([AnyHashable : Any]?) -> Void) {
			let (input, _) = Signal<[AnyHashable: Any]?>.create { s in s.subscribeWhile { r in reply(r.value ?? nil); return false } }
			handleWatchKitExtensionRequest!.send(value: Callback(userInfo, input))
		}
		
		var shouldRequestHealthAuthorization: (() -> Void)?
		func applicationShouldRequestHealthAuthorization(_ application: UIApplication) {
			shouldRequestHealthAuthorization!()
		}
		
		var willContinueUserActivity: ((String) -> Bool)?
		func application(_ application: UIApplication, willContinueUserActivityWithType userActivityType: String) -> Bool {
			return willContinueUserActivity!(userActivityType)
		}
		
		var continueUserActivity: ((Callback<NSUserActivity, [UIUserActivityRestoring]?>) -> Bool)?
		func application(_ application: UIApplication, continue userActivity: NSUserActivity, restorationHandler: @escaping ([UIUserActivityRestoring]?) -> Void) -> Bool {
			let (input, _) = Signal<[UIUserActivityRestoring]?>.create { s in s.subscribeWhile { r in restorationHandler(r.value ?? nil); return false } }
			return continueUserActivity!(Callback(userActivity, input))
		}
		
		var didUpdate: ((NSUserActivity) -> Void)?
		func application(_ application: UIApplication, didUpdate userActivity: NSUserActivity) {
			didUpdate!(userActivity)
		}
		
		var shouldSaveApplicationState: ((NSCoder) -> Bool)?
		func application(_ application: UIApplication, shouldSaveApplicationState coder: NSCoder) -> Bool {
			return shouldSaveApplicationState!(coder)
		}
		
		var shouldRestoreApplicationState: ((NSCoder) -> Bool)?
		func application(_ application: UIApplication, shouldRestoreApplicationState coder: NSCoder) -> Bool {
			return shouldRestoreApplicationState!(coder)
		}
		
		var viewControllerWithRestorationPath: (([String], NSCoder) -> UIViewController?)?
		func application(_ application: UIApplication, viewControllerWithRestorationIdentifierPath identifierComponents: [String], coder: NSCoder) -> UIViewController? {
			return viewControllerWithRestorationPath!(identifierComponents, coder)
		}
		
		var open: ((URL, [UIApplication.OpenURLOptionsKey: Any]) -> Bool)?
		func application(_ app: UIApplication, open url: URL, options: [UIApplication.OpenURLOptionsKey : Any] = [:]) -> Bool {
			return open!(url, options)
		}
		
		var shouldAllowExtensionPointIdentifier: ((UIApplication.ExtensionPointIdentifier) -> Bool)?
		func application(_ application: UIApplication, shouldAllowExtensionPointIdentifier extensionPointIdentifier: UIApplication.ExtensionPointIdentifier) -> Bool {
			return shouldAllowExtensionPointIdentifier!(extensionPointIdentifier)
		}
		
		var performAction: SignalInput<Callback<UIApplicationShortcutItem, Bool>>?
		func application(_ application: UIApplication, performActionFor shortcutItem: UIApplicationShortcutItem, completionHandler: @escaping (Bool) -> Void) {
			let (input, _) = Signal<Bool>.create { s in s.subscribeWhile { r in completionHandler(r.value ?? false); return false } }
			performAction!.send(value: Callback(shortcutItem, input))
		}
	}
}

extension BindingName where Binding: ApplicationBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .applicationBinding(Application.Binding.$1(v)) }) }
	static var ignoreInteractionEvents: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .applicationBinding(Application.Binding.ignoreInteractionEvents(v)) }) }
	static var supportShakeToEdit: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .applicationBinding(Application.Binding.supportShakeToEdit(v)) }) }
	static var isIdleTimerDisabled: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .applicationBinding(Application.Binding.isIdleTimerDisabled(v)) }) }
	static var shortcutItems: BindingName<Dynamic<[UIApplicationShortcutItem]?>, Binding> { return BindingName<Dynamic<[UIApplicationShortcutItem]?>, Binding>({ v in .applicationBinding(Application.Binding.shortcutItems(v)) }) }
	static var isNetworkActivityIndicatorVisible: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .applicationBinding(Application.Binding.isNetworkActivityIndicatorVisible(v)) }) }
	static var applicationIconBadgeNumber: BindingName<Dynamic<Int>, Binding> { return BindingName<Dynamic<Int>, Binding>({ v in .applicationBinding(Application.Binding.applicationIconBadgeNumber(v)) }) }
	static var window: BindingName<Dynamic<WindowConvertible?>, Binding> { return BindingName<Dynamic<WindowConvertible?>, Binding>({ v in .applicationBinding(Application.Binding.window(v)) }) }
	static var additionalWindows: BindingName<Dynamic<[WindowConvertible]>, Binding> { return BindingName<Dynamic<[WindowConvertible]>, Binding>({ v in .applicationBinding(Application.Binding.additionalWindows(v)) }) }
	static var didBecomeActive: BindingName<SignalInput<Void>, Binding> { return BindingName<SignalInput<Void>, Binding>({ v in .applicationBinding(Application.Binding.didBecomeActive(v)) }) }
	static var willResignActive: BindingName<SignalInput<Void>, Binding> { return BindingName<SignalInput<Void>, Binding>({ v in .applicationBinding(Application.Binding.willResignActive(v)) }) }
	static var didEnterBackground: BindingName<SignalInput<Void>, Binding> { return BindingName<SignalInput<Void>, Binding>({ v in .applicationBinding(Application.Binding.didEnterBackground(v)) }) }
	static var willEnterForeground: BindingName<SignalInput<Void>, Binding> { return BindingName<SignalInput<Void>, Binding>({ v in .applicationBinding(Application.Binding.willEnterForeground(v)) }) }
	static var protectedDataWillBecomeUnavailable: BindingName<SignalInput<Void>, Binding> { return BindingName<SignalInput<Void>, Binding>({ v in .applicationBinding(Application.Binding.protectedDataWillBecomeUnavailable(v)) }) }
	static var protectedDataDidBecomeAvailable: BindingName<SignalInput<Void>, Binding> { return BindingName<SignalInput<Void>, Binding>({ v in .applicationBinding(Application.Binding.protectedDataDidBecomeAvailable(v)) }) }
	static var didReceiveMemoryWarning: BindingName<SignalInput<Void>, Binding> { return BindingName<SignalInput<Void>, Binding>({ v in .applicationBinding(Application.Binding.didReceiveMemoryWarning(v)) }) }
	static var significantTimeChange: BindingName<SignalInput<Void>, Binding> { return BindingName<SignalInput<Void>, Binding>({ v in .applicationBinding(Application.Binding.significantTimeChange(v)) }) }
	static var performFetch: BindingName<SignalInput<SignalInput<UIBackgroundFetchResult>>, Binding> { return BindingName<SignalInput<SignalInput<UIBackgroundFetchResult>>, Binding>({ v in .applicationBinding(Application.Binding.performFetch(v)) }) }
	static var handleEventsForBackgroundURLSession: BindingName<SignalInput<Callback<String, ()>>, Binding> { return BindingName<SignalInput<Callback<String, ()>>, Binding>({ v in .applicationBinding(Application.Binding.handleEventsForBackgroundURLSession(v)) }) }
	@available(iOS, introduced: 8.0, deprecated: 10.0, message: "Use UserNotifications Framework's UNNotificationSettings")
	static var registerUserNotificationSettings: BindingName<Signal<UIUserNotificationSettings>, Binding> { return BindingName<Signal<UIUserNotificationSettings>, Binding>({ v in .applicationBinding(Application.Binding.registerUserNotificationSettings(v)) }) }
	static var registerForRemoteNotifications: BindingName<Signal<Bool>, Binding> { return BindingName<Signal<Bool>, Binding>({ v in .applicationBinding(Application.Binding.registerForRemoteNotifications(v)) }) }
	@available(iOS, introduced: 8.0, deprecated: 10.0, message: "Use UserNotifications Framework's UNNotificationSettings")
	static var didRegisterUserNotifications: BindingName<SignalInput<UIUserNotificationSettings>, Binding> { return BindingName<SignalInput<UIUserNotificationSettings>, Binding>({ v in .applicationBinding(Application.Binding.didRegisterUserNotifications(v)) }) }
	static var didRegisterRemoteNotifications: BindingName<SignalInput<Result<Data>>, Binding> { return BindingName<SignalInput<Result<Data>>, Binding>({ v in .applicationBinding(Application.Binding.didRegisterRemoteNotifications(v)) }) }
	@available(iOS, introduced: 8.0, deprecated: 10.0, message: "Use UserNotifications Framework's UNNotificationSettings")
	static var didReceiveLocalNotification: BindingName<SignalInput<UILocalNotification>, Binding> { return BindingName<SignalInput<UILocalNotification>, Binding>({ v in .applicationBinding(Application.Binding.didReceiveLocalNotification(v)) }) }
	static var didReceiveRemoteNotification: BindingName<SignalInput<Callback<[AnyHashable: Any], UIBackgroundFetchResult>>, Binding> { return BindingName<SignalInput<Callback<[AnyHashable: Any], UIBackgroundFetchResult>>, Binding>({ v in .applicationBinding(Application.Binding.didReceiveRemoteNotification(v)) }) }
	@available(iOS, introduced: 8.0, deprecated: 10.0, message: "Use UserNotifications Framework's UNNotificationSettings")
	static var handleLocalNotificationAction: BindingName<SignalInput<Callback<(String?, UILocalNotification), ()>>, Binding> { return BindingName<SignalInput<Callback<(String?, UILocalNotification), ()>>, Binding>({ v in .applicationBinding(Application.Binding.handleLocalNotificationAction(v)) }) }
	@available(iOS, introduced: 8.0, deprecated: 10.0, message: "Use UserNotifications Framework's UNNotificationSettings")
	static var handleRemoteNotificationAction: BindingName<SignalInput<Callback<(String?, [AnyHashable : Any]), ()>>, Binding> { return BindingName<SignalInput<Callback<(String?, [AnyHashable : Any]), ()>>, Binding>({ v in .applicationBinding(Application.Binding.handleRemoteNotificationAction(v)) }) }
	@available(iOS, introduced: 9.0, deprecated: 10.0, message: "Use UserNotifications Framework's UNNotificationSettings")
	static var handleLocalNotificationResponseInfoAction: BindingName<SignalInput<Callback<(String?, UILocalNotification, [AnyHashable : Any]), ()>>, Binding> { return BindingName<SignalInput<Callback<(String?, UILocalNotification, [AnyHashable : Any]), ()>>, Binding>({ v in .applicationBinding(Application.Binding.handleLocalNotificationResponseInfoAction(v)) }) }
	@available(iOS, introduced: 9.0, deprecated: 10.0, message: "Use UserNotifications Framework's UNNotificationSettings")
	static var handleRemoteNotificationResponseInfoAction: BindingName<SignalInput<Callback<(String?, [AnyHashable : Any], [AnyHashable : Any]), ()>>, Binding> { return BindingName<SignalInput<Callback<(String?, [AnyHashable : Any], [AnyHashable : Any]), ()>>, Binding>({ v in .applicationBinding(Application.Binding.handleRemoteNotificationResponseInfoAction(v)) }) }
	static var didFailToContinueUserActivity: BindingName<SignalInput<(String, Error)>, Binding> { return BindingName<SignalInput<(String, Error)>, Binding>({ v in .applicationBinding(Application.Binding.didFailToContinueUserActivity(v)) }) }
	static var performAction: BindingName<SignalInput<Callback<UIApplicationShortcutItem, Bool>>, Binding> { return BindingName<SignalInput<Callback<UIApplicationShortcutItem, Bool>>, Binding>({ v in .applicationBinding(Application.Binding.performAction(v)) }) }
	static var handleWatchKitExtensionRequest: BindingName<SignalInput<Callback<([AnyHashable: Any]?), [AnyHashable: Any]?>>, Binding> { return BindingName<SignalInput<Callback<([AnyHashable: Any]?), [AnyHashable: Any]?>>, Binding>({ v in .applicationBinding(Application.Binding.handleWatchKitExtensionRequest(v)) }) }
	static var willContinueUserActivity: BindingName<(String) -> Bool, Binding> { return BindingName<(String) -> Bool, Binding>({ v in .applicationBinding(Application.Binding.willContinueUserActivity(v)) }) }
	static var continueUserActivity: BindingName<(Callback<NSUserActivity, [UIUserActivityRestoring]?>) -> Bool, Binding> { return BindingName<(Callback<NSUserActivity, [UIUserActivityRestoring]?>) -> Bool, Binding>({ v in .applicationBinding(Application.Binding.continueUserActivity(v)) }) }
	static var didUpdate: BindingName<(NSUserActivity) -> Void, Binding> { return BindingName<(NSUserActivity) -> Void, Binding>({ v in .applicationBinding(Application.Binding.didUpdate(v)) }) }
	static var willFinishLaunching: BindingName<([UIApplication.LaunchOptionsKey: Any]?) -> Bool, Binding> { return BindingName<([UIApplication.LaunchOptionsKey: Any]?) -> Bool, Binding>({ v in .applicationBinding(Application.Binding.willFinishLaunching(v)) }) }
	static var didFinishLaunching: BindingName<([UIApplication.LaunchOptionsKey: Any]?) -> Bool, Binding> { return BindingName<([UIApplication.LaunchOptionsKey: Any]?) -> Bool, Binding>({ v in .applicationBinding(Application.Binding.didFinishLaunching(v)) }) }
	static var willEncodeRestorableState: BindingName<(NSKeyedArchiver) -> Void, Binding> { return BindingName<(NSKeyedArchiver) -> Void, Binding>({ v in .applicationBinding(Application.Binding.willEncodeRestorableState(v)) }) }
	static var didDecodeRestorableState: BindingName<(NSKeyedUnarchiver) -> Void, Binding> { return BindingName<(NSKeyedUnarchiver) -> Void, Binding>({ v in .applicationBinding(Application.Binding.didDecodeRestorableState(v)) }) }
	static var willTerminate: BindingName<() -> Void, Binding> { return BindingName<() -> Void, Binding>({ v in .applicationBinding(Application.Binding.willTerminate(v)) }) }
	static var shouldSaveApplicationState: BindingName<(_ coder: NSCoder) -> Bool, Binding> { return BindingName<(_ coder: NSCoder) -> Bool, Binding>({ v in .applicationBinding(Application.Binding.shouldSaveApplicationState(v)) }) }
	static var shouldRestoreApplicationState: BindingName<(_ coder: NSCoder) -> Bool, Binding> { return BindingName<(_ coder: NSCoder) -> Bool, Binding>({ v in .applicationBinding(Application.Binding.shouldRestoreApplicationState(v)) }) }
	static var viewControllerWithRestorationPath: BindingName<(_ path: [String], _ coder: NSCoder) -> UIViewController, Binding> { return BindingName<(_ path: [String], _ coder: NSCoder) -> UIViewController, Binding>({ v in .applicationBinding(Application.Binding.viewControllerWithRestorationPath(v)) }) }
	static var open: BindingName<(_ url: URL, _ options: [UIApplication.OpenURLOptionsKey: Any]) -> Bool, Binding> { return BindingName<(_ url: URL, _ options: [UIApplication.OpenURLOptionsKey: Any]) -> Bool, Binding>({ v in .applicationBinding(Application.Binding.open(v)) }) }
	static var shouldAllowExtensionPointIdentifier: BindingName<(UIApplication.ExtensionPointIdentifier) -> Bool, Binding> { return BindingName<(UIApplication.ExtensionPointIdentifier) -> Bool, Binding>({ v in .applicationBinding(Application.Binding.shouldAllowExtensionPointIdentifier(v)) }) }
	static var shouldRequestHealthAuthorization: BindingName<() -> Void, Binding> { return BindingName<() -> Void, Binding>({ v in .applicationBinding(Application.Binding.shouldRequestHealthAuthorization(v)) }) }
}

protocol ApplicationBinding: BaseBinding {
	static func applicationBinding(_ binding: Application.Binding) -> Self
}
extension ApplicationBinding {
	static func baseBinding(_ binding: BaseBinder.Binding) -> Self {
		return applicationBinding(.inheritedBinding(binding))
	}
}

#if os(macOS)
	import AppKit
#else
	import UIKit
#endif

class TabBarController<ItemIdentifier: Hashable>: ConstructingBinder, TabBarControllerConvertible {
	typealias Instance = UITabBarController
	typealias Inherited = ViewController
	
	var state: ConstructingBinderState<Instance, Binding>
	required init(state: ConstructingBinderState<Instance, Binding>) {
		self.state = state
	}
	static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	func uiTabBarController() -> Instance { return instance() }
	
	enum Binding: TabBarControllerBinding {
		typealias ItemIdentifierType = ItemIdentifier
		typealias EnclosingBinder = TabBarController
		static func tabBarControllerBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case tabBar(Constant<TabBar<ItemIdentifier>>)

		// 1. Value bindings may be applied at construction and may subsequently change.
		case items(Dynamic<SetOrAnimate<[ItemIdentifier]>>)
		case customizableItems(Dynamic<Set<ItemIdentifier>>)

		// 2. Signal bindings are performed on the object after construction.
		case selectItem(Signal<ItemIdentifier>)

		// 3. Action bindings are triggered by the object after construction.
		case didSelect(SignalInput<ItemIdentifier>)
		case willBeginCustomizing(SignalInput<[ItemIdentifier]>)
		case willEndCustomizing(SignalInput<([ItemIdentifier], Bool)>)
		case didEndCustomizing(SignalInput<([ItemIdentifier], Bool)>)

		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case tabConstructor((ItemIdentifier) -> ViewControllerConvertible)
		case shouldSelect((ItemIdentifier) -> Bool)
		case supportedInterfaceOrientations(() -> UIInterfaceOrientationMask)
		case preferredInterfaceOrientationForPresentation(() -> UIInterfaceOrientation)
		case interactionControllerForAnimation((UIViewControllerAnimatedTransitioning) -> UIViewControllerInteractiveTransitioning?)
		case animationControllerForTransition((UIViewController, UIViewController) -> UIViewControllerAnimatedTransitioning?)
	}

	struct Preparer: ConstructingPreparer {
		typealias EnclosingBinder = TabBarController
		var linkedPreparer = Inherited.Preparer()

		func constructStorage() -> EnclosingBinder.Storage { return Storage() }
		func constructInstance(subclass: EnclosingBinder.Instance.Type) -> EnclosingBinder.Instance { return subclass.init() }

		init() {
			self.init(delegateClass: Delegate.self)
		}
		init<Value>(delegateClass: Value.Type) where Value: Delegate {
			self.delegateClass = delegateClass
		}
		let delegateClass: Delegate.Type
		var possibleDelegate: Delegate? = nil
		mutating func delegate() -> Delegate {
			if let d = possibleDelegate {
				return d
			} else {
				let d = delegateClass.init()
				possibleDelegate = d
				return d
			}
		}
		
		var tabConstructor: ((ItemIdentifier) -> ViewControllerConvertible)?
		
		mutating func prepareBinding(_ binding: Binding) {
			switch binding {
			case .tabConstructor(let x): tabConstructor = x
			case .shouldSelect(let x):
				let s = #selector(UITabBarControllerDelegate.tabBarController(_:shouldSelect:))
				delegate().addSelector(s).shouldSelect = x
			case .supportedInterfaceOrientations(let x):
				let s = #selector(UITabBarControllerDelegate.tabBarControllerSupportedInterfaceOrientations(_:))
				delegate().addSelector(s).supportedInterfaceOrientations = x
			case .preferredInterfaceOrientationForPresentation(let x):
				let s = #selector(UITabBarControllerDelegate.tabBarControllerPreferredInterfaceOrientationForPresentation(_:))
				delegate().addSelector(s).preferredInterfaceOrientationForPresentation = x
			case .interactionControllerForAnimation(let x):
				let s = #selector(UITabBarControllerDelegate.tabBarController(_:interactionControllerFor:))
				delegate().addSelector(s).interactionControllerForAnimation = x
			case .animationControllerForTransition(let x):
				let s = #selector(UITabBarControllerDelegate.tabBarController(_:animationControllerForTransitionFrom:to:))
				delegate().addSelector(s).animationControllerForTransition = x
			case .willBeginCustomizing(let x):
				let s = #selector(UITabBarControllerDelegate.tabBarController(_:willBeginCustomizing:))
				delegate().addSelector(s).willBeginCustomizing = x
			case .willEndCustomizing(let x):
				let s = #selector(UITabBarControllerDelegate.tabBarController(_:willEndCustomizing:changed:))
				delegate().addSelector(s).willEndCustomizing = x
			case .didEndCustomizing(let x):
				let s = #selector(UITabBarControllerDelegate.tabBarController(_:didEndCustomizing:changed:))
				delegate().addSelector(s).didEndCustomizing = x
			case .didSelect(let x):
				let s = #selector(UITabBarControllerDelegate.tabBarController(_:didSelect:))
				delegate().addSelector(s).didSelect = x
			case .inheritedBinding(let x): linkedPreparer.prepareBinding(x)
			default: break
			}
		}
		
		mutating func prepareInstance(_ instance: Instance, storage: Storage) {
			precondition(instance.delegate == nil, "Conflicting delegate applied to instance")

			storage.dynamicDelegate = possibleDelegate
			storage.tabConstructor = tabConstructor

			if storage.inUse {
				instance.delegate = storage
			}
			
			linkedPreparer.prepareInstance(instance, storage: storage)
		}
		
		func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
			switch binding {
			case .tabBar(let x):
				x.value.applyBindings(to: instance.tabBar)
				return nil
			case .items(let x):
				return x.apply(instance, storage) { inst, stor, val in
					let items = val.value.compactMap { stor.viewController(for: $0) }
					inst.setViewControllers(items, animated: val.isAnimated)
				}
			case .customizableItems(let x):
				return x.apply(instance, storage) { inst, stor, val in
					inst.customizableViewControllers = val.compactMap { stor.viewController(for: $0) }
				}
			case .selectItem(let x):
				return x.apply(instance, storage) { inst, stor, val in
					if let vc = stor.viewController(for: val), let index = inst.viewControllers?.index(of: vc) {
						inst.selectedIndex = index
					}
				}
			case .tabConstructor: return nil
			case .didSelect: return nil
			case .willBeginCustomizing: return nil
			case .willEndCustomizing: return nil
			case .didEndCustomizing: return nil
			case .shouldSelect: return nil
			case .supportedInterfaceOrientations: return nil
			case .preferredInterfaceOrientationForPresentation: return nil
			case .interactionControllerForAnimation: return nil
			case .animationControllerForTransition: return nil
			case .inheritedBinding(let b): return linkedPreparer.applyBinding(b, instance: instance, storage: storage)
			}
		}
	}

	class Storage: ViewController.Storage, UITabBarControllerDelegate {
		var tabConstructor: ((ItemIdentifier) -> ViewControllerConvertible)?
		var allItems: [ItemIdentifier: ViewControllerConvertible] = [:]
		
		override var inUse: Bool { return true }
		
		func identifier(for viewController: UIViewController) -> ItemIdentifier? {
			return allItems.first(where: { pair -> Bool in
				pair.value.uiViewController() === viewController
			})?.key
		}
		func viewController(for identifier: ItemIdentifier) -> UIViewController? {
			if let existing = allItems[identifier] {
				return existing.uiViewController()
			}
			if let constructor = tabConstructor {
				let new = constructor(identifier)
				allItems[identifier] = new
				return new.uiViewController()
			}
			return nil
		}
	}
	
	class Delegate: DynamicDelegate, UITabBarControllerDelegate {
		required override init() {
			super.init()
		}

		var didSelect: SignalInput<ItemIdentifier>?
		func tabBarController(_ tabBarController: UITabBarController, didSelect viewController: UIViewController) {
			if let identifier = (tabBarController.delegate as? Storage)?.identifier(for: viewController) {
				didSelect?.send(value: identifier)
			}
		}

		var willBeginCustomizing: SignalInput<[ItemIdentifier]>?
		func tabBarController(_ tabBarController: UITabBarController, willBeginCustomizing viewControllers: [UIViewController]) {
			if let storage = tabBarController.delegate as? Storage {
				willBeginCustomizing?.send(value: viewControllers.compactMap { storage.identifier(for: $0) })
			}
		}

		var didBeginCustomizing: SignalInput<[ItemIdentifier]>?
		func tabBarController(_ tabBarController: UITabBarController, didBeginCustomizing viewControllers: [UIViewController]) {
			if let storage = tabBarController.delegate as? Storage {
				didBeginCustomizing?.send(value: viewControllers.compactMap { storage.identifier(for: $0) })
			}
		}

		var willEndCustomizing: SignalInput<([ItemIdentifier], Bool)>?
		func tabBarController(_ tabBarController: UITabBarController, willEndCustomizing viewControllers: [UIViewController], changed: Bool) {
			if let storage = tabBarController.delegate as? Storage {
				willEndCustomizing?.send(value: (viewControllers.compactMap { storage.identifier(for: $0) }, changed))
			}
		}

		var didEndCustomizing: SignalInput<([ItemIdentifier], Bool)>?
		func tabBarController(_ tabBarController: UITabBarController, didEndCustomizing viewControllers: [UIViewController], changed: Bool) {
			if let storage = tabBarController.delegate as? Storage {
				didEndCustomizing?.send(value: (viewControllers.compactMap { storage.identifier(for: $0) }, changed))
			}
		}
		
		var shouldSelect: ((ItemIdentifier) -> Bool)?
		func tabBarController(_ tabBarController: UITabBarController, shouldSelect viewController: UIViewController) -> Bool {
			if let storage = tabBarController.delegate as? Storage, let identifier = storage.identifier(for: viewController) {
				return shouldSelect!(identifier)
			}
			return false
		}
		
		var supportedInterfaceOrientations: (() -> UIInterfaceOrientationMask)?
		func tabBarControllerSupportedInterfaceOrientations(_ tabBarController: UITabBarController) -> UIInterfaceOrientationMask {
			return supportedInterfaceOrientations!()
		}
		
		var preferredInterfaceOrientationForPresentation: (() -> UIInterfaceOrientation)?
		func tabBarControllerPreferredInterfaceOrientationForPresentation(_ tabBarController: UITabBarController) -> UIInterfaceOrientation {
			return preferredInterfaceOrientationForPresentation!()
		}
		
		var interactionControllerForAnimation: ((UIViewControllerAnimatedTransitioning) -> UIViewControllerInteractiveTransitioning?)?
		func tabBarController(_ tabBarController: UITabBarController, interactionControllerFor animationController: UIViewControllerAnimatedTransitioning) -> UIViewControllerInteractiveTransitioning? {
			return interactionControllerForAnimation!(animationController)
		}
		
		var animationControllerForTransition: ((UIViewController, UIViewController) -> UIViewControllerAnimatedTransitioning?)?
		func tabBarController(_ tabBarController: UITabBarController, animationControllerForTransitionFrom fromVC: UIViewController, to toVC: UIViewController) -> UIViewControllerAnimatedTransitioning? {
			return animationControllerForTransition!(fromVC, toVC)
		}
	}
}

extension BindingName where Binding: TabBarControllerBinding {
	// You can easily convert the `Binding` cases to `BindingName` by copying them to here and using the following Xcode-style regex:
	// Find:    case ([^\(]+)\((.+)\)$
	// Replace: static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .tabBarControllerBinding(TabBarController<Binding.ItemIdentifierType>.Binding.$1(v)) }) }
	static var tabBar: BindingName<Constant<TabBar<Binding.ItemIdentifierType>>, Binding> { return BindingName<Constant<TabBar<Binding.ItemIdentifierType>>, Binding>({ v in .tabBarControllerBinding(TabBarController<Binding.ItemIdentifierType>.Binding.tabBar(v)) }) }
	static var items: BindingName<Dynamic<SetOrAnimate<[Binding.ItemIdentifierType]>>, Binding> { return BindingName<Dynamic<SetOrAnimate<[Binding.ItemIdentifierType]>>, Binding>({ v in .tabBarControllerBinding(TabBarController<Binding.ItemIdentifierType>.Binding.items(v)) }) }
	static var customizableItems: BindingName<Dynamic<Set<Binding.ItemIdentifierType>>, Binding> { return BindingName<Dynamic<Set<Binding.ItemIdentifierType>>, Binding>({ v in .tabBarControllerBinding(TabBarController<Binding.ItemIdentifierType>.Binding.customizableItems(v)) }) }
	static var selectItem: BindingName<Signal<Binding.ItemIdentifierType>, Binding> { return BindingName<Signal<Binding.ItemIdentifierType>, Binding>({ v in .tabBarControllerBinding(TabBarController<Binding.ItemIdentifierType>.Binding.selectItem(v)) }) }
	static var didSelect: BindingName<SignalInput<Binding.ItemIdentifierType>, Binding> { return BindingName<SignalInput<Binding.ItemIdentifierType>, Binding>({ v in .tabBarControllerBinding(TabBarController<Binding.ItemIdentifierType>.Binding.didSelect(v)) }) }
	static var willBeginCustomizing: BindingName<SignalInput<[Binding.ItemIdentifierType]>, Binding> { return BindingName<SignalInput<[Binding.ItemIdentifierType]>, Binding>({ v in .tabBarControllerBinding(TabBarController<Binding.ItemIdentifierType>.Binding.willBeginCustomizing(v)) }) }
	static var willEndCustomizing: BindingName<SignalInput<([Binding.ItemIdentifierType], Bool)>, Binding> { return BindingName<SignalInput<([Binding.ItemIdentifierType], Bool)>, Binding>({ v in .tabBarControllerBinding(TabBarController<Binding.ItemIdentifierType>.Binding.willEndCustomizing(v)) }) }
	static var didEndCustomizing: BindingName<SignalInput<([Binding.ItemIdentifierType], Bool)>, Binding> { return BindingName<SignalInput<([Binding.ItemIdentifierType], Bool)>, Binding>({ v in .tabBarControllerBinding(TabBarController<Binding.ItemIdentifierType>.Binding.didEndCustomizing(v)) }) }
	static var tabConstructor: BindingName<(Binding.ItemIdentifierType) -> ViewControllerConvertible, Binding> { return BindingName<(Binding.ItemIdentifierType) -> ViewControllerConvertible, Binding>({ v in .tabBarControllerBinding(TabBarController<Binding.ItemIdentifierType>.Binding.tabConstructor(v)) }) }
	static var shouldSelect: BindingName<(Binding.ItemIdentifierType) -> Bool, Binding> { return BindingName<(Binding.ItemIdentifierType) -> Bool, Binding>({ v in .tabBarControllerBinding(TabBarController<Binding.ItemIdentifierType>.Binding.shouldSelect(v)) }) }
	static var supportedInterfaceOrientations: BindingName<() -> UIInterfaceOrientationMask, Binding> { return BindingName<() -> UIInterfaceOrientationMask, Binding>({ v in .tabBarControllerBinding(TabBarController<Binding.ItemIdentifierType>.Binding.supportedInterfaceOrientations(v)) }) }
	static var preferredInterfaceOrientationForPresentation: BindingName<() -> UIInterfaceOrientation, Binding> { return BindingName<() -> UIInterfaceOrientation, Binding>({ v in .tabBarControllerBinding(TabBarController<Binding.ItemIdentifierType>.Binding.preferredInterfaceOrientationForPresentation(v)) }) }
	static var interactionControllerForAnimation: BindingName<(UIViewControllerAnimatedTransitioning) -> UIViewControllerInteractiveTransitioning?, Binding> { return BindingName<(UIViewControllerAnimatedTransitioning) -> UIViewControllerInteractiveTransitioning?, Binding>({ v in .tabBarControllerBinding(TabBarController<Binding.ItemIdentifierType>.Binding.interactionControllerForAnimation(v)) }) }
	static var animationControllerForTransition: BindingName<(UIViewController, UIViewController) -> UIViewControllerAnimatedTransitioning?, Binding> { return BindingName<(UIViewController, UIViewController) -> UIViewControllerAnimatedTransitioning?, Binding>({ v in .tabBarControllerBinding(TabBarController<Binding.ItemIdentifierType>.Binding.animationControllerForTransition(v)) }) }
}

protocol TabBarControllerConvertible {
	func uiTabBarController() -> UITabBarController
}
extension TabBarControllerConvertible {
	func uiViewController() -> ViewController.Instance { return uiTabBarController() }
}
extension TabBarController.Instance: TabBarControllerConvertible {
	func uiTabBarController() -> UITabBarController { return self }
}

protocol TabBarControllerBinding: ViewControllerBinding {
	associatedtype ItemIdentifierType: Hashable
	static func tabBarControllerBinding(_ binding: TabBarController<ItemIdentifierType>.Binding) -> Self
}
extension TabBarControllerBinding {
	static func viewControllerBinding(_ binding: ViewController.Binding) -> Self {
		return tabBarControllerBinding(.inheritedBinding(binding))
	}
}

class ImageView: ConstructingBinder, ImageViewConvertible {
	typealias Instance = UIImageView
	typealias Inherited = View
	
	var state: ConstructingBinderState<Instance, Binding>
	required init(state: ConstructingBinderState<Instance, Binding>) {
		self.state = state
	}
	static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	func uiImageView() -> Instance { return instance() }
	
	enum Binding: ImageViewBinding {
		typealias EnclosingBinder = ImageView
		static func imageViewBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case image(Dynamic<UIImage?>)
		case highlightedImage(Dynamic<UIImage?>)
		case animationImages(Dynamic<[UIImage]?>)
		case highlightedAnimationImages(Dynamic<[UIImage]?>)
		case animationDuration(Dynamic<TimeInterval>)
		case animationRepeatCount(Dynamic<Int>)
		case isHighlighted(Dynamic<Bool>)
		
		// 2. Signal bindings are performed on the object after construction.
		case animating(Signal<Bool>)
		
		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
	
	struct Preparer: ConstructingPreparer {
		typealias EnclosingBinder = ImageView
		var linkedPreparer = Inherited.Preparer()
		
		func constructStorage() -> EnclosingBinder.Storage { return Storage() }
		func constructInstance(subclass: EnclosingBinder.Instance.Type) -> EnclosingBinder.Instance {
			return subclass.init(image: initialImage ?? nil, highlightedImage: initialHighlightedImage ?? nil)
		}
		
		var image = InitialSubsequent<UIImage?>()
		var initialImage: UIImage?? = nil
		var highlightedImage = InitialSubsequent<UIImage?>()
		var initialHighlightedImage: UIImage?? = nil
		
		init() {}
		
		mutating func prepareBinding(_ binding: Binding) {
			switch binding {
			case .image(let x):
				image = x.initialSubsequent()
				initialImage = image.initial()
			case .highlightedImage(let x):
				highlightedImage = x.initialSubsequent()
				initialHighlightedImage = highlightedImage.initial()
			case .inheritedBinding(let x): linkedPreparer.prepareBinding(x)
			default: break
			}
		}
		
		func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
			switch binding {
			case .image: return image.subsequent.flatMap { $0.apply(instance, storage) { i, s, v in i.image = v } }
			case .highlightedImage: return highlightedImage.subsequent.flatMap { $0.apply(instance, storage) { i, s, v in i.highlightedImage = v } }
			case .animationImages(let x): return x.apply(instance, storage) { i, s, v in i.animationImages = v }
			case .highlightedAnimationImages(let x): return x.apply(instance, storage) { i, s, v in i.highlightedAnimationImages = v }
			case .animationDuration(let x): return x.apply(instance, storage) { i, s, v in i.animationDuration = v }
			case .animationRepeatCount(let x): return x.apply(instance, storage) { i, s, v in i.animationRepeatCount = v }
			case .isHighlighted(let x): return x.apply(instance, storage) { i, s, v in i.isHighlighted = v }
			case .animating(let x):
				return x.apply(instance, storage) { i, s, v in
					if v && !i.isAnimating {
						i.startAnimating()
					} else if !v && i.isAnimating {
						i.stopAnimating()
					}
				}
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: instance, storage: storage)
			}
		}
	}
	
	typealias Storage = View.Storage
}

extension BindingName where Binding: ImageViewBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .imageViewBinding(ImageView.Binding.$1(v)) }) }
	static var image: BindingName<Dynamic<UIImage?>, Binding> { return BindingName<Dynamic<UIImage?>, Binding>({ v in .imageViewBinding(ImageView.Binding.image(v)) }) }
	static var highlightedImage: BindingName<Dynamic<UIImage?>, Binding> { return BindingName<Dynamic<UIImage?>, Binding>({ v in .imageViewBinding(ImageView.Binding.highlightedImage(v)) }) }
	static var animationImages: BindingName<Dynamic<[UIImage]?>, Binding> { return BindingName<Dynamic<[UIImage]?>, Binding>({ v in .imageViewBinding(ImageView.Binding.animationImages(v)) }) }
	static var highlightedAnimationImages: BindingName<Dynamic<[UIImage]?>, Binding> { return BindingName<Dynamic<[UIImage]?>, Binding>({ v in .imageViewBinding(ImageView.Binding.highlightedAnimationImages(v)) }) }
	static var animationDuration: BindingName<Dynamic<TimeInterval>, Binding> { return BindingName<Dynamic<TimeInterval>, Binding>({ v in .imageViewBinding(ImageView.Binding.animationDuration(v)) }) }
	static var animationRepeatCount: BindingName<Dynamic<Int>, Binding> { return BindingName<Dynamic<Int>, Binding>({ v in .imageViewBinding(ImageView.Binding.animationRepeatCount(v)) }) }
	static var isHighlighted: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .imageViewBinding(ImageView.Binding.isHighlighted(v)) }) }
	static var animating: BindingName<Signal<Bool>, Binding> { return BindingName<Signal<Bool>, Binding>({ v in .imageViewBinding(ImageView.Binding.animating(v)) }) }
}

protocol ImageViewConvertible: ViewConvertible {
	func uiImageView() -> ImageView.Instance
}
extension ImageViewConvertible {
	func uiView() -> View.Instance { return uiImageView() }
}
extension ImageView.Instance: ImageViewConvertible {
	func uiImageView() -> ImageView.Instance { return self }
}

protocol ImageViewBinding: ViewBinding {
	static func imageViewBinding(_ binding: ImageView.Binding) -> Self
}

extension ImageViewBinding {
	static func viewBinding(_ binding: View.Binding) -> Self {
		return imageViewBinding(.inheritedBinding(binding))
	}
}

class AlertController: ConstructingBinder, AlertControllerConvertible {
	typealias Instance = UIAlertController
	typealias Inherited = ViewController
	
	var state: ConstructingBinderState<Instance, Binding>
	required init(state: ConstructingBinderState<Instance, Binding>) {
		self.state = state
	}
	static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	func uiAlertController() -> Instance { return instance() }
	
	enum Binding: AlertControllerBinding {
		typealias EnclosingBinder = AlertController
		static func alertControllerBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case preferredStyle(Constant<UIAlertController.Style>)
		case textFields(Constant<[TextField]>)
		case actions(Constant<[AlertActionConvertible]>)
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case message(Dynamic<String?>)
		case preferredActionIndex(Dynamic<Int?>)
		
		// 2. Signal bindings are performed on the object after construction.
		
		//	3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
	
	struct Preparer: ConstructingPreparer {
		typealias EnclosingBinder = AlertController
		var linkedPreparer = Inherited.Preparer()
		
		func constructStorage() -> EnclosingBinder.Storage { return Storage() }
		func constructInstance(subclass: EnclosingBinder.Instance.Type) -> EnclosingBinder.Instance {
			return subclass.init(title: initialTitle, message: initialMessage ?? nil, preferredStyle: preferredStyle)
		}
		
		var title = InitialSubsequent<String>()
		var initialTitle: String? = nil
		var message = InitialSubsequent<String?>()
		var initialMessage: String?? = nil
		var preferredStyle: UIAlertController.Style = .alert
		
		init() {}
		
		mutating func prepareBinding(_ binding: Binding) {
			switch binding {
			case .preferredStyle(let x): preferredStyle = x.value
			case .message(let x):
				message = x.initialSubsequent()
				initialMessage = message.initial()
			case .inheritedBinding(.title(let x)):
				title = x.initialSubsequent()
				initialTitle = title.initial()
			case .inheritedBinding(let s): return linkedPreparer.prepareBinding(s)
			default: break
			}
		}
		
		func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
			switch binding {
			case .preferredStyle: return nil
			case .actions(let x):
				for a in x.value {
					instance.addAction(a.uiAlertAction())
				}
				return nil
			case .textFields(let x):
				for bindings in x.value {
					instance.addTextField { textField in
						bindings.applyBindings(to: textField)
					}
				}
				return nil
			case .message(let x): return x.apply(instance, storage) { i, s, v in i.message = v }
			case .preferredActionIndex(let x):
				return x.apply(instance, storage) { i, s, v in
					i.preferredAction = v.map { i.actions[$0] }
				}
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: instance, storage: storage)
			}
		}
	}
	
	typealias Storage = ViewController.Storage
}

extension BindingName where Binding: AlertControllerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .alertControllerBinding(AlertController.Binding.$1(v)) }) }
	static var preferredStyle: BindingName<Constant<UIAlertController.Style>, Binding> { return BindingName<Constant<UIAlertController.Style>, Binding>({ v in .alertControllerBinding(AlertController.Binding.preferredStyle(v)) }) }
	static var textFields: BindingName<Constant<[TextField]>, Binding> { return BindingName<Constant<[TextField]>, Binding>({ v in .alertControllerBinding(AlertController.Binding.textFields(v)) }) }
	static var actions: BindingName<Constant<[AlertActionConvertible]>, Binding> { return BindingName<Constant<[AlertActionConvertible]>, Binding>({ v in .alertControllerBinding(AlertController.Binding.actions(v)) }) }
	static var message: BindingName<Dynamic<String?>, Binding> { return BindingName<Dynamic<String?>, Binding>({ v in .alertControllerBinding(AlertController.Binding.message(v)) }) }
	static var preferredActionIndex: BindingName<Dynamic<Int?>, Binding> { return BindingName<Dynamic<Int?>, Binding>({ v in .alertControllerBinding(AlertController.Binding.preferredActionIndex(v)) }) }
}

protocol AlertControllerConvertible: ViewControllerConvertible {
	func uiAlertController() -> AlertController.Instance
}
extension AlertControllerConvertible {
	func uiViewController() -> ViewController.Instance { return uiAlertController() }
}
extension AlertController.Instance: AlertControllerConvertible {
	func uiAlertController() -> AlertController.Instance { return self }
}

protocol AlertControllerBinding: ViewControllerBinding {
	static func alertControllerBinding(_ binding: AlertController.Binding) -> Self
}
extension AlertControllerBinding {
	static func viewControllerBinding(_ binding: ViewController.Binding) -> Self {
		return alertControllerBinding(.inheritedBinding(binding))
	}
}

#if os(macOS)
	import AppKit
#else
	import UIKit
#endif

class PageViewController<PageData>: ConstructingBinder, PageViewControllerConvertible {
	typealias Instance = UIPageViewController
	typealias Inherited = ViewController
	
	var state: ConstructingBinderState<Instance, Binding>
	required init(state: ConstructingBinderState<Instance, Binding>) {
		self.state = state
	}
	static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	func uiPageViewController() -> Instance { return instance() }
	
	enum Binding: PageViewControllerBinding {
		typealias PageDataType = PageData
		
		typealias EnclosingBinder = PageViewController
		static func pageViewControllerBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		// 0. Static bindings are applied at construction and are subsequently immutable.
		// e.g. case someProperty(Constant<PropertyType>)
		case transitionStyle(Constant<UIPageViewController.TransitionStyle>)
		case navigationOrientation(Constant<UIPageViewController.NavigationOrientation>)
		case spineLocation(Constant<UIPageViewController.SpineLocation>)
		case pageSpacing(Constant<CGFloat>)

		// 1. Value bindings may be applied at construction and may subsequently change.
		case pageData(Dynamic<SetAnimatable<[PageData], UIPageViewController.NavigationDirection>>)
		case isDoubleSided(Dynamic<Bool>)

		// 2. Signal bindings are performed on the object after construction.
		// e.g. case someFunction(Signal<FunctionParametersAsTuple>)

		// 3. Action bindings are triggered by the object after construction.
		// e.g. case someAction(SignalInput<CallbackParameters>)

		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case constructPage((PageData) -> ViewControllerConvertible)
		case willTransitionTo(([UIViewController]) -> Void)
		case didFinishAnimating((Bool, [UIViewController], Bool) -> Void)
		case spineLocationFor((UIInterfaceOrientation) -> UIPageViewController.SpineLocation)
		case supportedInterfaceOrientations(() -> UIInterfaceOrientationMask)
		case interfaceOrientationForPresentation(() -> UIInterfaceOrientation)
	}

	struct Preparer: ConstructingPreparer {
		typealias EnclosingBinder = PageViewController
		var linkedPreparer = Inherited.Preparer()

		func constructStorage() -> EnclosingBinder.Storage { return Storage() }
		func constructInstance(subclass: EnclosingBinder.Instance.Type) -> EnclosingBinder.Instance { return subclass.init() }
		
		init() {
			self.init(delegateClass: Delegate.self)
		}
		init<Value>(delegateClass: Value.Type) where Value: Delegate {
			self.delegateClass = delegateClass
		}
		let delegateClass: Delegate.Type
		var possibleDelegate: Delegate? = nil
		mutating func delegate() -> Delegate {
			if let d = possibleDelegate {
				return d
			} else {
				let d = delegateClass.init()
				possibleDelegate = d
				return d
			}
		}
		
		var transitionStyle = UIPageViewController.TransitionStyle.scroll
		var navigationOrientation = UIPageViewController.NavigationOrientation.horizontal
		var spineLocation = UIPageViewController.SpineLocation.min
		var pageSpacing = CGFloat(0)
		var pageConstructor: ((PageData) -> ViewControllerConvertible)?
		
		mutating func prepareBinding(_ binding: PageViewController<PageData>.Binding) {
			switch binding {
			case .constructPage(let x): pageConstructor = x
			case .transitionStyle(let x): transitionStyle = x.value
			case .navigationOrientation(let x): navigationOrientation = x.value
			case .spineLocation(let x): spineLocation = x.value
			case .pageSpacing(let x): pageSpacing = x.value
			case .inheritedBinding(let x): return linkedPreparer.prepareBinding(x)
			case .willTransitionTo(let x):
				let s = #selector(UIPageViewControllerDelegate.pageViewController(_:willTransitionTo:))
				delegate().addSelector(s).willTransitionTo = x
			case .didFinishAnimating(let x):
				let s = #selector(UIPageViewControllerDelegate.pageViewController(_:didFinishAnimating:previousViewControllers:transitionCompleted:))
				delegate().addSelector(s).didFinishAnimating = x
			case .spineLocationFor(let x):
				let s = #selector(UIPageViewControllerDelegate.pageViewController(_:spineLocationFor:))
				delegate().addSelector(s).spineLocationFor = x
			case .supportedInterfaceOrientations(let x):
				let s = #selector(UIPageViewControllerDelegate.pageViewControllerSupportedInterfaceOrientations(_:))
				delegate().addSelector(s).supportedInterfaceOrientations = x
			case .interfaceOrientationForPresentation(let x):
				let s = #selector(UIPageViewControllerDelegate.pageViewControllerPreferredInterfaceOrientationForPresentation(_:))
				delegate().addSelector(s).interfaceOrientationForPresentation = x
			default: break
			}
		}
		
		func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
			switch binding {
			case .pageData(let x):
				return x.apply(instance, storage) { inst, stor, val in
					stor.changePageData(val.value, in: inst, animation: val.animation)
				}
			case .isDoubleSided(let x): return x.apply(instance, storage) { inst, stor, val in inst.isDoubleSided = val }
			case .constructPage: return nil
			case .transitionStyle: return nil
			case .navigationOrientation: return nil
			case .spineLocation: return nil
			case .pageSpacing: return nil
			case .inheritedBinding(let b): return linkedPreparer.applyBinding(b, instance: instance, storage: storage)
			case .willTransitionTo: return nil
			case .didFinishAnimating: return nil
			case .spineLocationFor: return nil
			case .supportedInterfaceOrientations: return nil
			case .interfaceOrientationForPresentation: return nil
			}
		}
	}

	class Storage: ViewController.Storage, UIPageViewControllerDelegate, UIPageViewControllerDataSource {
		func pageViewController(_ pageViewController: UIPageViewController, viewControllerBefore viewController: UIViewController) -> UIViewController? {
			if let i = index(of: viewController) {
				return self.viewController(at: i - 1)
			}
			return nil
		}
		
		func pageViewController(_ pageViewController: UIPageViewController, viewControllerAfter viewController: UIViewController) -> UIViewController? {
			if let i = index(of: viewController) {
				return self.viewController(at: i + 1)
			}
			return nil
		}
		
		var pageData: [PageData] = []
		var activeViewControllers: [(Int, Weak<UIViewController>)] = []
		var pageConstructor: ((PageData) -> ViewControllerConvertible)?
		
		func changePageData(_ newPageData: [PageData], in pvc: UIPageViewController, animation: UIPageViewController.NavigationDirection?) {
			let indexes = pvc.viewControllers?.compactMap { self.index(of: $0) }.sorted() ?? (newPageData.isEmpty ? [] : [0])
			pageData = newPageData
			activeViewControllers.removeAll()
			let newViewControllers = indexes.compactMap { self.viewController(at: $0) }
			pvc.setViewControllers(newViewControllers, direction: animation ?? .forward, animated: animation != nil, completion: nil)
		}
		
		func viewController(at: Int) -> UIViewController? {
			guard let constructor = pageConstructor, pageData.indices.contains(at) else { return nil }
			var i = 0
			var match: UIViewController? = nil
			while i < activeViewControllers.count {
				let tuple = activeViewControllers[i]
				if let vc = tuple.1.value {
					if tuple.0 == at {
						match = vc
					}
					i += 1
				} else {
					activeViewControllers.remove(at: i)
				}
			}
			if let m = match {
				return m
			}
			let vc = constructor(pageData[at]).uiViewController()
			activeViewControllers.append((at, Weak(vc)))
			return vc
		}
		
		func index(of: UIViewController) -> Int? {
			var i = 0
			var match: Int? = nil
			while i < activeViewControllers.count {
				let tuple = activeViewControllers[i]
				if let vc = tuple.1.value {
					if vc === of {
						match = tuple.0
					}
					i += 1
				} else {
					activeViewControllers.remove(at: i)
				}
			}
			return match
		}
	}

	class Delegate: DynamicDelegate, UIPageViewControllerDelegate {
		required override init() {
			super.init()
		}
		
		var willTransitionTo: (([UIViewController]) -> Void)?
		func pageViewController(_ pageViewController: UIPageViewController, willTransitionTo pendingViewControllers: [UIViewController]) {
			willTransitionTo!(pendingViewControllers)
		}
		
		var didFinishAnimating: ((Bool, [UIViewController], Bool) -> Void)?
		func pageViewController(_ pageViewController: UIPageViewController, didFinishAnimating finished: Bool, previousViewControllers: [UIViewController], transitionCompleted completed: Bool) {
			didFinishAnimating!(finished, previousViewControllers, completed)
		}
		
		var spineLocationFor: ((UIInterfaceOrientation) -> UIPageViewController.SpineLocation)?
		func pageViewController(_ pageViewController: UIPageViewController, spineLocationFor orientation: UIInterfaceOrientation) -> UIPageViewController.SpineLocation {
			return spineLocationFor!(orientation)
		}
		
		var supportedInterfaceOrientations: (() -> UIInterfaceOrientationMask)?
		func pageViewControllerSupportedInterfaceOrientations(_ pageViewController: UIPageViewController) -> UIInterfaceOrientationMask {
			return supportedInterfaceOrientations!()
		}
		
		var interfaceOrientationForPresentation: (() -> UIInterfaceOrientation)?
		func pageViewControllerPreferredInterfaceOrientationForPresentation(_ pageViewController: UIPageViewController) -> UIInterfaceOrientation {
			return interfaceOrientationForPresentation!()
		}
	}
}

extension BindingName where Binding: PageViewControllerBinding {
	// You can easily convert the `Binding` cases to `BindingName` by copying them to here and using the following Xcode-style regex:
	// Find:    case ([^\(]+)\((.+)\)$
	// Replace: static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .pageViewControllerBinding(PageViewController.Binding.$1(v)) }) }
	static var transitionStyle: BindingName<Constant<UIPageViewController.TransitionStyle>, Binding> { return BindingName<Constant<UIPageViewController.TransitionStyle>, Binding>({ v in .pageViewControllerBinding(PageViewController.Binding.transitionStyle(v)) }) }
	static var navigationOrientation: BindingName<Constant<UIPageViewController.NavigationOrientation>, Binding> { return BindingName<Constant<UIPageViewController.NavigationOrientation>, Binding>({ v in .pageViewControllerBinding(PageViewController.Binding.navigationOrientation(v)) }) }
	static var spineLocation: BindingName<Constant<UIPageViewController.SpineLocation>, Binding> { return BindingName<Constant<UIPageViewController.SpineLocation>, Binding>({ v in .pageViewControllerBinding(PageViewController.Binding.spineLocation(v)) }) }
	static var pageSpacing: BindingName<Constant<CGFloat>, Binding> { return BindingName<Constant<CGFloat>, Binding>({ v in .pageViewControllerBinding(PageViewController.Binding.pageSpacing(v)) }) }
	static var pageData: BindingName<Dynamic<SetAnimatable<[Binding.PageDataType], UIPageViewController.NavigationDirection>>, Binding> { return BindingName<Dynamic<SetAnimatable<[Binding.PageDataType], UIPageViewController.NavigationDirection>>, Binding>({ v in .pageViewControllerBinding(PageViewController.Binding.pageData(v)) }) }
	static var isDoubleSided: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .pageViewControllerBinding(PageViewController.Binding.isDoubleSided(v)) }) }
	static var constructPage: BindingName<(Binding.PageDataType) -> ViewControllerConvertible, Binding> { return BindingName<(Binding.PageDataType) -> ViewControllerConvertible, Binding>({ v in .pageViewControllerBinding(PageViewController.Binding.constructPage(v)) }) }
	static var willTransitionTo: BindingName<([UIViewController]) -> Void, Binding> { return BindingName<([UIViewController]) -> Void, Binding>({ v in .pageViewControllerBinding(PageViewController.Binding.willTransitionTo(v)) }) }
	static var didFinishAnimating: BindingName<(Bool, [UIViewController], Bool) -> Void, Binding> { return BindingName<(Bool, [UIViewController], Bool) -> Void, Binding>({ v in .pageViewControllerBinding(PageViewController.Binding.didFinishAnimating(v)) }) }
	static var spineLocationFor: BindingName<(UIInterfaceOrientation) -> UIPageViewController.SpineLocation, Binding> { return BindingName<(UIInterfaceOrientation) -> UIPageViewController.SpineLocation, Binding>({ v in .pageViewControllerBinding(PageViewController.Binding.spineLocationFor(v)) }) }
	static var supportedInterfaceOrientations: BindingName<() -> UIInterfaceOrientationMask, Binding> { return BindingName<() -> UIInterfaceOrientationMask, Binding>({ v in .pageViewControllerBinding(PageViewController.Binding.supportedInterfaceOrientations(v)) }) }
	static var interfaceOrientationForPresentation: BindingName<() -> UIInterfaceOrientation, Binding> { return BindingName<() -> UIInterfaceOrientation, Binding>({ v in .pageViewControllerBinding(PageViewController.Binding.interfaceOrientationForPresentation(v)) }) }
}

protocol PageViewControllerConvertible: ViewControllerConvertible {
	func uiPageViewController() -> UIPageViewController
}
extension PageViewControllerConvertible {
	func uiViewController() -> ViewController.Instance { return uiPageViewController() }
}
extension PageViewController.Instance: PageViewControllerConvertible {
	func uiPageViewController() -> UIPageViewController { return self }
}

protocol PageViewControllerBinding: ViewControllerBinding {
	associatedtype PageDataType
	static func pageViewControllerBinding(_ binding: PageViewController<PageDataType>.Binding) -> Self
}
extension PageViewControllerBinding {
	static func viewControllerBinding(_ binding: ViewController.Binding) -> Self {
		return pageViewControllerBinding(.inheritedBinding(binding))
	}
}

class TableViewCell: Binder, TableViewCellConvertible {
	typealias Instance = UITableViewCell
	typealias Inherited = View
	
	var state: ConstructingBinderState<Instance, Binding>
	required init(state: ConstructingBinderState<Instance, Binding>) {
		self.state = state
	}
	static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	func construct(reuseIdentifier: String?, additional: ((Instance) -> Lifetime?)? = nil) -> UITableViewCell {
		return binderConstruct(
			additional: additional,
			storageConstructor: { prep, params, i in prep.constructStorage() },
			instanceConstructor: { prep, params in prep.constructInstance(reuseIdentifier: reuseIdentifier, subclass: params.subclass) },
			combine: embedStorageIfInUse,
			output: { i, s in i })
	}
	func uiTableViewCell(reuseIdentifier: String?) -> UITableViewCell {
		return construct(reuseIdentifier: reuseIdentifier)
	}
	
	enum Binding: TableViewCellBinding {
		typealias EnclosingBinder = TableViewCell
		static func tableViewCellBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case cellStyle(Constant<UITableViewCell.CellStyle>)
		case textLabel(Constant<Label>)
		case detailLabel(Constant<Label>)
		case imageView(Constant<ImageView>)
		case contentView(Constant<View>)
		
		//	1. Value bindings may be applied at construction and may subsequently change.
		case backgroundView(Dynamic<ViewConvertible?>)
		case selectedBackgroundView(Dynamic<ViewConvertible?>)
		case multipleSelectionBackgroundView(Dynamic<ViewConvertible?>)
		case accessoryType(Dynamic<UITableViewCell.AccessoryType>)
		case accessoryView(Dynamic<ViewConvertible>)
		case editingAccessoryType(Dynamic<UITableViewCell.AccessoryType>)
		case editingAccessoryView(Dynamic<ViewConvertible>)
		case isSelected(Dynamic<SetOrAnimate<Bool>>)
		case isHighlighted(Dynamic<SetOrAnimate<Bool>>)
		case isEditing(Dynamic<SetOrAnimate<Bool>>)
		case showsReorderControl(Dynamic<Bool>)
		case indentationLevel(Dynamic<Int>)
		case indentationWidth(Dynamic<CGFloat>)
		case shouldIndentWhileEditing(Dynamic<Bool>)
		case separatorInset(Dynamic<UIEdgeInsets>)
		case focusStyle(Dynamic<UITableViewCell.FocusStyle>)
		
		//	2. Signal bindings are performed on the object after construction.
		
		//	3. Action bindings are triggered by the object after construction.
		
		//	4. Delegate bindings require synchronous evaluation within the object's context.
	}
	
	struct Preparer: ConstructingPreparer {
		typealias EnclosingBinder = TableViewCell
		var linkedPreparer = Inherited.Preparer()
		
		func constructStorage() -> EnclosingBinder.Storage { return Storage() }
		func constructInstance(subclass: EnclosingBinder.Instance.Type) -> EnclosingBinder.Instance { return subclass.init(style: cellStyle, reuseIdentifier: nil) }
		func constructInstance(reuseIdentifier: String?, subclass: EnclosingBinder.Instance.Type) -> EnclosingBinder.Instance { return subclass.init(style: cellStyle, reuseIdentifier: reuseIdentifier) }
		
		init() {}
		
		var cellStyle: UITableViewCell.CellStyle = .default
		
		mutating func prepareBinding(_ binding: Binding) {
			switch binding {
			case .cellStyle(let x): cellStyle = x.value
			case .inheritedBinding(let x): linkedPreparer.prepareBinding(x)
			default: break
			}
		}
		
		func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
			switch binding {
			case .cellStyle: return nil
			case .textLabel(let x):
				if let l = instance.textLabel {
					x.value.applyBindings(to: l)
				}
				return nil
			case .detailLabel(let x):
				if let l = instance.detailTextLabel {
					x.value.applyBindings(to: l)
				}
				return nil
			case .imageView(let x):
				if let l = instance.imageView {
					x.value.applyBindings(to: l)
				}
				return nil
			case .contentView(let x):
				x.value.applyBindings(to: instance.contentView)
				return nil
			case .backgroundView(let x): return x.apply(instance, storage) { i, s, v in i.backgroundView = v?.uiView() }
			case .selectedBackgroundView(let x): return x.apply(instance, storage) { i, s, v in i.selectedBackgroundView = v?.uiView() }
			case .multipleSelectionBackgroundView(let x): return x.apply(instance, storage) { i, s, v in i.multipleSelectionBackgroundView = v?.uiView() }
			case .accessoryType(let x): return x.apply(instance, storage) { i, s, v in i.accessoryType = v }
			case .accessoryView(let x): return x.apply(instance, storage) { i, s, v in i.accessoryView = v.uiView() }
			case .editingAccessoryType(let x): return x.apply(instance, storage) { i, s, v in i.editingAccessoryType = v }
			case .editingAccessoryView(let x): return x.apply(instance, storage) { i, s, v in i.editingAccessoryView = v.uiView() }
			case .isSelected(let x): return x.apply(instance, storage) { i, s, v in i.setSelected(v.value, animated: v.isAnimated) }
			case .isHighlighted(let x): return x.apply(instance, storage) { i, s, v in i.setHighlighted(v.value, animated: v.isAnimated) }
			case .isEditing(let x): return x.apply(instance, storage) { i, s, v in i.setEditing(v.value, animated: v.isAnimated) }
			case .showsReorderControl(let x): return x.apply(instance, storage) { i, s, v in i.showsReorderControl = v }
			case .indentationLevel(let x): return x.apply(instance, storage) { i, s, v in i.indentationLevel = v }
			case .indentationWidth(let x): return x.apply(instance, storage) { i, s, v in i.indentationWidth = v }
			case .shouldIndentWhileEditing(let x): return x.apply(instance, storage) { i, s, v in i.shouldIndentWhileEditing = v }
			case .separatorInset(let x): return x.apply(instance, storage) { i, s, v in i.separatorInset = v }
			case .focusStyle(let x): return x.apply(instance, storage) { i, s, v in i.focusStyle = v }
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: instance, storage: storage)
			}
		}
	}
	
	typealias Storage = View.Storage
}

extension BindingName where Binding: TableViewCellBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .tableViewCellBinding(TableViewCell.Binding.$1(v)) }) }
	static var cellStyle: BindingName<Constant<UITableViewCell.CellStyle>, Binding> { return BindingName<Constant<UITableViewCell.CellStyle>, Binding>({ v in .tableViewCellBinding(TableViewCell.Binding.cellStyle(v)) }) }
	static var textLabel: BindingName<Constant<Label>, Binding> { return BindingName<Constant<Label>, Binding>({ v in .tableViewCellBinding(TableViewCell.Binding.textLabel(v)) }) }
	static var detailLabel: BindingName<Constant<Label>, Binding> { return BindingName<Constant<Label>, Binding>({ v in .tableViewCellBinding(TableViewCell.Binding.detailLabel(v)) }) }
	static var imageView: BindingName<Constant<ImageView>, Binding> { return BindingName<Constant<ImageView>, Binding>({ v in .tableViewCellBinding(TableViewCell.Binding.imageView(v)) }) }
	static var contentView: BindingName<Constant<View>, Binding> { return BindingName<Constant<View>, Binding>({ v in .tableViewCellBinding(TableViewCell.Binding.contentView(v)) }) }
	static var backgroundView: BindingName<Dynamic<ViewConvertible?>, Binding> { return BindingName<Dynamic<ViewConvertible?>, Binding>({ v in .tableViewCellBinding(TableViewCell.Binding.backgroundView(v)) }) }
	static var selectedBackgroundView: BindingName<Dynamic<ViewConvertible?>, Binding> { return BindingName<Dynamic<ViewConvertible?>, Binding>({ v in .tableViewCellBinding(TableViewCell.Binding.selectedBackgroundView(v)) }) }
	static var multipleSelectionBackgroundView: BindingName<Dynamic<ViewConvertible?>, Binding> { return BindingName<Dynamic<ViewConvertible?>, Binding>({ v in .tableViewCellBinding(TableViewCell.Binding.multipleSelectionBackgroundView(v)) }) }
	static var accessoryType: BindingName<Dynamic<UITableViewCell.AccessoryType>, Binding> { return BindingName<Dynamic<UITableViewCell.AccessoryType>, Binding>({ v in .tableViewCellBinding(TableViewCell.Binding.accessoryType(v)) }) }
	static var accessoryView: BindingName<Dynamic<ViewConvertible>, Binding> { return BindingName<Dynamic<ViewConvertible>, Binding>({ v in .tableViewCellBinding(TableViewCell.Binding.accessoryView(v)) }) }
	static var editingAccessoryType: BindingName<Dynamic<UITableViewCell.AccessoryType>, Binding> { return BindingName<Dynamic<UITableViewCell.AccessoryType>, Binding>({ v in .tableViewCellBinding(TableViewCell.Binding.editingAccessoryType(v)) }) }
	static var editingAccessoryView: BindingName<Dynamic<ViewConvertible>, Binding> { return BindingName<Dynamic<ViewConvertible>, Binding>({ v in .tableViewCellBinding(TableViewCell.Binding.editingAccessoryView(v)) }) }
	static var isSelected: BindingName<Dynamic<SetOrAnimate<Bool>>, Binding> { return BindingName<Dynamic<SetOrAnimate<Bool>>, Binding>({ v in .tableViewCellBinding(TableViewCell.Binding.isSelected(v)) }) }
	static var isHighlighted: BindingName<Dynamic<SetOrAnimate<Bool>>, Binding> { return BindingName<Dynamic<SetOrAnimate<Bool>>, Binding>({ v in .tableViewCellBinding(TableViewCell.Binding.isHighlighted(v)) }) }
	static var isEditing: BindingName<Dynamic<SetOrAnimate<Bool>>, Binding> { return BindingName<Dynamic<SetOrAnimate<Bool>>, Binding>({ v in .tableViewCellBinding(TableViewCell.Binding.isEditing(v)) }) }
	static var showsReorderControl: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .tableViewCellBinding(TableViewCell.Binding.showsReorderControl(v)) }) }
	static var indentationLevel: BindingName<Dynamic<Int>, Binding> { return BindingName<Dynamic<Int>, Binding>({ v in .tableViewCellBinding(TableViewCell.Binding.indentationLevel(v)) }) }
	static var indentationWidth: BindingName<Dynamic<CGFloat>, Binding> { return BindingName<Dynamic<CGFloat>, Binding>({ v in .tableViewCellBinding(TableViewCell.Binding.indentationWidth(v)) }) }
	static var shouldIndentWhileEditing: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .tableViewCellBinding(TableViewCell.Binding.shouldIndentWhileEditing(v)) }) }
	static var separatorInset: BindingName<Dynamic<UIEdgeInsets>, Binding> { return BindingName<Dynamic<UIEdgeInsets>, Binding>({ v in .tableViewCellBinding(TableViewCell.Binding.separatorInset(v)) }) }
	static var focusStyle: BindingName<Dynamic<UITableViewCell.FocusStyle>, Binding> { return BindingName<Dynamic<UITableViewCell.FocusStyle>, Binding>({ v in .tableViewCellBinding(TableViewCell.Binding.focusStyle(v)) }) }
}

protocol TableViewCellConvertible: ViewConvertible {
	func uiTableViewCell(reuseIdentifier: String?) -> UITableViewCell
}
extension TableViewCellConvertible {
	func uiView() -> UIView { return uiTableViewCell(reuseIdentifier: nil) }
}
extension UITableViewCell: TableViewCellConvertible {
	func uiTableViewCell(reuseIdentifier: String?) -> UITableViewCell {
		return self
	}
}

protocol TableViewCellBinding: ViewBinding {
	static func tableViewCellBinding(_ binding: TableViewCell.Binding) -> Self
}
extension TableViewCellBinding {
	static func viewBinding(_ binding: View.Binding) -> Self {
		return tableViewCellBinding(.inheritedBinding(binding))
	}
}

class TabBarItem: ConstructingBinder, TabBarItemConvertible {
	typealias Instance = UITabBarItem
	typealias Inherited = BarItem
	
	var state: ConstructingBinderState<Instance, Binding>
	required init(state: ConstructingBinderState<Instance, Binding>) {
		self.state = state
	}
	static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	func uiTabBarItem() -> Instance { return instance() }
	
	enum Binding: TabBarItemBinding {
		typealias EnclosingBinder = TabBarItem
		static func tabBarItemBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case systemItem(Constant<UITabBarItem.SystemItem?>)

		//	1. Value bindings may be applied at construction and may subsequently change.
		case selectedImage(Dynamic<UIImage?>)
		case titlePositionAdjustment(Dynamic<UIOffset>)
		case badgeValue(Dynamic<String?>)
		@available(iOS 10.0, *)
		case badgeColor(Dynamic<UIColor?>)
		@available(iOS 10.0, *)
		case badgeTextAttributes(Dynamic<ScopedValues<UIControl.State, [NSAttributedString.Key : Any]?>>)
		
		//	2. Signal bindings are performed on the object after construction.
		
		//	3. Action bindings are triggered by the object after construction.
		
		//	4. Delegate bindings require synchronous evaluation within the object's context.
	}
	
	struct Preparer: ConstructingPreparer {
		typealias EnclosingBinder = TabBarItem
		var linkedPreparer = Inherited.Preparer()
		
		func constructStorage() -> EnclosingBinder.Storage { return Storage() }
		func constructInstance(subclass: EnclosingBinder.Instance.Type) -> EnclosingBinder.Instance {
			let x: UITabBarItem
			if let si = systemItem {
				x = subclass.init(tabBarSystemItem: si, tag: tagInitial ?? 0)
			} else if let si = selectedImageInitial {
				x = subclass.init(title: titleInitial ?? nil, image: imageInitial ?? nil, selectedImage: si)
			} else {
				x = subclass.init(title: titleInitial ?? nil, image: imageInitial ?? nil, tag: tagInitial ?? 0)
			}
			return x
		}
		
		var systemItem: UITabBarItem.SystemItem?
		var title = InitialSubsequent<String>()
		var titleInitial: String? = nil
		var image = InitialSubsequent<UIImage?>()
		var imageInitial: UIImage?? = nil
		var selectedImage = InitialSubsequent<UIImage?>()
		var selectedImageInitial: UIImage?? = nil
		var tag = InitialSubsequent<Int>()
		var tagInitial: Int? = nil
		
		init() {}
		
		mutating func prepareBinding(_ binding: Binding) {
			switch binding {
			case .systemItem(let x): systemItem = x.value
			case .selectedImage(let x):
				selectedImage = x.initialSubsequent()
				selectedImageInitial = selectedImage.initial()
			case .inheritedBinding(.tag(let x)):
				tag = x.initialSubsequent()
				tagInitial = tag.initial()
			case .inheritedBinding(.image(let x)):
				image = x.initialSubsequent()
				imageInitial = image.initial()
			case .inheritedBinding(.title(let x)):
				title = x.initialSubsequent()
				titleInitial = title.initial()
			case .inheritedBinding(let x): linkedPreparer.prepareBinding(x)
			default: break
			}
		}
		
		func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
			switch binding {
			case .badgeTextAttributes(let x):
				if #available(iOS 10.0, *) {
					var previous: ScopedValues<UIControl.State, [NSAttributedString.Key : Any]?>? = nil
					return x.apply(instance, storage) { i, s, v in
						if let p = previous {
							for c in p.pairs {
								i.setBadgeTextAttributes(nil, for: c.0)
							}
						}
						previous = v
						for c in v.pairs {
							i.setBadgeTextAttributes(c.1, for: c.0)
						}
					}
				} else {
					return nil
				}
			case .titlePositionAdjustment(let x): return x.apply(instance, storage) { i, s, v in i.titlePositionAdjustment = v }
			case .badgeValue(let x): return x.apply(instance, storage) { i, s, v in i.badgeValue = v }
			case .badgeColor(let x):
				return x.apply(instance, storage) { i, s, v in
					if #available(iOS 10.0, *) {
						i.badgeColor = v
					}
				}
			case .systemItem: return nil
			case .selectedImage: return selectedImage.resume()?.apply(instance, storage) { i, s, v in i.selectedImage = v }
			case .inheritedBinding(.tag): return tag.resume()?.apply(instance, storage) { i, s, v in i.tag = v }
			case .inheritedBinding(.image): return image.resume()?.apply(instance, storage) { i, s, v in i.image = v }
			case .inheritedBinding(.title): return title.resume()?.apply(instance, storage) { i, s, v in i.title = v }
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: instance, storage: storage)
			}
		}
	}
	
	typealias Storage = BarItem.Storage
}

extension BindingName where Binding: TabBarItemBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .tabBarItemBinding(TabBarItem.Binding.$1(v)) }) }
	static var selectedImage: BindingName<Dynamic<UIImage?>, Binding> { return BindingName<Dynamic<UIImage?>, Binding>({ v in .tabBarItemBinding(TabBarItem.Binding.selectedImage(v)) }) }
	static var titlePositionAdjustment: BindingName<Dynamic<UIOffset>, Binding> { return BindingName<Dynamic<UIOffset>, Binding>({ v in .tabBarItemBinding(TabBarItem.Binding.titlePositionAdjustment(v)) }) }
	static var badgeValue: BindingName<Dynamic<String?>, Binding> { return BindingName<Dynamic<String?>, Binding>({ v in .tabBarItemBinding(TabBarItem.Binding.badgeValue(v)) }) }
	@available(iOS 10.0, *)
	static var badgeColor: BindingName<Dynamic<UIColor?>, Binding> { return BindingName<Dynamic<UIColor?>, Binding>({ v in .tabBarItemBinding(TabBarItem.Binding.badgeColor(v)) }) }
	@available(iOS 10.0, *)
	static var badgeTextAttributes: BindingName<Dynamic<ScopedValues<UIControl.State, [NSAttributedString.Key : Any]?>>, Binding> { return BindingName<Dynamic<ScopedValues<UIControl.State, [NSAttributedString.Key : Any]?>>, Binding>({ v in .tabBarItemBinding(TabBarItem.Binding.badgeTextAttributes(v)) }) }
}

protocol TabBarItemConvertible: BarItemConvertible {
	func uiTabBarItem() -> TabBarItem.Instance
}
extension TabBarItemConvertible {
	func uiBarItem() -> BarItem.Instance { return uiTabBarItem() }
}
extension TabBarItem.Instance: TabBarItemConvertible {
	func uiTabBarItem() -> TabBarItem.Instance { return self }
}

protocol TabBarItemBinding: BarItemBinding {
	static func tabBarItemBinding(_ binding: TabBarItem.Binding) -> Self
}
extension TabBarItemBinding {
	static func barItemBinding(_ binding: BarItem.Binding) -> Self {
		return tabBarItemBinding(.inheritedBinding(binding))
	}
}

class NavigationBar: ConstructingBinder, NavigationBarConvertible {
	typealias Instance = UINavigationBar
	typealias Inherited = View
	
	var state: ConstructingBinderState<Instance, Binding>
	required init(state: ConstructingBinderState<Instance, Binding>) {
		self.state = state
	}
	static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	func uiNavigationBar() -> Instance { return instance() }
	
	enum Binding: NavigationBarBinding {
		typealias EnclosingBinder = NavigationBar
		static func navigationBarBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case items(Dynamic<SetOrAnimate<[NavigationItemConvertible]>>)
		case backIndicatorImage(Dynamic<UIImage?>)
		case backIndicatorTransitionMaskImage(Dynamic<UIImage?>)
		case barStyle(Dynamic<UIBarStyle>)
		case barTintColor(Dynamic<UIColor?>)
		case shadowImage(Dynamic<UIImage?>)
		case tintColor(Dynamic<UIColor?>)
		case isTranslucent(Dynamic<Bool>)
		case titleTextAttributes(Dynamic<[NSAttributedString.Key: Any]>)
		case titleVerticalPositionAdjustment(Dynamic<ScopedValues<UIBarMetrics, CGFloat>>)
		case backgroundImage(Dynamic<ScopedValues<PositionAndMetrics, UIImage?>>)
		
		// 2. Signal bindings are performed on the object after construction.
		
		//	3. Action bindings are triggered by the object after construction.
		case didPush(SignalInput<UINavigationItem>)
		case didPop(SignalInput<UINavigationItem>)
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case shouldPush((UINavigationBar, UINavigationItem) -> Bool)
		case shouldPop((UINavigationBar, UINavigationItem) -> Bool)
		case position((UIBarPositioning) -> UIBarPosition)
	}

	struct Preparer: ConstructingPreparer {
		typealias EnclosingBinder = NavigationBar
		var linkedPreparer = Inherited.Preparer()
		
		func constructStorage() -> EnclosingBinder.Storage { return Storage() }
		func constructInstance(subclass: EnclosingBinder.Instance.Type) -> EnclosingBinder.Instance { return subclass.init() }
		
		init() {
			self.init(delegateClass: Delegate.self)
		}
		init<Value>(delegateClass: Value.Type) where Value: Delegate {
			self.delegateClass = delegateClass
		}
		let delegateClass: Delegate.Type
		var possibleDelegate: Delegate? = nil
		mutating func delegate() -> Delegate {
			if let d = possibleDelegate {
				return d
			} else {
				let d = delegateClass.init()
				possibleDelegate = d
				return d
			}
		}
		
		mutating func prepareBinding(_ binding: Binding) {
			switch binding {
			case .shouldPush(let x):
				let s = #selector(UINavigationBarDelegate.navigationBar(_:shouldPush:))
				delegate().addSelector(s).shouldPush = x
			case .shouldPop(let x):
				let s = #selector(UINavigationBarDelegate.navigationBar(_:shouldPop:))
				delegate().addSelector(s).shouldPop = x
			case .position(let x):
				let s = #selector(UINavigationBarDelegate.position(for:))
				delegate().addSelector(s).position = x
			case .didPush(let x):
				let s = #selector(UINavigationBarDelegate.navigationBar(_:didPush:))
				delegate().addSelector(s).didPush = x
			case .didPop(let x):
				let s = #selector(UINavigationBarDelegate.navigationBar(_:didPop:))
				delegate().addSelector(s).didPop = x
			case .inheritedBinding(let x): linkedPreparer.prepareBinding(x)
			default: break
			}
		}
		
		mutating func prepareInstance(_ instance: Instance, storage: Storage) {
			// Don't steal the delegate from the navigation controller
			if possibleDelegate != nil {
				precondition(instance.delegate == nil, "Conflicting delegate applied to instance")
				storage.dynamicDelegate = possibleDelegate
				instance.delegate = storage
			}
			
			linkedPreparer.prepareInstance(instance, storage: storage)
		}
		
		func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
			switch binding {
			case .backgroundImage(let x):
				var previous: ScopedValues<PositionAndMetrics, UIImage?>? = nil
				return x.apply(instance, storage) { i, s, v in
					if let p = previous {
						for conditions in p.pairs {
							if conditions.value != nil {
								i.setBackgroundImage(nil, for: conditions.scope.barPosition, barMetrics: conditions.scope.barMetrics)
							}
						}
					}
					previous = v
					for conditions in v.pairs {
						if let image = conditions.value {
							i.setBackgroundImage(image, for: conditions.scope.barPosition, barMetrics: conditions.scope.barMetrics)
						}
					}
				}
			case .titleVerticalPositionAdjustment(let x):
				var previous: ScopedValues<UIBarMetrics, CGFloat>? = nil
				return x.apply(instance, storage) { i, s, v in
					if let p = previous {
						for c in p.pairs {
							i.setTitleVerticalPositionAdjustment(0, for: c.0)
						}
					}
					previous = v
					for c in v.pairs {
						i.setTitleVerticalPositionAdjustment(c.1, for: c.0)
					}
				}
			case .items(let x): return x.apply(instance, storage) { i, s, v in i.setItems(v.value.map { $0.uiNavigationItem() }, animated: v.isAnimated) }
			case .backIndicatorImage(let x): return x.apply(instance, storage) { i, s, v in i.backIndicatorImage = v }
			case .backIndicatorTransitionMaskImage(let x): return x.apply(instance, storage) { i, s, v in i.backIndicatorTransitionMaskImage = v }
			case .barStyle(let x): return x.apply(instance, storage) { i, s, v in i.barStyle = v }
			case .barTintColor(let x): return x.apply(instance, storage) { i, s, v in i.barTintColor = v }
			case .shadowImage(let x): return x.apply(instance, storage) { i, s, v in i.shadowImage = v }
			case .tintColor(let x): return x.apply(instance, storage) { i, s, v in i.tintColor = v }
			case .isTranslucent(let x): return x.apply(instance, storage) { i, s, v in i.isTranslucent = v }
			case .titleTextAttributes(let x):
				return x.apply(instance, storage) { i, s, v in
					i.titleTextAttributes = v
				}
			case .didPush: return nil
			case .didPop: return nil
			case .shouldPush: return nil
			case .shouldPop: return nil
			case .position: return nil
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: instance, storage: storage)
			}
		}
	}

	class Storage: View.Storage, UINavigationBarDelegate {}

	class Delegate: DynamicDelegate, UINavigationBarDelegate {
		required override init() {
			super.init()
		}
		
		var shouldPop: ((_ navigationBar: UINavigationBar, _ item: UINavigationItem) -> Bool)?
		func navigationBar(_ navigationBar: UINavigationBar, shouldPop item: UINavigationItem) -> Bool {
			return shouldPop!(navigationBar, item)
		}
		
		var shouldPush: ((_ navigationBar: UINavigationBar, _ item: UINavigationItem) -> Bool)?
		func navigationBar(_ navigationBar: UINavigationBar, shouldPush item: UINavigationItem) -> Bool {
			return shouldPush!(navigationBar, item)
		}
		
		var didPop: SignalInput<UINavigationItem>?
		func navigationBar(_ navigationBar: UINavigationBar, didPop item: UINavigationItem) {
			didPop!.send(value: item)
		}
		
		var didPush: SignalInput<UINavigationItem>?
		func navigationBar(_ navigationBar: UINavigationBar, didPush item: UINavigationItem) {
			didPush!.send(value: item)
		}
		
		var position: ((UIBarPositioning) -> UIBarPosition)?
		func position(for bar: UIBarPositioning) -> UIBarPosition {
			return position!(bar)
		}
	}
}

extension BindingName where Binding: NavigationBarBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .navigationBarBinding(NavigationBar.Binding.$1(v)) }) }
	static var items: BindingName<Dynamic<SetOrAnimate<[NavigationItemConvertible]>>, Binding> { return BindingName<Dynamic<SetOrAnimate<[NavigationItemConvertible]>>, Binding>({ v in .navigationBarBinding(NavigationBar.Binding.items(v)) }) }
	static var backIndicatorImage: BindingName<Dynamic<UIImage?>, Binding> { return BindingName<Dynamic<UIImage?>, Binding>({ v in .navigationBarBinding(NavigationBar.Binding.backIndicatorImage(v)) }) }
	static var backIndicatorTransitionMaskImage: BindingName<Dynamic<UIImage?>, Binding> { return BindingName<Dynamic<UIImage?>, Binding>({ v in .navigationBarBinding(NavigationBar.Binding.backIndicatorTransitionMaskImage(v)) }) }
	static var barStyle: BindingName<Dynamic<UIBarStyle>, Binding> { return BindingName<Dynamic<UIBarStyle>, Binding>({ v in .navigationBarBinding(NavigationBar.Binding.barStyle(v)) }) }
	static var barTintColor: BindingName<Dynamic<UIColor?>, Binding> { return BindingName<Dynamic<UIColor?>, Binding>({ v in .navigationBarBinding(NavigationBar.Binding.barTintColor(v)) }) }
	static var shadowImage: BindingName<Dynamic<UIImage?>, Binding> { return BindingName<Dynamic<UIImage?>, Binding>({ v in .navigationBarBinding(NavigationBar.Binding.shadowImage(v)) }) }
	static var tintColor: BindingName<Dynamic<UIColor?>, Binding> { return BindingName<Dynamic<UIColor?>, Binding>({ v in .navigationBarBinding(NavigationBar.Binding.tintColor(v)) }) }
	static var isTranslucent: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .navigationBarBinding(NavigationBar.Binding.isTranslucent(v)) }) }
	static var titleTextAttributes: BindingName<Dynamic<[NSAttributedString.Key: Any]>, Binding> { return BindingName<Dynamic<[NSAttributedString.Key: Any]>, Binding>({ v in .navigationBarBinding(NavigationBar.Binding.titleTextAttributes(v)) }) }
	static var titleVerticalPositionAdjustment: BindingName<Dynamic<ScopedValues<UIBarMetrics, CGFloat>>, Binding> { return BindingName<Dynamic<ScopedValues<UIBarMetrics, CGFloat>>, Binding>({ v in .navigationBarBinding(NavigationBar.Binding.titleVerticalPositionAdjustment(v)) }) }
	static var backgroundImage: BindingName<Dynamic<ScopedValues<PositionAndMetrics, UIImage?>>, Binding> { return BindingName<Dynamic<ScopedValues<PositionAndMetrics, UIImage?>>, Binding>({ v in .navigationBarBinding(NavigationBar.Binding.backgroundImage(v)) }) }
	static var didPush: BindingName<SignalInput<UINavigationItem>, Binding> { return BindingName<SignalInput<UINavigationItem>, Binding>({ v in .navigationBarBinding(NavigationBar.Binding.didPush(v)) }) }
	static var didPop: BindingName<SignalInput<UINavigationItem>, Binding> { return BindingName<SignalInput<UINavigationItem>, Binding>({ v in .navigationBarBinding(NavigationBar.Binding.didPop(v)) }) }
	static var shouldPush: BindingName<(UINavigationBar, UINavigationItem) -> Bool, Binding> { return BindingName<(UINavigationBar, UINavigationItem) -> Bool, Binding>({ v in .navigationBarBinding(NavigationBar.Binding.shouldPush(v)) }) }
	static var shouldPop: BindingName<(UINavigationBar, UINavigationItem) -> Bool, Binding> { return BindingName<(UINavigationBar, UINavigationItem) -> Bool, Binding>({ v in .navigationBarBinding(NavigationBar.Binding.shouldPop(v)) }) }
}

protocol NavigationBarConvertible: ViewConvertible {
	func uiNavigationBar() -> NavigationBar.Instance
}
extension NavigationBarConvertible {
	func uiView() -> View.Instance { return uiNavigationBar() }
}
extension NavigationBar.Instance: NavigationBarConvertible {
	func uiNavigationBar() -> NavigationBar.Instance { return self }
}

protocol NavigationBarBinding: ViewBinding {
	static func navigationBarBinding(_ binding: NavigationBar.Binding) -> Self
}
extension NavigationBarBinding {
	static func viewBinding(_ binding: View.Binding) -> Self {
		return navigationBarBinding(.inheritedBinding(binding))
	}
}

struct PositionAndMetrics {
	let barPosition: UIBarPosition
	let barMetrics: UIBarMetrics
	init(position: UIBarPosition = .any, metrics: UIBarMetrics = .default) {
		self.barPosition = position
		self.barMetrics = metrics
	}
}

extension ScopedValues where Scope == PositionAndMetrics {
	static func any(metrics: UIBarMetrics = .default, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: PositionAndMetrics(position: .any, metrics: metrics))
	}
	static func bottom(metrics: UIBarMetrics = .default, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: PositionAndMetrics(position: .bottom, metrics: metrics))
	}
	static func top(metrics: UIBarMetrics = .default, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: PositionAndMetrics(position: .top, metrics: metrics))
	}
	static func topAttached(metrics: UIBarMetrics = .default, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: PositionAndMetrics(position: .topAttached, metrics: metrics))
	}
}

class LongPressGestureRecognizer: ConstructingBinder, LongPressGestureRecognizerConvertible {
	typealias Instance = UILongPressGestureRecognizer
	typealias Inherited = GestureRecognizer
	
	var state: ConstructingBinderState<Instance, Binding>
	required init(state: ConstructingBinderState<Instance, Binding>) {
		self.state = state
	}
	static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	func uiLongPressGestureRecognizer() -> Instance { return instance() }
	
	enum Binding: LongPressGestureRecognizerBinding {
		typealias EnclosingBinder = LongPressGestureRecognizer
		static func longPressGestureRecognizerBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case minimumPressDuration(Dynamic<CFTimeInterval>)
		case numberOfTouchesRequired(Dynamic<Int>)
		case numberOfTapsRequired(Dynamic<Int>)
		case allowableMovement(Dynamic<CGFloat>)
		
		// 2. Signal bindings are performed on the object after construction.
		
		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
	
	struct Preparer: ConstructingPreparer {
		typealias EnclosingBinder = LongPressGestureRecognizer
		var linkedPreparer = Inherited.Preparer()
		
		func constructStorage() -> EnclosingBinder.Storage { return Storage() }
		func constructInstance(subclass: EnclosingBinder.Instance.Type) -> EnclosingBinder.Instance { return subclass.init() }
		
		init() {}
		
		func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
			switch binding {
			case .minimumPressDuration(let x): return x.apply(instance, storage) { i, s, v in i.minimumPressDuration = v }
			case .numberOfTouchesRequired(let x): return x.apply(instance, storage) { i, s, v in i.numberOfTouchesRequired = v }
			case .numberOfTapsRequired(let x): return x.apply(instance, storage) { i, s, v in i.numberOfTapsRequired = v }
			case .allowableMovement(let x): return x.apply(instance, storage) { i, s, v in i.allowableMovement = v }
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: instance, storage: storage)
			}
		}
	}
	
	typealias Storage = GestureRecognizer.Storage
}

extension BindingName where Binding: LongPressGestureRecognizerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .longPressGestureRecognizerBinding(LongPressGestureRecognizer.Binding.$1(v)) }) }
	static var minimumPressDuration: BindingName<Dynamic<CFTimeInterval>, Binding> { return BindingName<Dynamic<CFTimeInterval>, Binding>({ v in .longPressGestureRecognizerBinding(LongPressGestureRecognizer.Binding.minimumPressDuration(v)) }) }
	static var numberOfTouchesRequired: BindingName<Dynamic<Int>, Binding> { return BindingName<Dynamic<Int>, Binding>({ v in .longPressGestureRecognizerBinding(LongPressGestureRecognizer.Binding.numberOfTouchesRequired(v)) }) }
	static var numberOfTapsRequired: BindingName<Dynamic<Int>, Binding> { return BindingName<Dynamic<Int>, Binding>({ v in .longPressGestureRecognizerBinding(LongPressGestureRecognizer.Binding.numberOfTapsRequired(v)) }) }
	static var allowableMovement: BindingName<Dynamic<CGFloat>, Binding> { return BindingName<Dynamic<CGFloat>, Binding>({ v in .longPressGestureRecognizerBinding(LongPressGestureRecognizer.Binding.allowableMovement(v)) }) }
}

protocol LongPressGestureRecognizerConvertible: GestureRecognizerConvertible {
	func uiLongPressGestureRecognizer() -> LongPressGestureRecognizer.Instance
}
extension LongPressGestureRecognizerConvertible {
	func uiGestureRecognizer() -> GestureRecognizer.Instance { return uiLongPressGestureRecognizer() }
}
extension LongPressGestureRecognizer.Instance: LongPressGestureRecognizerConvertible {
	func uiLongPressGestureRecognizer() -> LongPressGestureRecognizer.Instance { return self }
}

protocol LongPressGestureRecognizerBinding: GestureRecognizerBinding {
	static func longPressGestureRecognizerBinding(_ binding: LongPressGestureRecognizer.Binding) -> Self
}

extension LongPressGestureRecognizerBinding {
	static func gestureRecognizerBinding(_ binding: GestureRecognizer.Binding) -> Self {
		return longPressGestureRecognizerBinding(.inheritedBinding(binding))
	}
}

class AlertAction: ConstructingBinder, AlertActionConvertible {
	typealias Instance = UIAlertAction
	typealias Inherited = BaseBinder
	
	var state: ConstructingBinderState<Instance, Binding>
	required init(state: ConstructingBinderState<Instance, Binding>) {
		self.state = state
	}
	static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	func uiAlertAction() -> Instance { return instance() }
	
	enum Binding: AlertActionBinding {
		typealias EnclosingBinder = AlertAction
		static func alertActionBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case title(Constant<String>)
		case style(Constant<UIAlertAction.Style>)

		//	1. Value bindings may be applied at construction and may subsequently change.
		case isEnabled(Dynamic<Bool>)

		//	2. Signal bindings are performed on the object after construction.

		//	3. Action bindings are triggered by the object after construction.
		case handler(SignalInput<Void>)

		//	4. Delegate bindings require synchronous evaluation within the object's context.
	}

	struct Preparer: ConstructingPreparer {
		typealias EnclosingBinder = AlertAction
		var linkedPreparer = Inherited.Preparer()
		
		func constructStorage() -> EnclosingBinder.Storage { return Storage() }
		func constructInstance(subclass: EnclosingBinder.Instance.Type) -> EnclosingBinder.Instance {
			return subclass.init(title: title, style: style, handler: handler.map { h in
				{ _ in h.send(value: ()) }
			})
		}
		
		var title: String? = nil
		var style: UIAlertAction.Style = .default
		var handler: SignalInput<Void>? = nil

		init() {}
		
		mutating func prepareBinding(_ binding: AlertAction.Binding) {
			switch binding {
			case .title(let x): title = x.value
			case .style(let x): style = x.value
			case .handler(let x): handler = x
			case .inheritedBinding(let s): return linkedPreparer.prepareBinding(s)
			default: break
			}
		}
		
		func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
			switch binding {
			case .title: return nil
			case .style: return nil
			case .handler: return nil
			case .isEnabled(let x): return x.apply(instance, storage) { i, s, v in i.isEnabled = v }
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: (), storage: ())
			}
		}
		
		mutating func finalizeInstance(_ instance: Instance, storage: Storage) -> Lifetime? {
			let linkedLifetime = linkedPreparer.finalizeInstance(instance, storage: storage)
			return AggregateLifetime(lifetimes: [linkedLifetime, handler as Optional<Lifetime>].compactMap { $0 })
		}
	}

	typealias Storage = ObjectBinderStorage
}

extension BindingName where Binding: AlertActionBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .alertActionBinding(AlertAction.Binding.$1(v)) }) }
	static var title: BindingName<Constant<String>, Binding> { return BindingName<Constant<String>, Binding>({ v in .alertActionBinding(AlertAction.Binding.title(v)) }) }
	static var style: BindingName<Constant<UIAlertAction.Style>, Binding> { return BindingName<Constant<UIAlertAction.Style>, Binding>({ v in .alertActionBinding(AlertAction.Binding.style(v)) }) }
	static var handler: BindingName<SignalInput<Void>, Binding> { return BindingName<SignalInput<Void>, Binding>({ v in .alertActionBinding(AlertAction.Binding.handler(v)) }) }
	static var isEnabled: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .alertActionBinding(AlertAction.Binding.isEnabled(v)) }) }
}

protocol AlertActionConvertible {
	func uiAlertAction() -> AlertAction.Instance
}
extension AlertAction.Instance: AlertActionConvertible {
	func uiAlertAction() -> AlertAction.Instance { return self }
}

protocol AlertActionBinding: BaseBinding {
	static func alertActionBinding(_ binding: AlertAction.Binding) -> Self
}
extension AlertActionBinding {
	static func baseBinding(_ binding: BaseBinder.Binding) -> Self {
		return alertActionBinding(.inheritedBinding(binding))
	}
}

class Slider: ConstructingBinder, SliderConvertible {
	typealias Instance = UISlider
	typealias Inherited = Control
	
	var state: ConstructingBinderState<Instance, Binding>
	required init(state: ConstructingBinderState<Instance, Binding>) {
		self.state = state
	}
	static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	func uiSlider() -> Instance { return instance() }
	
	enum Binding: SliderBinding {
		typealias EnclosingBinder = Slider
		static func sliderBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case value(Dynamic<SetOrAnimate<Float>>)
		case maximumValue(Dynamic<Float>)
		case minimumValue(Dynamic<Float>)
		case isContinuous(Dynamic<Bool>)
		case minimumValueImage(Dynamic<UIImage?>)
		case maximumValueImage(Dynamic<UIImage?>)
		case minimumTrackTintColor(Dynamic<UIColor?>)
		case maximumTrackTintColor(Dynamic<UIColor?>)
		case thumbTintColor(Dynamic<UIColor?>)
		case thumbImage(Dynamic<ScopedValues<UIControl.State, UIImage?>>)
		case minimumTrackImage(Dynamic<ScopedValues<UIControl.State, UIImage?>>)
		case maximumTrackImage(Dynamic<ScopedValues<UIControl.State, UIImage?>>)
		
		// 2. Signal bindings are performed on the object after construction.
		
		//	3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
	
	struct Preparer: ConstructingPreparer {
		typealias EnclosingBinder = Slider
		var linkedPreparer = Inherited.Preparer()
		
		func constructStorage() -> EnclosingBinder.Storage { return Storage() }
		func constructInstance(subclass: EnclosingBinder.Instance.Type) -> EnclosingBinder.Instance { return subclass.init() }
		
		init() {}
		
		func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
			switch binding {
			case .thumbImage(let x):
				var previous: ScopedValues<UIControl.State, UIImage?>? = nil
				return x.apply(instance, storage) { i, s, v in
					if let p = previous {
						for c in p.pairs {
							i.setThumbImage(nil, for: c.0)
						}
					}
					previous = v
					for c in v.pairs {
						i.setThumbImage(c.1, for: c.0)
					}
				}
			case .minimumTrackImage(let x):
				var previous: ScopedValues<UIControl.State, UIImage?>? = nil
				return x.apply(instance, storage) { i, s, v in
					if let p = previous {
						for c in p.pairs {
							i.setMinimumTrackImage(nil, for: c.0)
						}
					}
					previous = v
					for c in v.pairs {
						i.setMinimumTrackImage(c.1, for: c.0)
					}
				}
			case .maximumTrackImage(let x):
				var previous: ScopedValues<UIControl.State, UIImage?>? = nil
				return x.apply(instance, storage) { i, s, v in
					if let p = previous {
						for c in p.pairs {
							i.setMaximumTrackImage(nil, for: c.0)
						}
					}
					previous = v
					for c in v.pairs {
						i.setMaximumTrackImage(c.1, for: c.0)
					}
				}
			case .value(let x): return x.apply(instance, storage) { i, s, v in i.setValue(v.value, animated: v.isAnimated) }
			case .maximumValue(let x): return x.apply(instance, storage) { i, s, v in i.maximumValue = v }
			case .minimumValue(let x): return x.apply(instance, storage) { i, s, v in i.minimumValue = v }
			case .isContinuous(let x): return x.apply(instance, storage) { i, s, v in i.isContinuous = v }
			case .minimumValueImage(let x): return x.apply(instance, storage) { i, s, v in i.minimumValueImage = v }
			case .maximumValueImage(let x): return x.apply(instance, storage) { i, s, v in i.maximumValueImage = v }
			case .minimumTrackTintColor(let x): return x.apply(instance, storage) { i, s, v in i.minimumTrackTintColor = v }
			case .maximumTrackTintColor(let x): return x.apply(instance, storage) { i, s, v in i.maximumTrackTintColor = v }
			case .thumbTintColor(let x): return x.apply(instance, storage) { i, s, v in i.thumbTintColor = v }
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: instance, storage: storage)
			}
		}
	}
	
	typealias Storage = Control.Storage
}

extension BindingName where Binding: SliderBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .sliderBinding(Slider.Binding.$1(v)) }) }
	static var value: BindingName<Dynamic<SetOrAnimate<Float>>, Binding> { return BindingName<Dynamic<SetOrAnimate<Float>>, Binding>({ v in .sliderBinding(Slider.Binding.value(v)) }) }
	static var maximumValue: BindingName<Dynamic<Float>, Binding> { return BindingName<Dynamic<Float>, Binding>({ v in .sliderBinding(Slider.Binding.maximumValue(v)) }) }
	static var minimumValue: BindingName<Dynamic<Float>, Binding> { return BindingName<Dynamic<Float>, Binding>({ v in .sliderBinding(Slider.Binding.minimumValue(v)) }) }
	static var isContinuous: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .sliderBinding(Slider.Binding.isContinuous(v)) }) }
	static var minimumValueImage: BindingName<Dynamic<UIImage?>, Binding> { return BindingName<Dynamic<UIImage?>, Binding>({ v in .sliderBinding(Slider.Binding.minimumValueImage(v)) }) }
	static var maximumValueImage: BindingName<Dynamic<UIImage?>, Binding> { return BindingName<Dynamic<UIImage?>, Binding>({ v in .sliderBinding(Slider.Binding.maximumValueImage(v)) }) }
	static var minimumTrackTintColor: BindingName<Dynamic<UIColor?>, Binding> { return BindingName<Dynamic<UIColor?>, Binding>({ v in .sliderBinding(Slider.Binding.minimumTrackTintColor(v)) }) }
	static var maximumTrackTintColor: BindingName<Dynamic<UIColor?>, Binding> { return BindingName<Dynamic<UIColor?>, Binding>({ v in .sliderBinding(Slider.Binding.maximumTrackTintColor(v)) }) }
	static var thumbTintColor: BindingName<Dynamic<UIColor?>, Binding> { return BindingName<Dynamic<UIColor?>, Binding>({ v in .sliderBinding(Slider.Binding.thumbTintColor(v)) }) }
	static var thumbImage: BindingName<Dynamic<ScopedValues<UIControl.State, UIImage?>>, Binding> { return BindingName<Dynamic<ScopedValues<UIControl.State, UIImage?>>, Binding>({ v in .sliderBinding(Slider.Binding.thumbImage(v)) }) }
	static var minimumTrackImage: BindingName<Dynamic<ScopedValues<UIControl.State, UIImage?>>, Binding> { return BindingName<Dynamic<ScopedValues<UIControl.State, UIImage?>>, Binding>({ v in .sliderBinding(Slider.Binding.minimumTrackImage(v)) }) }
	static var maximumTrackImage: BindingName<Dynamic<ScopedValues<UIControl.State, UIImage?>>, Binding> { return BindingName<Dynamic<ScopedValues<UIControl.State, UIImage?>>, Binding>({ v in .sliderBinding(Slider.Binding.maximumTrackImage(v)) }) }
}

protocol SliderConvertible: ControlConvertible {
	func uiSlider() -> Slider.Instance
}
extension SliderConvertible {
	func uiControl() -> Control.Instance { return uiSlider() }
}
extension Slider.Instance: SliderConvertible {
	func uiSlider() -> Slider.Instance { return self }
}

protocol SliderBinding: ControlBinding {
	static func sliderBinding(_ binding: Slider.Binding) -> Self
}
extension SliderBinding {
	static func controlBinding(_ binding: Control.Binding) -> Self {
		return sliderBinding(.inheritedBinding(binding))
	}
}

class Window: ConstructingBinder, WindowConvertible {
	typealias Instance = UIWindow
	typealias Inherited = View
	
	var state: ConstructingBinderState<Instance, Binding>
	required init(state: ConstructingBinderState<Instance, Binding>) {
		self.state = state
	}
	static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	func uiWindow() -> Instance { return instance() }
	
	enum Binding: WindowBinding {
		typealias EnclosingBinder = Window
		static func windowBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case rootViewController(Dynamic<ViewControllerConvertible>)
		case windowLevel(Dynamic<UIWindow.Level>)
		case screen(Dynamic<UIScreen>)
		case frame(Dynamic<CGRect>)
		
		// 2. Signal bindings are performed on the object after construction.
		case makeKey(Signal<Void>)
		
		// 3. Action bindings are triggered by the object after construction.
		case didBecomeVisible(SignalInput<Void>)
		case didBecomeHidden(SignalInput<Void>)
		case didBecomeKey(SignalInput<Void>)
		case didResignKey(SignalInput<Void>)
		case keyboardWillShow(SignalInput<[AnyHashable: Any]?>)
		case keyboardDidShow(SignalInput<[AnyHashable: Any]?>)
		case keyboardWillHide(SignalInput<[AnyHashable: Any]?>)
		case keyboardDidHide(SignalInput<[AnyHashable: Any]?>)
		case keyboardWillChangeFrame(SignalInput<[AnyHashable: Any]?>)
		case keyboardDidChangeFrame(SignalInput<[AnyHashable: Any]?>)
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
	
	struct Preparer: ConstructingPreparer {
		typealias EnclosingBinder = Window
		var linkedPreparer = Inherited.Preparer()
		
		func constructStorage() -> EnclosingBinder.Storage { return Storage() }
		func constructInstance(subclass: EnclosingBinder.Instance.Type) -> EnclosingBinder.Instance { return subclass.init() }
		
		init() {}

		var isHidden: InitialSubsequent<Bool>? = nil
		
		mutating func prepareBinding(_ binding: Window.Binding) {
			switch binding {
			case .inheritedBinding(.isHidden(let x)): isHidden = x.initialSubsequent()
			case .inheritedBinding(let s): linkedPreparer.prepareBinding(s)
			default: break
			}
		}
		
		func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
			switch binding {
			case .frame(let x): return x.apply(instance, storage) { i, s, v in i.frame = v }
			case .rootViewController(let x):
				return x.apply(instance, storage) { i, s, v in
					let rootViewController = v.uiViewController()
					i.rootViewController = rootViewController
					if rootViewController.restorationIdentifier == nil {
						rootViewController.restorationIdentifier = "cwlviews.root"
					}
				}
			case .windowLevel(let x): return x.apply(instance, storage) { i, s, v in i.windowLevel = v }
			case .screen(let x): return x.apply(instance, storage) { i, s, v in i.screen = v }
			case .makeKey(let x): return x.apply(instance, storage) { i, s, v in i.makeKey() }
			case .didBecomeVisible(let x): return Signal.notifications(name: UIWindow.didBecomeVisibleNotification, object: instance).map { notification -> Void in }.cancellableBind(to: x)
			case .didBecomeHidden(let x): return Signal.notifications(name: UIWindow.didBecomeHiddenNotification, object: instance).map { notification -> Void in }.cancellableBind(to: x)
			case .didBecomeKey(let x): return Signal.notifications(name: UIWindow.didBecomeKeyNotification, object: instance).map { notification -> Void in }.cancellableBind(to: x)
			case .didResignKey(let x): return Signal.notifications(name: UIWindow.didResignKeyNotification, object: instance).map { notification -> Void in }.cancellableBind(to: x)
			case .keyboardWillShow(let x): return Signal.notifications(name: UIResponder.keyboardWillShowNotification, object: instance).map { notification -> [AnyHashable: Any]? in notification.userInfo }.cancellableBind(to: x)
			case .keyboardDidShow(let x): return Signal.notifications(name: UIResponder.keyboardDidShowNotification, object: instance).map { notification -> [AnyHashable: Any]? in notification.userInfo }.cancellableBind(to: x)
			case .keyboardWillHide(let x): return Signal.notifications(name: UIResponder.keyboardWillHideNotification, object: instance).map { notification -> [AnyHashable: Any]? in notification.userInfo }.cancellableBind(to: x)
			case .keyboardDidHide(let x): return Signal.notifications(name: UIResponder.keyboardDidHideNotification, object: instance).map { notification -> [AnyHashable: Any]? in notification.userInfo }.cancellableBind(to: x)
			case .keyboardWillChangeFrame(let x): return Signal.notifications(name: UIResponder.keyboardWillChangeFrameNotification, object: instance).map { notification -> [AnyHashable: Any]? in notification.userInfo }.cancellableBind(to: x)
			case .keyboardDidChangeFrame(let x): return Signal.notifications(name: UIResponder.keyboardDidChangeFrameNotification, object: instance).map { notification -> [AnyHashable: Any]? in notification.userInfo }.cancellableBind(to: x)
			case .inheritedBinding(.isHidden): return nil
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: instance, storage: storage)
			}
		}
		
		mutating func finalizeInstance(_ instance: Instance, storage: View.Storage) -> Lifetime? {
			let lifetime = linkedPreparer.finalizeInstance(instance, storage: storage)
			if let h = isHidden?.resume() {
				if let c2 = linkedPreparer.applyBinding(.isHidden(.dynamic(h)), instance: instance, storage: storage) {
					return lifetime.map { c1 in AggregateLifetime(lifetimes: [c2, c1]) } ?? c2
				}
			}
			return lifetime
		}
	}
	
	typealias Storage = View.Storage
}

extension BindingName where Binding: WindowBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .windowBinding(Window.Binding.$1(v)) }) }
	static var frame: BindingName<Dynamic<CGRect>, Binding> { return BindingName<Dynamic<CGRect>, Binding>({ v in .windowBinding(Window.Binding.frame(v)) }) }
	static var rootViewController: BindingName<Dynamic<ViewControllerConvertible>, Binding> { return BindingName<Dynamic<ViewControllerConvertible>, Binding>({ v in .windowBinding(Window.Binding.rootViewController(v)) }) }
	static var windowLevel: BindingName<Dynamic<UIWindow.Level>, Binding> { return BindingName<Dynamic<UIWindow.Level>, Binding>({ v in .windowBinding(Window.Binding.windowLevel(v)) }) }
	static var screen: BindingName<Dynamic<UIScreen>, Binding> { return BindingName<Dynamic<UIScreen>, Binding>({ v in .windowBinding(Window.Binding.screen(v)) }) }
	static var makeKey: BindingName<Signal<Void>, Binding> { return BindingName<Signal<Void>, Binding>({ v in .windowBinding(Window.Binding.makeKey(v)) }) }
	static var didBecomeVisible: BindingName<SignalInput<Void>, Binding> { return BindingName<SignalInput<Void>, Binding>({ v in .windowBinding(Window.Binding.didBecomeVisible(v)) }) }
	static var didBecomeHidden: BindingName<SignalInput<Void>, Binding> { return BindingName<SignalInput<Void>, Binding>({ v in .windowBinding(Window.Binding.didBecomeHidden(v)) }) }
	static var didBecomeKey: BindingName<SignalInput<Void>, Binding> { return BindingName<SignalInput<Void>, Binding>({ v in .windowBinding(Window.Binding.didBecomeKey(v)) }) }
	static var didResignKey: BindingName<SignalInput<Void>, Binding> { return BindingName<SignalInput<Void>, Binding>({ v in .windowBinding(Window.Binding.didResignKey(v)) }) }
	static var keyboardWillShow: BindingName<SignalInput<[AnyHashable: Any]?>, Binding> { return BindingName<SignalInput<[AnyHashable: Any]?>, Binding>({ v in .windowBinding(Window.Binding.keyboardWillShow(v)) }) }
	static var keyboardDidShow: BindingName<SignalInput<[AnyHashable: Any]?>, Binding> { return BindingName<SignalInput<[AnyHashable: Any]?>, Binding>({ v in .windowBinding(Window.Binding.keyboardDidShow(v)) }) }
	static var keyboardWillHide: BindingName<SignalInput<[AnyHashable: Any]?>, Binding> { return BindingName<SignalInput<[AnyHashable: Any]?>, Binding>({ v in .windowBinding(Window.Binding.keyboardWillHide(v)) }) }
	static var keyboardDidHide: BindingName<SignalInput<[AnyHashable: Any]?>, Binding> { return BindingName<SignalInput<[AnyHashable: Any]?>, Binding>({ v in .windowBinding(Window.Binding.keyboardDidHide(v)) }) }
	static var keyboardWillChangeFrame: BindingName<SignalInput<[AnyHashable: Any]?>, Binding> { return BindingName<SignalInput<[AnyHashable: Any]?>, Binding>({ v in .windowBinding(Window.Binding.keyboardWillChangeFrame(v)) }) }
	static var keyboardDidChangeFrame: BindingName<SignalInput<[AnyHashable: Any]?>, Binding> { return BindingName<SignalInput<[AnyHashable: Any]?>, Binding>({ v in .windowBinding(Window.Binding.keyboardDidChangeFrame(v)) }) }
}

protocol WindowConvertible: ViewConvertible {
	func uiWindow() -> Window.Instance
}
extension WindowConvertible {
	func uiView() -> View.Instance { return uiWindow() }
}
extension Window.Instance: WindowConvertible {
	func uiWindow() -> Window.Instance { return self }
}

protocol WindowBinding: ViewBinding {
	static func windowBinding(_ binding: Window.Binding) -> Self
}
extension WindowBinding {
	static func viewBinding(_ binding: View.Binding) -> Self {
		return windowBinding(.inheritedBinding(binding))
	}
}

class Switch: ConstructingBinder, SwitchConvertible {
	typealias Instance = UISwitch
	typealias Inherited = Control
	
	var state: ConstructingBinderState<Instance, Binding>
	required init(state: ConstructingBinderState<Instance, Binding>) {
		self.state = state
	}
	static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	func uiSwitch() -> Instance { return instance() }
	
	enum Binding: SwitchBinding {
		typealias EnclosingBinder = Switch
		static func switchBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case isOn(Dynamic<SetOrAnimate<Bool>>)
		case onTintColor(Dynamic<UIColor>)
		case tintColor(Dynamic<UIColor>)
		case thumbTintColor(Dynamic<UIColor>)
		case onImage(Dynamic<UIImage?>)
		case offImage(Dynamic<UIImage?>)
		
		// 2. Signal bindings are performed on the object after construction.
		
		//	3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
	
	struct Preparer: ConstructingPreparer {
		typealias EnclosingBinder = Switch
		var linkedPreparer = Inherited.Preparer()
		
		func constructStorage() -> EnclosingBinder.Storage { return Storage() }
		func constructInstance(subclass: EnclosingBinder.Instance.Type) -> EnclosingBinder.Instance { return subclass.init() }
		
		init() {}
		
		func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
			switch binding {
			case .isOn(let x): return x.apply(instance, storage) { i, s, v in i.setOn(v.value, animated: v.isAnimated) }
			case .onTintColor(let x): return x.apply(instance, storage) { i, s, v in i.onTintColor = v }
			case .tintColor(let x): return x.apply(instance, storage) { i, s, v in i.tintColor = v }
			case .thumbTintColor(let x): return x.apply(instance, storage) { i, s, v in i.thumbTintColor = v }
			case .onImage(let x): return x.apply(instance, storage) { i, s, v in i.onImage = v }
			case .offImage(let x): return x.apply(instance, storage) { i, s, v in i.offImage = v }
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: instance, storage: storage)
			}
		}
	}
	
	typealias Storage = Control.Storage
}

extension BindingName where Binding: SwitchBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .switchBinding(Switch.Binding.$1(v)) }) }
	static var isOn: BindingName<Dynamic<SetOrAnimate<Bool>>, Binding> { return BindingName<Dynamic<SetOrAnimate<Bool>>, Binding>({ v in .switchBinding(Switch.Binding.isOn(v)) }) }
	static var onTintColor: BindingName<Dynamic<UIColor>, Binding> { return BindingName<Dynamic<UIColor>, Binding>({ v in .switchBinding(Switch.Binding.onTintColor(v)) }) }
	static var tintColor: BindingName<Dynamic<UIColor>, Binding> { return BindingName<Dynamic<UIColor>, Binding>({ v in .switchBinding(Switch.Binding.tintColor(v)) }) }
	static var thumbTintColor: BindingName<Dynamic<UIColor>, Binding> { return BindingName<Dynamic<UIColor>, Binding>({ v in .switchBinding(Switch.Binding.thumbTintColor(v)) }) }
	static var onImage: BindingName<Dynamic<UIImage?>, Binding> { return BindingName<Dynamic<UIImage?>, Binding>({ v in .switchBinding(Switch.Binding.onImage(v)) }) }
	static var offImage: BindingName<Dynamic<UIImage?>, Binding> { return BindingName<Dynamic<UIImage?>, Binding>({ v in .switchBinding(Switch.Binding.offImage(v)) }) }
}

protocol SwitchConvertible: ControlConvertible {
	func uiSwitch() -> Switch.Instance
}
extension SwitchConvertible {
	func uiControl() -> Control.Instance { return uiSwitch() }
}
extension Switch.Instance: SwitchConvertible {
	func uiSwitch() -> Switch.Instance { return self }
}

protocol SwitchBinding: ControlBinding {
	static func switchBinding(_ binding: Switch.Binding) -> Self
}
extension SwitchBinding {
	static func controlBinding(_ binding: Control.Binding) -> Self {
		return switchBinding(.inheritedBinding(binding))
	}
}


class PanGestureRecognizer: ConstructingBinder, PanGestureRecognizerConvertible {
	typealias Instance = UIPanGestureRecognizer
	typealias Inherited = GestureRecognizer
	
	var state: ConstructingBinderState<Instance, Binding>
	required init(state: ConstructingBinderState<Instance, Binding>) {
		self.state = state
	}
	static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	func uiPanGestureRecognizer() -> Instance { return instance() }
	
	enum Binding: PanGestureRecognizerBinding {
		typealias EnclosingBinder = PanGestureRecognizer
		static func panGestureRecognizerBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case maximumNumberOfTouches(Dynamic<Int>)
		case minimumNumberOfTouches(Dynamic<Int>)
		case translation(Dynamic<CGPoint>)
		
		// 2. Signal bindings are performed on the object after construction.
		
		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
	
	struct Preparer: ConstructingPreparer {
		typealias EnclosingBinder = PanGestureRecognizer
		var linkedPreparer = Inherited.Preparer()
		
		func constructStorage() -> EnclosingBinder.Storage { return Storage() }
		func constructInstance(subclass: EnclosingBinder.Instance.Type) -> EnclosingBinder.Instance { return subclass.init() }
		
		init() {}
		
		func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
			switch binding {
			case .maximumNumberOfTouches(let x): return x.apply(instance, storage) { i, s, v in i.maximumNumberOfTouches = v }
			case .minimumNumberOfTouches(let x): return x.apply(instance, storage) { i, s, v in i.minimumNumberOfTouches = v }
			case .translation(let x): return x.apply(instance, storage) { i, s, v in i.setTranslation(v, in: nil) }
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: instance, storage: storage)
			}
		}
	}
	
	typealias Storage = GestureRecognizer.Storage
}

extension BindingName where Binding: PanGestureRecognizerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .panGestureRecognizerBinding(PanGestureRecognizer.Binding.$1(v)) }) }
	static var maximumNumberOfTouches: BindingName<Dynamic<Int>, Binding> { return BindingName<Dynamic<Int>, Binding>({ v in .panGestureRecognizerBinding(PanGestureRecognizer.Binding.maximumNumberOfTouches(v)) }) }
	static var minimumNumberOfTouches: BindingName<Dynamic<Int>, Binding> { return BindingName<Dynamic<Int>, Binding>({ v in .panGestureRecognizerBinding(PanGestureRecognizer.Binding.minimumNumberOfTouches(v)) }) }
	static var translation: BindingName<Dynamic<CGPoint>, Binding> { return BindingName<Dynamic<CGPoint>, Binding>({ v in .panGestureRecognizerBinding(PanGestureRecognizer.Binding.translation(v)) }) }
}

protocol PanGestureRecognizerConvertible: GestureRecognizerConvertible {
	func uiPanGestureRecognizer() -> PanGestureRecognizer.Instance
}
extension PanGestureRecognizerConvertible {
	func uiGestureRecognizer() -> GestureRecognizer.Instance { return uiPanGestureRecognizer() }
}
extension PanGestureRecognizer.Instance: PanGestureRecognizerConvertible {
	func uiPanGestureRecognizer() -> PanGestureRecognizer.Instance { return self }
}

protocol PanGestureRecognizerBinding: GestureRecognizerBinding {
	static func panGestureRecognizerBinding(_ binding: PanGestureRecognizer.Binding) -> Self
}
extension PanGestureRecognizerBinding {
	static func gestureRecognizerBinding(_ binding: GestureRecognizer.Binding) -> Self {
		return panGestureRecognizerBinding(.inheritedBinding(binding))
	}
}

class SplitViewController: ConstructingBinder, SplitViewControllerConvertible {
	typealias Instance = UISplitViewController
	typealias Inherited = ViewController
	
	var state: ConstructingBinderState<Instance, Binding>
	required init(state: ConstructingBinderState<Instance, Binding>) {
		self.state = state
	}
	static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	func uiSplitViewController() -> Instance { return instance() }
	
	enum Binding: SplitViewControllerBinding {
		typealias EnclosingBinder = SplitViewController
		static func splitViewControllerBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case primaryViewController(Dynamic<ViewControllerConvertible>)
		case secondaryViewController(Dynamic<ViewControllerConvertible>)
		case presentsWithGesture(Dynamic<Bool>)
		case preferredDisplayMode(Dynamic<UISplitViewController.DisplayMode>)
		case preferredPrimaryColumnWidthFraction(Dynamic<CGFloat>)
		case minimumPrimaryColumnWidth(Dynamic<CGFloat>)
		case maximumPrimaryColumnWidth(Dynamic<CGFloat>)
		case shouldShowSecondary(Dynamic<Bool>)

		// 2. Signal bindings are performed on the object after construction.

		// 3. Action bindings are triggered by the object after construction.
		case displayModeButton(SignalInput<BarButtonItemConvertible?>)
		case willChangeDisplayMode(SignalInput<UISplitViewController.DisplayMode>)
		case dismissedSecondary(SignalInput<Void>)

		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case targetDisplayModeForAction((UISplitViewController) -> UISplitViewController.DisplayMode)
		case preferredInterfaceOrientation((UISplitViewController) -> UIInterfaceOrientation)
		case supportedInterfaceOrientations((UISplitViewController) -> UIInterfaceOrientationMask)
		case primaryViewControllerForCollapsing((UISplitViewController) -> UIViewController?)
		case collapseSecondary((UISplitViewController, _ secondaryViewController: UIViewController, _ ontoPrimaryViewController: UIViewController) -> Bool)
		case primaryViewControllerForExpanding((UISplitViewController) -> UIViewController?)
		case separateSecondary((UISplitViewController, _ fromPrimaryViewController: UIViewController) -> UIViewController?)
		case showPrimaryViewController((UISplitViewController, _ show: UIViewController, _ sender: Any?) -> Bool)
		case showSecondaryViewController((UISplitViewController, _ show: UIViewController, _ sender: Any?) -> Bool)
	}

	struct Preparer: ConstructingPreparer {
		typealias EnclosingBinder = SplitViewController
		var linkedPreparer = Inherited.Preparer()
		
		func constructStorage() -> EnclosingBinder.Storage { return Storage() }
		func constructInstance(subclass: EnclosingBinder.Instance.Type) -> EnclosingBinder.Instance { return subclass.init(nibName: nil, bundle: nil) }

		init() {
			self.init(delegateClass: Delegate.self)
		}
		init<Value>(delegateClass: Value.Type) where Value: Delegate {
			self.delegateClass = delegateClass
		}
		let delegateClass: Delegate.Type
		var possibleDelegate: Delegate? = nil
		mutating func delegate() -> Delegate {
			if let d = possibleDelegate {
				return d
			} else {
				let d = delegateClass.init()
				possibleDelegate = d
				return d
			}
		}

		var primary = InitialSubsequent<ViewControllerConvertible>()
		var secondary = InitialSubsequent<ViewControllerConvertible>()

		mutating func prepareBinding(_ binding: Binding) {
			switch binding {
			case .primaryViewController(let x): primary = x.initialSubsequent()
			case .secondaryViewController(let x): secondary = x.initialSubsequent()
			case .willChangeDisplayMode(let x):
				let s = #selector(UISplitViewControllerDelegate.splitViewController(_:willChangeTo:))
				delegate().addSelector(s).willChangeDisplayMode = x
			case .targetDisplayModeForAction(let x):
				let s = #selector(UISplitViewControllerDelegate.targetDisplayModeForAction(in:))
				delegate().addSelector(s).targetDisplayMode = x
			case .preferredInterfaceOrientation(let x):
				let s = #selector(UISplitViewControllerDelegate.splitViewControllerPreferredInterfaceOrientationForPresentation(_:))
				delegate().addSelector(s).preferredInterfaceOrientation = x
			case .supportedInterfaceOrientations(let x):
				let s = #selector(UISplitViewControllerDelegate.splitViewControllerSupportedInterfaceOrientations(_:))
				delegate().addSelector(s).supportedInterfaceOrientations = x
			case .primaryViewControllerForCollapsing(let x):
				let s = #selector(UISplitViewControllerDelegate.primaryViewController(forCollapsing:))
				delegate().addSelector(s).primaryViewControllerForCollapsing = x
			case .primaryViewControllerForExpanding(let x):
				let s = #selector(UISplitViewControllerDelegate.primaryViewController(forExpanding:))
				delegate().addSelector(s).primaryViewControllerForExpanding = x
			case .showPrimaryViewController(let x):
				let s = #selector(UISplitViewControllerDelegate.splitViewController(_:show:sender:))
				delegate().addSelector(s).showPrimaryViewController = x
			case .showSecondaryViewController(let x):
				let s = #selector(UISplitViewControllerDelegate.splitViewController(_:showDetail:sender:))
				delegate().addSelector(s).showSecondaryViewController = x
			case .inheritedBinding(let x): linkedPreparer.prepareBinding(x)
			default: break
			}
		}
		
		mutating func prepareInstance(_ instance: Instance, storage: Storage) {
			precondition(instance.delegate == nil, "Conflicting delegate applied to instance")
			storage.dynamicDelegate = possibleDelegate
			if storage.inUse {
				instance.delegate = storage
			}

			storage.secondaryViewController = secondary.initial()?.uiViewController()
			instance.viewControllers = [primary.initial()?.uiViewController() ?? UIViewController()]
			
			linkedPreparer.prepareInstance(instance, storage: storage)
		}

		func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
			switch binding {
			case .primaryViewController: return primary.resume()?.apply(instance, storage) { i, s, v in i.show(v.uiViewController(), sender: nil) }
			case .secondaryViewController:
				return secondary.resume()?.apply(instance, storage) { i, s, v in
					let vc = v.uiViewController()
					s.secondaryViewController = vc
					i.showDetailViewController(vc, sender: nil)
				}
			case .presentsWithGesture(let x): return x.apply(instance, storage) { i, s, v in i.presentsWithGesture = v }
			case .preferredDisplayMode(let x): return x.apply(instance, storage) { i, s, v in i.preferredDisplayMode = v }
			case .preferredPrimaryColumnWidthFraction(let x): return x.apply(instance, storage) { i, s, v in i.preferredPrimaryColumnWidthFraction = v }
			case .minimumPrimaryColumnWidth(let x): return x.apply(instance, storage) { i, s, v in i.minimumPrimaryColumnWidth = v }
			case .maximumPrimaryColumnWidth(let x): return x.apply(instance, storage) { i, s, v in i.maximumPrimaryColumnWidth = v }
			case .displayModeButton(let x):
				storage.displayModeButton = x
				return nil
			case .dismissedSecondary(let x):
				storage.dismissedSecondary = x
				return nil
			case .shouldShowSecondary(let x):
				return x.apply(instance, storage) { i, s, v in
					if v == true && s.shouldShowSecondary == false, let svc = s.secondaryViewController {
						i.showDetailViewController(svc, sender: nil)
					}
					s.shouldShowSecondary = v
				}
			case .willChangeDisplayMode: return nil
			case .targetDisplayModeForAction: return nil
			case .preferredInterfaceOrientation: return nil
			case .supportedInterfaceOrientations: return nil
			case .primaryViewControllerForCollapsing: return nil
			case .collapseSecondary(let x):
				storage.collapseSecondary = x
				return nil
			case .primaryViewControllerForExpanding: return nil
			case .separateSecondary(let x):
				storage.separateSecondary = x
				return nil
			case .showPrimaryViewController: return nil
			case .showSecondaryViewController: return nil
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: instance, storage: storage)
			}
		}

		mutating func finalizeInstance(_ instance: Instance, storage: Storage) -> Lifetime? {
			let lifetime = linkedPreparer.finalizeInstance(instance, storage: storage)
			if !instance.isCollapsed {
				storage.displayModeButton?.send(value: instance.displayModeButtonItem)
			}
			return lifetime
		}
	}

	class Storage: ViewController.Storage, UISplitViewControllerDelegate {
		var secondaryViewController: UIViewController? = nil
		var shouldShowSecondary: Bool = true
		var displayModeButton: SignalInput<BarButtonItemConvertible?>?
		var dismissedSecondary: SignalInput<Void>?
		
		override var inUse: Bool {
			return true
		}
		
		func collapsedController(_ controller: UINavigationController) {
			if let svc = secondaryViewController, svc === controller {
				dismissedSecondary?.send(value: ())
			}
		}

		override func viewWillAppear(controller: UIViewController, animated: Bool) {
			if let secondary = secondaryViewController, let splitViewController = controller as? UISplitViewController {
				splitViewController.viewControllers.append(secondary)
			}
			super.viewWillAppear(controller: controller, animated: animated)
		}
		
		var collapseSecondary: ((UISplitViewController, _ secondaryViewController: UIViewController, _ ontoPrimaryViewController: UIViewController) -> Bool)?
		func splitViewController(_ splitViewController: UISplitViewController, collapseSecondary secondaryViewController: UIViewController, onto primaryViewController: UIViewController) -> Bool {
			displayModeButton?.send(value: nil)
			return (collapseSecondary?(splitViewController, secondaryViewController, primaryViewController) ?? false) || !shouldShowSecondary
		}
		
		var separateSecondary: ((UISplitViewController, _ fromPrimaryViewController: UIViewController) -> UIViewController?)?
		func splitViewController(_ splitViewController: UISplitViewController, separateSecondaryFrom primaryViewController: UIViewController) -> UIViewController? {
			displayModeButton?.send(value: splitViewController.displayModeButtonItem)
			return separateSecondary?(splitViewController, primaryViewController)
		}
	}

	class Delegate: DynamicDelegate, UISplitViewControllerDelegate {
		required override init() {
			super.init()
		}
		
		var willChangeDisplayMode: SignalInput<UISplitViewController.DisplayMode>?
		func splitViewController(_ svc: UISplitViewController, willChangeTo displayMode: UISplitViewController.DisplayMode) {
			willChangeDisplayMode!.send(value: displayMode)
		}
		
		var targetDisplayMode: ((UISplitViewController) -> UISplitViewController.DisplayMode)?
		func targetDisplayModeForAction(in svc: UISplitViewController) -> UISplitViewController.DisplayMode {
			return targetDisplayMode!(svc)
		}
		
		var preferredInterfaceOrientation: ((UISplitViewController) -> UIInterfaceOrientation)?
		func splitViewControllerPreferredInterfaceOrientationForPresentation(_ splitViewController: UISplitViewController) -> UIInterfaceOrientation {
			return preferredInterfaceOrientation!(splitViewController)
		}
		
		var supportedInterfaceOrientations: ((UISplitViewController) -> UIInterfaceOrientationMask)?
		func splitViewControllerSupportedInterfaceOrientations(_ splitViewController: UISplitViewController) -> UIInterfaceOrientationMask {
			return supportedInterfaceOrientations!(splitViewController)
		}
		
		var primaryViewControllerForCollapsing: ((UISplitViewController) -> UIViewController?)?
		func primaryViewController(forCollapsing splitViewController: UISplitViewController) -> UIViewController? {
			return primaryViewControllerForCollapsing!(splitViewController)
		}
		
		var primaryViewControllerForExpanding: ((UISplitViewController) -> UIViewController?)?
		func primaryViewController(forExpanding splitViewController: UISplitViewController) -> UIViewController? {
			return primaryViewControllerForExpanding!(splitViewController)
		}
		
		var showPrimaryViewController: ((UISplitViewController, _ show: UIViewController, _ sender: Any?) -> Bool)?
		func splitViewController(_ splitViewController: UISplitViewController, show vc: UIViewController, sender: Any?) -> Bool {
			return showPrimaryViewController!(splitViewController, vc, sender)
		}
		
		var showSecondaryViewController: ((UISplitViewController, _ show: UIViewController, _ sender: Any?) -> Bool)?
		func splitViewController(_ splitViewController: UISplitViewController, showDetail vc: UIViewController, sender: Any?) -> Bool {
			return showSecondaryViewController!(splitViewController, vc, sender)
		}
	}
}

extension BindingName where Binding: SplitViewControllerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .splitViewControllerBinding(SplitViewController.Binding.$1(v)) }) }
	static var primaryViewController: BindingName<Dynamic<ViewControllerConvertible>, Binding> { return BindingName<Dynamic<ViewControllerConvertible>, Binding>({ v in .splitViewControllerBinding(SplitViewController.Binding.primaryViewController(v)) }) }
	static var secondaryViewController: BindingName<Dynamic<ViewControllerConvertible>, Binding> { return BindingName<Dynamic<ViewControllerConvertible>, Binding>({ v in .splitViewControllerBinding(SplitViewController.Binding.secondaryViewController(v)) }) }
	static var presentsWithGesture: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .splitViewControllerBinding(SplitViewController.Binding.presentsWithGesture(v)) }) }
	static var preferredDisplayMode: BindingName<Dynamic<UISplitViewController.DisplayMode>, Binding> { return BindingName<Dynamic<UISplitViewController.DisplayMode>, Binding>({ v in .splitViewControllerBinding(SplitViewController.Binding.preferredDisplayMode(v)) }) }
	static var preferredPrimaryColumnWidthFraction: BindingName<Dynamic<CGFloat>, Binding> { return BindingName<Dynamic<CGFloat>, Binding>({ v in .splitViewControllerBinding(SplitViewController.Binding.preferredPrimaryColumnWidthFraction(v)) }) }
	static var minimumPrimaryColumnWidth: BindingName<Dynamic<CGFloat>, Binding> { return BindingName<Dynamic<CGFloat>, Binding>({ v in .splitViewControllerBinding(SplitViewController.Binding.minimumPrimaryColumnWidth(v)) }) }
	static var maximumPrimaryColumnWidth: BindingName<Dynamic<CGFloat>, Binding> { return BindingName<Dynamic<CGFloat>, Binding>({ v in .splitViewControllerBinding(SplitViewController.Binding.maximumPrimaryColumnWidth(v)) }) }
	static var shouldShowSecondary: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .splitViewControllerBinding(SplitViewController.Binding.shouldShowSecondary(v)) }) }
	static var displayModeButton: BindingName<SignalInput<BarButtonItemConvertible?>, Binding> { return BindingName<SignalInput<BarButtonItemConvertible?>, Binding>({ v in .splitViewControllerBinding(SplitViewController.Binding.displayModeButton(v)) }) }
	static var willChangeDisplayMode: BindingName<SignalInput<UISplitViewController.DisplayMode>, Binding> { return BindingName<SignalInput<UISplitViewController.DisplayMode>, Binding>({ v in .splitViewControllerBinding(SplitViewController.Binding.willChangeDisplayMode(v)) }) }
	static var dismissedSecondary: BindingName<SignalInput<Void>, Binding> { return BindingName<SignalInput<Void>, Binding>({ v in .splitViewControllerBinding(SplitViewController.Binding.dismissedSecondary(v)) }) }
	static var targetDisplayModeForAction: BindingName<(UISplitViewController) -> UISplitViewController.DisplayMode, Binding> { return BindingName<(UISplitViewController) -> UISplitViewController.DisplayMode, Binding>({ v in .splitViewControllerBinding(SplitViewController.Binding.targetDisplayModeForAction(v)) }) }
	static var preferredInterfaceOrientation: BindingName<(UISplitViewController) -> UIInterfaceOrientation, Binding> { return BindingName<(UISplitViewController) -> UIInterfaceOrientation, Binding>({ v in .splitViewControllerBinding(SplitViewController.Binding.preferredInterfaceOrientation(v)) }) }
	static var supportedInterfaceOrientations: BindingName<(UISplitViewController) -> UIInterfaceOrientationMask, Binding> { return BindingName<(UISplitViewController) -> UIInterfaceOrientationMask, Binding>({ v in .splitViewControllerBinding(SplitViewController.Binding.supportedInterfaceOrientations(v)) }) }
	static var primaryViewControllerForCollapsing: BindingName<(UISplitViewController) -> UIViewController?, Binding> { return BindingName<(UISplitViewController) -> UIViewController?, Binding>({ v in .splitViewControllerBinding(SplitViewController.Binding.primaryViewControllerForCollapsing(v)) }) }
	static var collapseSecondary: BindingName<(UISplitViewController, _ secondaryViewController: UIViewController, _ ontoPrimaryViewController: UIViewController) -> Bool, Binding> { return BindingName<(UISplitViewController, _ secondaryViewController: UIViewController, _ ontoPrimaryViewController: UIViewController) -> Bool, Binding>({ v in .splitViewControllerBinding(SplitViewController.Binding.collapseSecondary(v)) }) }
	static var primaryViewControllerForExpanding: BindingName<(UISplitViewController) -> UIViewController?, Binding> { return BindingName<(UISplitViewController) -> UIViewController?, Binding>({ v in .splitViewControllerBinding(SplitViewController.Binding.primaryViewControllerForExpanding(v)) }) }
	static var separateSecondary: BindingName<(UISplitViewController, _ fromPrimaryViewController: UIViewController) -> UIViewController?, Binding> { return BindingName<(UISplitViewController, _ fromPrimaryViewController: UIViewController) -> UIViewController?, Binding>({ v in .splitViewControllerBinding(SplitViewController.Binding.separateSecondary(v)) }) }
	static var showPrimaryViewController: BindingName<(UISplitViewController, _ show: UIViewController, _ sender: Any?) -> Bool, Binding> { return BindingName<(UISplitViewController, _ show: UIViewController, _ sender: Any?) -> Bool, Binding>({ v in .splitViewControllerBinding(SplitViewController.Binding.showPrimaryViewController(v)) }) }
	static var showSecondaryViewController: BindingName<(UISplitViewController, _ show: UIViewController, _ sender: Any?) -> Bool, Binding> { return BindingName<(UISplitViewController, _ show: UIViewController, _ sender: Any?) -> Bool, Binding>({ v in .splitViewControllerBinding(SplitViewController.Binding.showSecondaryViewController(v)) }) }
}

protocol SplitViewControllerConvertible: ViewControllerConvertible {
	func uiSplitViewController() -> SplitViewController.Instance
}
extension SplitViewControllerConvertible {
	func uiViewController() -> ViewController.Instance { return uiSplitViewController() }
}
extension SplitViewController.Instance: SplitViewControllerConvertible {
	func uiSplitViewController() -> SplitViewController.Instance { return self }
}

protocol SplitViewControllerBinding: ViewControllerBinding {
	static func splitViewControllerBinding(_ binding: SplitViewController.Binding) -> Self
}

extension SplitViewControllerBinding {
	static func viewControllerBinding(_ binding: ViewController.Binding) -> Self {
		return splitViewControllerBinding(.inheritedBinding(binding))
	}
}

class TextView: ConstructingBinder, TextViewConvertible {
	typealias Instance = UITextView
	typealias Inherited = ScrollView
	
	var state: ConstructingBinderState<Instance, Binding>
	required init(state: ConstructingBinderState<Instance, Binding>) {
		self.state = state
	}
	static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	func uiTextView() -> Instance { return instance() }
	
	enum Binding: TextViewBinding {
		typealias EnclosingBinder = TextView
		static func textViewBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case textInputTraits(Constant<TextInputTraits>)
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case text(Dynamic<String>)
		case attributedText(Dynamic<NSAttributedString>)
		case font(Dynamic<UIFont?>)
		case textColor(Dynamic<UIColor?>)
		case isEditable(Dynamic<Bool>)
		case allowsEditingTextAttributes(Dynamic<Bool>)
		case dataDetectorTypes(Dynamic<UIDataDetectorTypes>)
		case textAlignment(Dynamic<NSTextAlignment>)
		case typingAttributes(Dynamic<[NSAttributedString.Key: Any]>)
		case linkTextAttributes(Dynamic<[NSAttributedString.Key: Any]>)
		case textContainerInset(Dynamic<UIEdgeInsets>)
		case selectedRange(Dynamic<NSRange>)
		case clearsOnInsertion(Dynamic<Bool>)
		case isSelectable(Dynamic<Bool>)
		case inputView(Dynamic<ViewConvertible?>)
		case inputAccessoryView(Dynamic<ViewConvertible?>)
		
		// 2. Signal bindings are performed on the object after construction.
		case scrollRangeToVisible(Signal<NSRange>)
		
		//	3. Action bindings are triggered by the object after construction.
		case didBeginEditing(SignalInput<UITextView>)
		case didEndEditing(SignalInput<UITextView>)
		case didChange(SignalInput<UITextView>)
		case didChangeSelection(SignalInput<UITextView>)
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case shouldBeginEditing((UITextView) -> Bool)
		case shouldEndEditing((UITextView) -> Bool)
		case shouldChangeText((UITextView, NSRange, String) -> Bool)
		@available(iOS 10.0, *)
		case shouldInteractWithAttachment((UITextView, NSTextAttachment, NSRange, UITextItemInteraction) -> Bool)
		@available(iOS 10.0, *)
		case shouldInteractWithURL((UITextView, URL, NSRange, UITextItemInteraction) -> Bool)
	}
	
	struct Preparer: ConstructingPreparer {
		typealias EnclosingBinder = TextView
		var linkedPreparer = Inherited.Preparer()
		
		func constructStorage() -> EnclosingBinder.Storage { return Storage() }
		func constructInstance(subclass: EnclosingBinder.Instance.Type) -> EnclosingBinder.Instance { return subclass.init() }
		
		// Actual delegate construction is handled by the scroll view preparer
		init() {
			self.init(delegateClass: Delegate.self)
		}
		init(delegateClass: Delegate.Type) {
			linkedPreparer = Inherited.Preparer(delegateClass: delegateClass)
		}
		var possibleDelegate: Delegate? { return linkedPreparer.possibleDelegate as? Delegate }
		mutating func delegate() -> Delegate { return linkedPreparer.delegate() as! Delegate }
		
		mutating func prepareBinding(_ binding: Binding) {
			switch binding {
			case .shouldBeginEditing(let x):
				let s = #selector(UITextViewDelegate.textViewShouldBeginEditing(_:))
				delegate().addSelector(s).shouldBeginEditing = x
			case .shouldEndEditing(let x):
				let s = #selector(UITextViewDelegate.textViewShouldEndEditing(_:))
				delegate().addSelector(s).shouldEndEditing = x
			case .didBeginEditing(let x):
				let s = #selector(UITextViewDelegate.textViewDidBeginEditing(_:))
				delegate().addSelector(s).didBeginEditing = x
			case .didEndEditing(let x):
				let s = #selector(UITextViewDelegate.textViewDidEndEditing(_:))
				delegate().addSelector(s).didEndEditing = x
			case .shouldChangeText(let x):
				let s = #selector(UITextViewDelegate.textView(_:shouldChangeTextIn:replacementText:))
				delegate().addSelector(s).shouldChangeText = x
			case .didChange(let x):
				let s = #selector(UITextViewDelegate.textViewDidChange(_:))
				delegate().addSelector(s).didChange = x
			case .didChangeSelection(let x):
				let s = #selector(UITextViewDelegate.textViewDidChangeSelection(_:))
				delegate().addSelector(s).didChangeSelection = x
			case .shouldInteractWithAttachment(let x):
				if #available(iOS 10.0, *) {
					let s = #selector(UITextViewDelegate.textView(_:shouldInteractWith:in:interaction:) as ((UITextViewDelegate) -> (UITextView, NSTextAttachment, NSRange, UITextItemInteraction) -> Bool)?)
					delegate().addSelector(s).shouldInteractWithAttachment = x
				}
			case .shouldInteractWithURL(let x):
				if #available(iOS 10.0, *) {
					let s = #selector(UITextViewDelegate.textView(_:shouldInteractWith:in:interaction:) as ((UITextViewDelegate) -> (UITextView, URL, NSRange, UITextItemInteraction) -> Bool)?)
					delegate().addSelector(s).shouldInteractWithAttachment = x
				}
			case .inheritedBinding(let preceeding): linkedPreparer.prepareBinding(preceeding)
			default: break
			}
		}
		
		func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
			switch binding {
			case .textInputTraits(let x):
				return AggregateLifetime(lifetimes: x.value.bindings.lazy.compactMap { trait in
					switch trait {
					case .autocapitalizationType(let y): return y.apply(instance, storage) { i, s, v in i.autocapitalizationType = v }
					case .autocorrectionType(let y): return y.apply(instance, storage) { i, s, v in i.autocorrectionType = v }
					case .spellCheckingType(let y): return y.apply(instance, storage) { i, s, v in i.spellCheckingType = v }
					case .enablesReturnKeyAutomatically(let y): return y.apply(instance, storage) { i, s, v in i.enablesReturnKeyAutomatically = v }
					case .keyboardAppearance(let y): return y.apply(instance, storage) { i, s, v in i.keyboardAppearance = v }
					case .keyboardType(let y): return y.apply(instance, storage) { i, s, v in i.keyboardType = v }
					case .returnKeyType(let y): return y.apply(instance, storage) { i, s, v in i.returnKeyType = v }
					case .isSecureTextEntry(let y): return y.apply(instance, storage) { i, s, v in i.isSecureTextEntry = v }
					case .textContentType(let y):
						return y.apply(instance, storage) { i, s, v in
							if #available(iOS 10.0, *) {
								i.textContentType = v
							}
						}
					case .smartDashesType(let x):
						return x.apply(instance, storage) { i, s, v in
							if #available(iOS 11.0, *) {
								i.smartDashesType = v
							}
						}
					case .smartQuotesType(let x):
						return x.apply(instance, storage) { i, s, v in
							if #available(iOS 11.0, *) {
								i.smartQuotesType = v
							}
						}
					case .smartInsertDeleteType(let x):
						return x.apply(instance, storage) { i, s, v in
							if #available(iOS 11.0, *) {
								i.smartInsertDeleteType = v
							}
						}
					}
				})
			case .text(let x): return x.apply(instance, storage) { i, s, v in i.text = v }
			case .attributedText(let x): return x.apply(instance, storage) { i, s, v in i.attributedText = v }
			case .font(let x): return x.apply(instance, storage) { i, s, v in i.font = v }
			case .textColor(let x): return x.apply(instance, storage) { i, s, v in i.textColor = v }
			case .isEditable(let x): return x.apply(instance, storage) { i, s, v in i.isEditable = v }
			case .allowsEditingTextAttributes(let x): return x.apply(instance, storage) { i, s, v in i.allowsEditingTextAttributes = v }
			case .dataDetectorTypes(let x): return x.apply(instance, storage) { i, s, v in i.dataDetectorTypes = v }
			case .textAlignment(let x): return x.apply(instance, storage) { i, s, v in i.textAlignment = v }
			case .typingAttributes(let x): return x.apply(instance, storage) { i, s, v in i.typingAttributes = v }
			case .linkTextAttributes(let x): return x.apply(instance, storage) { i, s, v in i.linkTextAttributes = v }
			case .textContainerInset(let x): return x.apply(instance, storage) { i, s, v in i.textContainerInset = v }
			case .selectedRange(let x): return x.apply(instance, storage) { i, s, v in i.selectedRange = v }
			case .clearsOnInsertion(let x): return x.apply(instance, storage) { i, s, v in i.clearsOnInsertion = v }
			case .isSelectable(let x): return x.apply(instance, storage) { i, s, v in i.isSelectable = v }
			case .inputView(let x): return x.apply(instance, storage) { i, s, v in i.inputView = v?.uiView() }
			case .inputAccessoryView(let x): return x.apply(instance, storage) { i, s, v in i.inputAccessoryView = v?.uiView() }
			case .scrollRangeToVisible(let x): return x.apply(instance, storage) { i, s, v in i.scrollRangeToVisible(v) }
			case .shouldBeginEditing: return nil
			case .didBeginEditing: return nil
			case .shouldEndEditing: return nil
			case .didEndEditing: return nil
			case .shouldChangeText: return nil
			case .didChange: return nil
			case .didChangeSelection: return nil
			case .shouldInteractWithAttachment: return nil
			case .shouldInteractWithURL: return nil
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: instance, storage: storage)
			}
		}
	}
	
	class Storage: ScrollView.Storage, UITextViewDelegate {}
	
	class Delegate: ScrollView.Delegate, UITextViewDelegate {
		required init() {
			super.init()
		}
		
		var shouldBeginEditing: ((UITextView) -> Bool)?
		func textViewShouldBeginEditing(_ textView: UITextView) -> Bool {
			return shouldBeginEditing!(textView)
		}
		
		var shouldEndEditing: ((UITextView) -> Bool)?
		func textViewShouldEndEditing(_ textView: UITextView) -> Bool {
			return shouldEndEditing!(textView)
		}
		
		var didBeginEditing: SignalInput<UITextView>?
		func textViewDidBeginEditing(_ textView: UITextView) {
			didBeginEditing!.send(value: textView)
		}
		
		var didEndEditing: SignalInput<UITextView>?
		func textViewDidEndEditing(_ textView: UITextView) {
			didEndEditing!.send(value: textView)
		}
		
		var shouldChangeText: ((UITextView, NSRange, String) -> Bool)?
		func textView(_ textView: UITextView, shouldChangeTextIn range: NSRange, replacementText text: String) -> Bool {
			return shouldChangeText!(textView, range, text)
		}
		
		var didChange: SignalInput<UITextView>?
		func textViewDidChange(_ textView: UITextView) {
			didChange!.send(value: textView)
		}
		
		var didChangeSelection: SignalInput<UITextView>?
		func textViewDidChangeSelection(_ textView: UITextView) {
			didChangeSelection!.send(value: textView)
		}
		
		var shouldInteractWithAttachment: Any?
		@available(iOS 10.0, *)
		func textView(_ textView: UITextView, shouldInteractWith textAttachment: NSTextAttachment, in characterRange: NSRange, interaction: UITextItemInteraction) -> Bool {
			return (shouldInteractWithAttachment as! (UITextView, NSTextAttachment, NSRange, UITextItemInteraction) -> Bool)(textView, textAttachment, characterRange, interaction)
		}
		
		var shouldInteractWithURL: Any?
		@available(iOS 10.0, *)
		func textView(_ textView: UITextView, shouldInteractWith url: URL, in characterRange: NSRange, interaction: UITextItemInteraction) -> Bool {
			return (shouldInteractWithAttachment as! (UITextView, URL, NSRange, UITextItemInteraction) -> Bool)(textView, url, characterRange, interaction)
		}
	}
}

extension BindingName where Binding: TextViewBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .textViewBinding(TextView.Binding.$1(v)) }) }
	static var textInputTraits: BindingName<Constant<TextInputTraits>, Binding> { return BindingName<Constant<TextInputTraits>, Binding>({ v in .textViewBinding(TextView.Binding.textInputTraits(v)) }) }
	static var text: BindingName<Dynamic<String>, Binding> { return BindingName<Dynamic<String>, Binding>({ v in .textViewBinding(TextView.Binding.text(v)) }) }
	static var attributedText: BindingName<Dynamic<NSAttributedString>, Binding> { return BindingName<Dynamic<NSAttributedString>, Binding>({ v in .textViewBinding(TextView.Binding.attributedText(v)) }) }
	static var font: BindingName<Dynamic<UIFont?>, Binding> { return BindingName<Dynamic<UIFont?>, Binding>({ v in .textViewBinding(TextView.Binding.font(v)) }) }
	static var textColor: BindingName<Dynamic<UIColor?>, Binding> { return BindingName<Dynamic<UIColor?>, Binding>({ v in .textViewBinding(TextView.Binding.textColor(v)) }) }
	static var isEditable: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .textViewBinding(TextView.Binding.isEditable(v)) }) }
	static var allowsEditingTextAttributes: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .textViewBinding(TextView.Binding.allowsEditingTextAttributes(v)) }) }
	static var dataDetectorTypes: BindingName<Dynamic<UIDataDetectorTypes>, Binding> { return BindingName<Dynamic<UIDataDetectorTypes>, Binding>({ v in .textViewBinding(TextView.Binding.dataDetectorTypes(v)) }) }
	static var textAlignment: BindingName<Dynamic<NSTextAlignment>, Binding> { return BindingName<Dynamic<NSTextAlignment>, Binding>({ v in .textViewBinding(TextView.Binding.textAlignment(v)) }) }
	static var typingAttributes: BindingName<Dynamic<[NSAttributedString.Key: Any]>, Binding> { return BindingName<Dynamic<[NSAttributedString.Key: Any]>, Binding>({ v in .textViewBinding(TextView.Binding.typingAttributes(v)) }) }
	static var linkTextAttributes: BindingName<Dynamic<[NSAttributedString.Key: Any]>, Binding> { return BindingName<Dynamic<[NSAttributedString.Key: Any]>, Binding>({ v in .textViewBinding(TextView.Binding.linkTextAttributes(v)) }) }
	static var textContainerInset: BindingName<Dynamic<UIEdgeInsets>, Binding> { return BindingName<Dynamic<UIEdgeInsets>, Binding>({ v in .textViewBinding(TextView.Binding.textContainerInset(v)) }) }
	static var selectedRange: BindingName<Dynamic<NSRange>, Binding> { return BindingName<Dynamic<NSRange>, Binding>({ v in .textViewBinding(TextView.Binding.selectedRange(v)) }) }
	static var clearsOnInsertion: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .textViewBinding(TextView.Binding.clearsOnInsertion(v)) }) }
	static var isSelectable: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .textViewBinding(TextView.Binding.isSelectable(v)) }) }
	static var inputView: BindingName<Dynamic<ViewConvertible?>, Binding> { return BindingName<Dynamic<ViewConvertible?>, Binding>({ v in .textViewBinding(TextView.Binding.inputView(v)) }) }
	static var inputAccessoryView: BindingName<Dynamic<ViewConvertible?>, Binding> { return BindingName<Dynamic<ViewConvertible?>, Binding>({ v in .textViewBinding(TextView.Binding.inputAccessoryView(v)) }) }
	static var scrollRangeToVisible: BindingName<Signal<NSRange>, Binding> { return BindingName<Signal<NSRange>, Binding>({ v in .textViewBinding(TextView.Binding.scrollRangeToVisible(v)) }) }
	static var didBeginEditing: BindingName<SignalInput<UITextView>, Binding> { return BindingName<SignalInput<UITextView>, Binding>({ v in .textViewBinding(TextView.Binding.didBeginEditing(v)) }) }
	static var didEndEditing: BindingName<SignalInput<UITextView>, Binding> { return BindingName<SignalInput<UITextView>, Binding>({ v in .textViewBinding(TextView.Binding.didEndEditing(v)) }) }
	static var didChange: BindingName<SignalInput<UITextView>, Binding> { return BindingName<SignalInput<UITextView>, Binding>({ v in .textViewBinding(TextView.Binding.didChange(v)) }) }
	static var didChangeSelection: BindingName<SignalInput<UITextView>, Binding> { return BindingName<SignalInput<UITextView>, Binding>({ v in .textViewBinding(TextView.Binding.didChangeSelection(v)) }) }
	static var shouldBeginEditing: BindingName<(UITextView) -> Bool, Binding> { return BindingName<(UITextView) -> Bool, Binding>({ v in .textViewBinding(TextView.Binding.shouldBeginEditing(v)) }) }
	static var shouldEndEditing: BindingName<(UITextView) -> Bool, Binding> { return BindingName<(UITextView) -> Bool, Binding>({ v in .textViewBinding(TextView.Binding.shouldEndEditing(v)) }) }
	static var shouldChangeText: BindingName<(UITextView, NSRange, String) -> Bool, Binding> { return BindingName<(UITextView, NSRange, String) -> Bool, Binding>({ v in .textViewBinding(TextView.Binding.shouldChangeText(v)) }) }
	@available(iOS 10.0, *)
	static var shouldInteractWithAttachment: BindingName<(UITextView, NSTextAttachment, NSRange, UITextItemInteraction) -> Bool, Binding> { return BindingName<(UITextView, NSTextAttachment, NSRange, UITextItemInteraction) -> Bool, Binding>({ v in .textViewBinding(TextView.Binding.shouldInteractWithAttachment(v)) }) }
	@available(iOS 10.0, *)
	static var shouldInteractWithURL: BindingName<(UITextView, URL, NSRange, UITextItemInteraction) -> Bool, Binding> { return BindingName<(UITextView, URL, NSRange, UITextItemInteraction) -> Bool, Binding>({ v in .textViewBinding(TextView.Binding.shouldInteractWithURL(v)) }) }
}

protocol TextViewConvertible: ScrollViewConvertible {
	func uiTextView() -> TextView.Instance
}
extension TextViewConvertible {
	func uiScrollView() -> ScrollView.Instance { return uiTextView() }
}
extension TextView.Instance: TextViewConvertible {
	func uiTextView() -> TextView.Instance { return self }
}

protocol TextViewBinding: ScrollViewBinding {
	static func textViewBinding(_ binding: TextView.Binding) -> Self
}
extension TextViewBinding {
	static func scrollViewBinding(_ binding: ScrollView.Binding) -> Self {
		return textViewBinding(.inheritedBinding(binding))
	}
}

class PinchGestureRecognizer: ConstructingBinder, PinchGestureRecognizerConvertible {
	typealias Instance = UIPinchGestureRecognizer
	typealias Inherited = GestureRecognizer
	
	var state: ConstructingBinderState<Instance, Binding>
	required init(state: ConstructingBinderState<Instance, Binding>) {
		self.state = state
	}
	static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	func uiPinchGestureRecognizer() -> Instance { return instance() }
	
	enum Binding: PinchGestureRecognizerBinding {
		typealias EnclosingBinder = PinchGestureRecognizer
		static func pinchGestureRecognizerBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case scale(Dynamic<CGFloat>)
		
		// 2. Signal bindings are performed on the object after construction.
		
		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
	
	struct Preparer: ConstructingPreparer {
		typealias EnclosingBinder = PinchGestureRecognizer
		var linkedPreparer = Inherited.Preparer()
		
		func constructStorage() -> EnclosingBinder.Storage { return Storage() }
		func constructInstance(subclass: EnclosingBinder.Instance.Type) -> EnclosingBinder.Instance { return subclass.init() }
		
		init() {}
		
		func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
			switch binding {
			case .scale(let x): return x.apply(instance, storage) { i, s, v in i.scale = v }
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: instance, storage: storage)
			}
		}
	}
	
	typealias Storage = GestureRecognizer.Storage
}

extension BindingName where Binding: PinchGestureRecognizerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .pinchGestureRecognizerBinding(PinchGestureRecognizer.Binding.$1(v)) }) }
	static var scale: BindingName<Dynamic<CGFloat>, Binding> { return BindingName<Dynamic<CGFloat>, Binding>({ v in .pinchGestureRecognizerBinding(PinchGestureRecognizer.Binding.scale(v)) }) }
}

protocol PinchGestureRecognizerConvertible: GestureRecognizerConvertible {
	func uiPinchGestureRecognizer() -> PinchGestureRecognizer.Instance
}
extension PinchGestureRecognizerConvertible {
	func uiGestureRecognizer() -> GestureRecognizer.Instance { return uiPinchGestureRecognizer() }
}
extension PinchGestureRecognizer.Instance: PinchGestureRecognizerConvertible {
	func uiPinchGestureRecognizer() -> PinchGestureRecognizer.Instance { return self }
}

protocol PinchGestureRecognizerBinding: GestureRecognizerBinding {
	static func pinchGestureRecognizerBinding(_ binding: PinchGestureRecognizer.Binding) -> Self
}
extension PinchGestureRecognizerBinding {
	static func gestureRecognizerBinding(_ binding: GestureRecognizer.Binding) -> Self {
		return pinchGestureRecognizerBinding(.inheritedBinding(binding))
	}
}

class ScrollView: ConstructingBinder, ScrollViewConvertible {
	typealias Instance = UIScrollView
	typealias Inherited = View
	
	var state: ConstructingBinderState<Instance, Binding>
	required init(state: ConstructingBinderState<Instance, Binding>) {
		self.state = state
	}
	static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	func uiScrollView() -> Instance { return instance() }
	
	enum Binding: ScrollViewBinding {
		typealias EnclosingBinder = ScrollView
		static func scrollViewBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case panGestureRecognizerStyles(Constant<PanGestureRecognizer>)
		case pinchGestureRecognizerStyles(Constant<PinchGestureRecognizer>)
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case contentOffset(Dynamic<SetOrAnimate<CGPoint>>)
		case contentSize(Dynamic<CGSize>)
		case contentInset(Dynamic<UIEdgeInsets>)
		case isScrollEnabled(Dynamic<Bool>)
		case isDirectionalLockEnabled(Dynamic<Bool>)
		case scrollsToTop(Dynamic<Bool>)
		case isPagingEnabled(Dynamic<Bool>)
		case bounces(Dynamic<Bool>)
		case alwaysBounceVertical(Dynamic<Bool>)
		case alwaysBounceHorizontal(Dynamic<Bool>)
		case canCancelContentTouches(Dynamic<Bool>)
		case delaysContentTouches(Dynamic<Bool>)
		case decelerationRate(Dynamic<UIScrollView.DecelerationRate>)
		case indicatorStyle(Dynamic<UIScrollView.IndicatorStyle>)
		case scrollIndicatorInsets(Dynamic<UIEdgeInsets>)
		case showsHorizontalScrollIndicator(Dynamic<Bool>)
		case showsVerticalScrollIndicator(Dynamic<Bool>)
		case zoomScale(Dynamic<CGFloat>)
		case maximumZoomScale(Dynamic<CGFloat>)
		case minimumZoomScale(Dynamic<CGFloat>)
		case bouncesZoom(Dynamic<Bool>)
		@available(iOS 10.0, *) case refreshControl(Dynamic<UIRefreshControl?>)
		
		// 2. Signal bindings are performed on the object after construction.
		case scrollRectToVisible(Signal<(rect: CGRect, animated: Bool)>)
		case zoom(Signal<(rect: CGRect, animated: Bool)>)
		case flashScrollIndicators(Signal<Void>)
		
		// 3. Action bindings are triggered by the object after construction.
		case userDidScroll(SignalInput<CGPoint>)
		case didScroll(SignalInput<CGPoint>)
		case didZoom(SignalInput<CGFloat>)
		case willBeginDragging(SignalInput<CGPoint>)
		case didEndDragging(SignalInput<(CGPoint, Bool)>)
		case didScrollToTop(SignalInput<Void>)
		case willBeginDecelerating(SignalInput<Void>)
		case didEndDecelerating(SignalInput<CGPoint>)
		case willBeginZooming(SignalInput<CGFloat>)
		case didEndZooming(SignalInput<CGFloat>)
		case didEndScrollingAnimation(SignalInput<CGPoint>)
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case willEndDragging((_ scrollView: UIScrollView, _ velocity: CGPoint, _ targetContentOffset: UnsafeMutablePointer<CGPoint>) -> Void)
		case shouldScrollToTop((_ scrollView: UIScrollView) -> Bool)
		case viewForZooming((_ scrollView: UIScrollView) -> UIView?)
	}
	
	struct Preparer: ConstructingPreparer {
		typealias EnclosingBinder = ScrollView
		var linkedPreparer = Inherited.Preparer()
		
		func constructStorage() -> EnclosingBinder.Storage { return Storage() }
		func constructInstance(subclass: EnclosingBinder.Instance.Type) -> EnclosingBinder.Instance { return subclass.init() }
		
		init() {
			self.init(delegateClass: Delegate.self)
		}
		init<Value>(delegateClass: Value.Type) where Value: Delegate {
			self.delegateClass = delegateClass
		}
		let delegateClass: Delegate.Type
		var possibleDelegate: Delegate? = nil
		mutating func delegate() -> Delegate {
			if let d = possibleDelegate {
				return d
			} else {
				let d = delegateClass.init()
				possibleDelegate = d
				return d
			}
		}
		
		mutating func prepareBinding(_ binding: Binding) {
			switch binding {
			case .userDidScroll(let x):
				let s1 = #selector(UIScrollViewDelegate.scrollViewDidScrollToTop(_:))
				let s2 = #selector(UIScrollViewDelegate.scrollViewDidEndDragging(_:willDecelerate:))
				let s3 = #selector(UIScrollViewDelegate.scrollViewDidEndDecelerating(_:))
				delegate().addSelector(s1).userDidScroll = x
				_ = delegate().addSelector(s2)
				_ = delegate().addSelector(s3)
			case .didScroll(let x):
				let s = #selector(UIScrollViewDelegate.scrollViewDidScroll(_:))
				delegate().addSelector(s).didScroll = x
			case .didZoom(let x):
				let s = #selector(UIScrollViewDelegate.scrollViewDidZoom(_:))
				delegate().addSelector(s).didZoom = x
			case .willBeginDragging(let x):
				let s = #selector(UIScrollViewDelegate.scrollViewWillBeginDragging(_:))
				delegate().addSelector(s).willBeginDragging = x
			case .didEndDragging(let x):
				let s = #selector(UIScrollViewDelegate.scrollViewDidEndDragging(_:willDecelerate:))
				delegate().addSelector(s).didEndDragging = x
			case .didScrollToTop(let x):
				let s = #selector(UIScrollViewDelegate.scrollViewDidScrollToTop(_:))
				delegate().addSelector(s).didScrollToTop = x
			case .willBeginDecelerating(let x):
				let s = #selector(UIScrollViewDelegate.scrollViewWillBeginDecelerating(_:))
				delegate().addSelector(s).willBeginDecelerating = x
			case .didEndDecelerating(let x):
				let s = #selector(UIScrollViewDelegate.scrollViewDidEndDecelerating(_:))
				delegate().addSelector(s).didEndDecelerating = x
			case .willBeginZooming(let x):
				let s = #selector(UIScrollViewDelegate.scrollViewWillBeginZooming(_:with:))
				delegate().addSelector(s).willBeginZooming = x
			case .didEndZooming(let x):
				let s = #selector(UIScrollViewDelegate.scrollViewDidEndZooming(_:with:atScale:))
				delegate().addSelector(s).didEndZooming = x
			case .didEndScrollingAnimation(let x):
				let s = #selector(UIScrollViewDelegate.scrollViewDidEndScrollingAnimation(_:))
				delegate().addSelector(s).didEndScrollingAnimation = x
			case .willEndDragging(let x):
				let s = #selector(UIScrollViewDelegate.scrollViewWillEndDragging(_:withVelocity:targetContentOffset:))
				delegate().addSelector(s).willEndDragging = x
			case .shouldScrollToTop(let x):
				let s = #selector(UIScrollViewDelegate.scrollViewShouldScrollToTop(_:))
				delegate().addSelector(s).shouldScrollToTop = x
			case .viewForZooming(let x):
				let s = #selector(UIScrollViewDelegate.viewForZooming(in:))
				delegate().addSelector(s).forZooming = x
			case .inheritedBinding(let x): linkedPreparer.prepareBinding(x)
			default: break
			}
		}
		
		mutating func prepareInstance(_ instance: Instance, storage: Storage) {
			precondition(instance.delegate == nil, "Conflicting delegate applied to instance")
			storage.dynamicDelegate = possibleDelegate
			if storage.inUse {
				instance.delegate = storage
			}
			
			linkedPreparer.prepareInstance(instance, storage: storage)
		}
		
		func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
			switch binding {
			case .panGestureRecognizerStyles(let x):
				x.value.applyBindings(to: instance.panGestureRecognizer)
				return nil
			case .pinchGestureRecognizerStyles(let x):
				if let pgr = instance.pinchGestureRecognizer {
					x.value.applyBindings(to: pgr)
				}
				return nil
			case .contentOffset(let x): return x.apply(instance, storage) { i, s, v in i.setContentOffset(v.value, animated: v.isAnimated) }
			case .contentSize(let x): return x.apply(instance, storage) { i, s, v in i.contentSize = v }
			case .contentInset(let x): return x.apply(instance, storage) { i, s, v in i.contentInset = v }
			case .isScrollEnabled(let x): return x.apply(instance, storage) { i, s, v in i.isScrollEnabled = v }
			case .isDirectionalLockEnabled(let x): return x.apply(instance, storage) { i, s, v in i.isDirectionalLockEnabled = v }
			case .scrollsToTop(let x): return x.apply(instance, storage) { i, s, v in i.scrollsToTop = v }
			case .isPagingEnabled(let x): return x.apply(instance, storage) { i, s, v in i.isPagingEnabled = v }
			case .bounces(let x): return x.apply(instance, storage) { i, s, v in i.bounces = v }
			case .alwaysBounceVertical(let x): return x.apply(instance, storage) { i, s, v in i.alwaysBounceVertical = v }
			case .alwaysBounceHorizontal(let x): return x.apply(instance, storage) { i, s, v in i.alwaysBounceHorizontal = v }
			case .canCancelContentTouches(let x): return x.apply(instance, storage) { i, s, v in i.canCancelContentTouches = v }
			case .delaysContentTouches(let x): return x.apply(instance, storage) { i, s, v in i.delaysContentTouches = v }
			case .decelerationRate(let x): return x.apply(instance, storage) { i, s, v in i.decelerationRate = v }
			case .indicatorStyle(let x): return x.apply(instance, storage) { i, s, v in i.indicatorStyle = v }
			case .scrollIndicatorInsets(let x): return x.apply(instance, storage) { i, s, v in i.scrollIndicatorInsets = v }
			case .showsHorizontalScrollIndicator(let x): return x.apply(instance, storage) { i, s, v in i.showsHorizontalScrollIndicator = v }
			case .showsVerticalScrollIndicator(let x): return x.apply(instance, storage) { i, s, v in i.showsVerticalScrollIndicator = v }
			case .zoomScale(let x): return x.apply(instance, storage) { i, s, v in i.zoomScale = v }
			case .maximumZoomScale(let x): return x.apply(instance, storage) { i, s, v in i.maximumZoomScale = v }
			case .minimumZoomScale(let x): return x.apply(instance, storage) { i, s, v in i.minimumZoomScale = v }
			case .bouncesZoom(let x): return x.apply(instance, storage) { i, s, v in i.bouncesZoom = v }
			case .refreshControl(let x):
				return x.apply(instance, storage) { i, s, v in
					if #available(iOS 10.0, *) {
						i.refreshControl = v
					}
				}
			case .scrollRectToVisible(let x): return x.apply(instance, storage) { i, s, v in i.scrollRectToVisible(v.rect, animated: v.animated) }
			case .zoom(let x): return x.apply(instance, storage) { i, s, v in i.zoom(to: v.rect, animated: v.animated) }
			case .flashScrollIndicators(let x): return x.apply(instance, storage) { i, s, v in i.flashScrollIndicators() }
			case .userDidScroll: return nil
			case .didScroll: return nil
			case .didZoom: return nil
			case .willBeginDragging: return nil
			case .didEndDragging: return nil
			case .didScrollToTop: return nil
			case .willBeginDecelerating: return nil
			case .didEndDecelerating: return nil
			case .willBeginZooming: return nil
			case .didEndZooming: return nil
			case .didEndScrollingAnimation: return nil
			case .willEndDragging: return nil
			case .shouldScrollToTop: return nil
			case .viewForZooming: return nil
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: instance, storage: storage)
			}
		}
	}
	
	class Storage: View.Storage, UIScrollViewDelegate {}
	
	class Delegate: DynamicDelegate, UIScrollViewDelegate {
		required override init() {
			super.init()
		}
		
		var userDidScroll: SignalInput<CGPoint>?
		
		var didEndDragging: SignalInput<(CGPoint, Bool)>?
		func scrollViewDidEndDragging(_ scrollView: UIScrollView, willDecelerate decelerate: Bool) {
			if !decelerate {
				userDidScroll?.send(value: scrollView.contentOffset)
			}
			didEndDragging?.send(value: (scrollView.contentOffset, decelerate))
		}
		
		var didScrollToTop: SignalInput<Void>?
		func scrollViewDidScrollToTop(_ scrollView: UIScrollView) {
			userDidScroll?.send(value: scrollView.contentOffset)
			didScrollToTop!.send(value: ())
		}
		
		var didEndDecelerating: SignalInput<CGPoint>?
		func scrollViewDidEndDecelerating(_ scrollView: UIScrollView) {
			userDidScroll?.send(value: scrollView.contentOffset)
			didEndDecelerating?.send(value: scrollView.contentOffset)
		}
		
		var didScroll: SignalInput<CGPoint>?
		func scrollViewDidScroll(_ scrollView: UIScrollView) {
			didScroll?.send(value: scrollView.contentOffset)
		}
		
		var didZoom: SignalInput<CGFloat>?
		func scrollViewDidZoom(_ scrollView: UIScrollView) {
			didZoom!.send(value: scrollView.zoomScale)
		}
		
		var willBeginDragging: SignalInput<CGPoint>?
		func scrollViewWillBeginDragging(_ scrollView: UIScrollView) {
			willBeginDragging!.send(value: scrollView.contentOffset)
		}
		
		var willBeginDecelerating: SignalInput<Void>?
		func scrollViewWillBeginDecelerating(_ scrollView: UIScrollView) {
			willBeginDecelerating!.send(value: ())
		}
		
		var willBeginZooming: SignalInput<CGFloat>?
		func scrollViewWillBeginZooming(_ scrollView: UIScrollView, with view: UIView?) {
			willBeginZooming!.send(value: scrollView.contentScaleFactor)
		}
		
		var didEndZooming: SignalInput<CGFloat>?
		func scrollViewDidEndZooming(_ scrollView: UIScrollView, with view: UIView?, atScale scale: CGFloat) {
			didEndZooming!.send(value: scale)
		}
		
		var didEndScrollingAnimation: SignalInput<CGPoint>?
		func scrollViewDidEndScrollingAnimation(_ scrollView: UIScrollView) {
			didEndScrollingAnimation!.send(value: scrollView.contentOffset)
		}
		
		var willEndDragging: ((_ scrollView: UIScrollView, _ velocity: CGPoint, _ targetContentOffset: UnsafeMutablePointer<CGPoint>) -> Void)?
		func scrollViewWillEndDragging(_ scrollView: UIScrollView, withVelocity velocity: CGPoint, targetContentOffset: UnsafeMutablePointer<CGPoint>) {
			willEndDragging!(scrollView, velocity, targetContentOffset)
		}
		
		var shouldScrollToTop: ((_ scrollView: UIScrollView) -> Bool)?
		func scrollViewShouldScrollToTop(_ scrollView: UIScrollView) -> Bool {
			return shouldScrollToTop!(scrollView)
		}
		
		var forZooming: ((_ scrollView: UIScrollView) -> UIView?)?
		func viewForZooming(in scrollView: UIScrollView) -> UIView? {
			return forZooming!(scrollView)
		}
	}
}

extension BindingName where Binding: ScrollViewBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .scrollViewBinding(ScrollView.Binding.$1(v)) }) }
	static var panGestureRecognizerStyles: BindingName<Constant<PanGestureRecognizer>, Binding> { return BindingName<Constant<PanGestureRecognizer>, Binding>({ v in .scrollViewBinding(ScrollView.Binding.panGestureRecognizerStyles(v)) }) }
	static var pinchGestureRecognizerStyles: BindingName<Constant<PinchGestureRecognizer>, Binding> { return BindingName<Constant<PinchGestureRecognizer>, Binding>({ v in .scrollViewBinding(ScrollView.Binding.pinchGestureRecognizerStyles(v)) }) }
	static var contentOffset: BindingName<Dynamic<SetOrAnimate<CGPoint>>, Binding> { return BindingName<Dynamic<SetOrAnimate<CGPoint>>, Binding>({ v in .scrollViewBinding(ScrollView.Binding.contentOffset(v)) }) }
	static var contentSize: BindingName<Dynamic<CGSize>, Binding> { return BindingName<Dynamic<CGSize>, Binding>({ v in .scrollViewBinding(ScrollView.Binding.contentSize(v)) }) }
	static var contentInset: BindingName<Dynamic<UIEdgeInsets>, Binding> { return BindingName<Dynamic<UIEdgeInsets>, Binding>({ v in .scrollViewBinding(ScrollView.Binding.contentInset(v)) }) }
	static var isScrollEnabled: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .scrollViewBinding(ScrollView.Binding.isScrollEnabled(v)) }) }
	static var isDirectionalLockEnabled: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .scrollViewBinding(ScrollView.Binding.isDirectionalLockEnabled(v)) }) }
	static var scrollsToTop: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .scrollViewBinding(ScrollView.Binding.scrollsToTop(v)) }) }
	static var isPagingEnabled: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .scrollViewBinding(ScrollView.Binding.isPagingEnabled(v)) }) }
	static var bounces: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .scrollViewBinding(ScrollView.Binding.bounces(v)) }) }
	static var alwaysBounceVertical: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .scrollViewBinding(ScrollView.Binding.alwaysBounceVertical(v)) }) }
	static var alwaysBounceHorizontal: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .scrollViewBinding(ScrollView.Binding.alwaysBounceHorizontal(v)) }) }
	static var canCancelContentTouches: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .scrollViewBinding(ScrollView.Binding.canCancelContentTouches(v)) }) }
	static var delaysContentTouches: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .scrollViewBinding(ScrollView.Binding.delaysContentTouches(v)) }) }
	static var decelerationRate: BindingName<Dynamic<UIScrollView.DecelerationRate>, Binding> { return BindingName<Dynamic<UIScrollView.DecelerationRate>, Binding>({ v in .scrollViewBinding(ScrollView.Binding.decelerationRate(v)) }) }
	static var indicatorStyle: BindingName<Dynamic<UIScrollView.IndicatorStyle>, Binding> { return BindingName<Dynamic<UIScrollView.IndicatorStyle>, Binding>({ v in .scrollViewBinding(ScrollView.Binding.indicatorStyle(v)) }) }
	static var scrollIndicatorInsets: BindingName<Dynamic<UIEdgeInsets>, Binding> { return BindingName<Dynamic<UIEdgeInsets>, Binding>({ v in .scrollViewBinding(ScrollView.Binding.scrollIndicatorInsets(v)) }) }
	static var showsHorizontalScrollIndicator: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .scrollViewBinding(ScrollView.Binding.showsHorizontalScrollIndicator(v)) }) }
	static var showsVerticalScrollIndicator: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .scrollViewBinding(ScrollView.Binding.showsVerticalScrollIndicator(v)) }) }
	static var zoomScale: BindingName<Dynamic<CGFloat>, Binding> { return BindingName<Dynamic<CGFloat>, Binding>({ v in .scrollViewBinding(ScrollView.Binding.zoomScale(v)) }) }
	static var maximumZoomScale: BindingName<Dynamic<CGFloat>, Binding> { return BindingName<Dynamic<CGFloat>, Binding>({ v in .scrollViewBinding(ScrollView.Binding.maximumZoomScale(v)) }) }
	static var minimumZoomScale: BindingName<Dynamic<CGFloat>, Binding> { return BindingName<Dynamic<CGFloat>, Binding>({ v in .scrollViewBinding(ScrollView.Binding.minimumZoomScale(v)) }) }
	static var bouncesZoom: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .scrollViewBinding(ScrollView.Binding.bouncesZoom(v)) }) }
	@available(iOS 10.0, *) static var refreshControl: BindingName<Dynamic<UIRefreshControl?>, Binding> { return BindingName<Dynamic<UIRefreshControl?>, Binding>({ v in .scrollViewBinding(ScrollView.Binding.refreshControl(v)) }) }
	static var scrollRectToVisible: BindingName<Signal<(rect: CGRect, animated: Bool)>, Binding> { return BindingName<Signal<(rect: CGRect, animated: Bool)>, Binding>({ v in .scrollViewBinding(ScrollView.Binding.scrollRectToVisible(v)) }) }
	static var zoom: BindingName<Signal<(rect: CGRect, animated: Bool)>, Binding> { return BindingName<Signal<(rect: CGRect, animated: Bool)>, Binding>({ v in .scrollViewBinding(ScrollView.Binding.zoom(v)) }) }
	static var flashScrollIndicators: BindingName<Signal<Void>, Binding> { return BindingName<Signal<Void>, Binding>({ v in .scrollViewBinding(ScrollView.Binding.flashScrollIndicators(v)) }) }
	static var userDidScroll: BindingName<SignalInput<CGPoint>, Binding> { return BindingName<SignalInput<CGPoint>, Binding>({ v in .scrollViewBinding(ScrollView.Binding.userDidScroll(v)) }) }
	static var didScroll: BindingName<SignalInput<CGPoint>, Binding> { return BindingName<SignalInput<CGPoint>, Binding>({ v in .scrollViewBinding(ScrollView.Binding.didScroll(v)) }) }
	static var didZoom: BindingName<SignalInput<CGFloat>, Binding> { return BindingName<SignalInput<CGFloat>, Binding>({ v in .scrollViewBinding(ScrollView.Binding.didZoom(v)) }) }
	static var willBeginDragging: BindingName<SignalInput<CGPoint>, Binding> { return BindingName<SignalInput<CGPoint>, Binding>({ v in .scrollViewBinding(ScrollView.Binding.willBeginDragging(v)) }) }
	static var didEndDragging: BindingName<SignalInput<(CGPoint, Bool)>, Binding> { return BindingName<SignalInput<(CGPoint, Bool)>, Binding>({ v in .scrollViewBinding(ScrollView.Binding.didEndDragging(v)) }) }
	static var didScrollToTop: BindingName<SignalInput<Void>, Binding> { return BindingName<SignalInput<Void>, Binding>({ v in .scrollViewBinding(ScrollView.Binding.didScrollToTop(v)) }) }
	static var willBeginDecelerating: BindingName<SignalInput<Void>, Binding> { return BindingName<SignalInput<Void>, Binding>({ v in .scrollViewBinding(ScrollView.Binding.willBeginDecelerating(v)) }) }
	static var didEndDecelerating: BindingName<SignalInput<CGPoint>, Binding> { return BindingName<SignalInput<CGPoint>, Binding>({ v in .scrollViewBinding(ScrollView.Binding.didEndDecelerating(v)) }) }
	static var willBeginZooming: BindingName<SignalInput<CGFloat>, Binding> { return BindingName<SignalInput<CGFloat>, Binding>({ v in .scrollViewBinding(ScrollView.Binding.willBeginZooming(v)) }) }
	static var didEndZooming: BindingName<SignalInput<CGFloat>, Binding> { return BindingName<SignalInput<CGFloat>, Binding>({ v in .scrollViewBinding(ScrollView.Binding.didEndZooming(v)) }) }
	static var didEndScrollingAnimation: BindingName<SignalInput<CGPoint>, Binding> { return BindingName<SignalInput<CGPoint>, Binding>({ v in .scrollViewBinding(ScrollView.Binding.didEndScrollingAnimation(v)) }) }
	static var willEndDragging: BindingName<(_ scrollView: UIScrollView, _ velocity: CGPoint, _ targetContentOffset: UnsafeMutablePointer<CGPoint>) -> Void, Binding> { return BindingName<(_ scrollView: UIScrollView, _ velocity: CGPoint, _ targetContentOffset: UnsafeMutablePointer<CGPoint>) -> Void, Binding>({ v in .scrollViewBinding(ScrollView.Binding.willEndDragging(v)) }) }
	static var shouldScrollToTop: BindingName<(_ scrollView: UIScrollView) -> Bool, Binding> { return BindingName<(_ scrollView: UIScrollView) -> Bool, Binding>({ v in .scrollViewBinding(ScrollView.Binding.shouldScrollToTop(v)) }) }
	static var viewForZooming: BindingName<(_ scrollView: UIScrollView) -> UIView?, Binding> { return BindingName<(_ scrollView: UIScrollView) -> UIView?, Binding>({ v in .scrollViewBinding(ScrollView.Binding.viewForZooming(v)) }) }
}

protocol ScrollViewConvertible: ViewConvertible {
	func uiScrollView() -> ScrollView.Instance
}
extension ScrollViewConvertible {
	func uiView() -> View.Instance { return uiScrollView() }
}
extension ScrollView.Instance: ScrollViewConvertible {
	func uiScrollView() -> ScrollView.Instance { return self }
}

protocol ScrollViewBinding: ViewBinding {
	static func scrollViewBinding(_ binding: ScrollView.Binding) -> Self
}
extension ScrollViewBinding {
	static func viewBinding(_ binding: View.Binding) -> Self {
		return scrollViewBinding(.inheritedBinding(binding))
	}
}

class GestureRecognizer: ConstructingBinder, GestureRecognizerConvertible {
	typealias Instance = UIGestureRecognizer
	typealias Inherited = BaseBinder
	
	var state: ConstructingBinderState<Instance, Binding>
	required init(state: ConstructingBinderState<Instance, Binding>) {
		self.state = state
	}
	static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	func uiGestureRecognizer() -> Instance { return instance() }
	
	enum Binding: GestureRecognizerBinding {
		typealias EnclosingBinder = GestureRecognizer
		static func gestureRecognizerBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)

		// 1. Value bindings may be applied at construction and may subsequently change.
		case cancelsTouchesInView(Dynamic<Bool>)
		case delaysTouchesBegan(Dynamic<Bool>)
		case delaysTouchesEnded(Dynamic<Bool>)
		case allowedPressTypes(Dynamic<[NSNumber]>)
		case allowedTouchTypes(Dynamic<[NSNumber]>)
		@available(iOS 9.2, *) case requiresExclusiveTouchType(Dynamic<Bool>)

		// 2. Signal bindings are performed on the object after construction.

		// 3. Action bindings are triggered by the object after construction.
		case action(SignalInput<Void>)

		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case shouldBegin((UIGestureRecognizer) -> Bool)
		case shouldReceiveTouch((UIGestureRecognizer, UITouch) -> Bool)
		case shouldRecognizeSimultanously((UIGestureRecognizer, UIGestureRecognizer) -> Bool)
		case shouldRequireFailure((UIGestureRecognizer, _ of: UIGestureRecognizer) -> Bool)
		case shouldBeRequiredToFail((UIGestureRecognizer, _ by: UIGestureRecognizer) -> Bool)
		case shouldReceivePress((UIGestureRecognizer, UIPress) -> Bool)
	}

	struct Preparer: ConstructingPreparer {
		typealias EnclosingBinder = GestureRecognizer
		var linkedPreparer = Inherited.Preparer()
		
		func constructStorage() -> EnclosingBinder.Storage { return Storage() }
		func constructInstance(subclass: EnclosingBinder.Instance.Type) -> EnclosingBinder.Instance { return subclass.init() }

		init() {
			self.init(delegateClass: Delegate.self)
		}
		init<Value>(delegateClass: Value.Type) where Value: Delegate {
			self.delegateClass = delegateClass
		}
		let delegateClass: Delegate.Type
		var possibleDelegate: Delegate? = nil
		mutating func delegate() -> Delegate {
			if let d = possibleDelegate {
				return d
			} else {
				let d = delegateClass.init()
				possibleDelegate = d
				return d
			}
		}
		
		mutating func prepareBinding(_ binding: Binding) {
			switch binding {
			case .shouldBegin(let x):
				let s = #selector(UIGestureRecognizerDelegate.gestureRecognizerShouldBegin(_:))
				delegate().addSelector(s).shouldBegin = x
			case .shouldReceiveTouch(let x):
				let s = #selector(UIGestureRecognizerDelegate.gestureRecognizer(_:shouldReceive:) as((UIGestureRecognizerDelegate) -> (UIGestureRecognizer, UITouch) -> Bool)?)
				delegate().addSelector(s).shouldReceiveTouch = x
			case .shouldRecognizeSimultanously(let x):
				let s = #selector(UIGestureRecognizerDelegate.gestureRecognizer(_:shouldRecognizeSimultaneouslyWith:))
				delegate().addSelector(s).shouldRecognizeSimultanously = x
			case .shouldRequireFailure(let x):
				let s = #selector(UIGestureRecognizerDelegate.gestureRecognizer(_:shouldRequireFailureOf:))
				delegate().addSelector(s).shouldRequireFailure = x
			case .shouldBeRequiredToFail(let x):
				let s = #selector(UIGestureRecognizerDelegate.gestureRecognizer(_:shouldBeRequiredToFailBy:))
				delegate().addSelector(s).shouldBeRequiredToFail = x
			case .shouldReceivePress(let x):
				let s = #selector(UIGestureRecognizerDelegate.gestureRecognizer(_:shouldReceive:) as((UIGestureRecognizerDelegate) -> (UIGestureRecognizer, UIPress) -> Bool)?)
				delegate().addSelector(s).shouldReceivePress = x
			case .inheritedBinding(let preceeding): linkedPreparer.prepareBinding(preceeding)
			default: break
			}
		}

		mutating func prepareInstance(_ instance: Instance, storage: Storage) {
			precondition(instance.delegate == nil, "Conflicting delegate applied to instance")
			storage.dynamicDelegate = possibleDelegate
			if storage.inUse {
				instance.delegate = storage
			}

			linkedPreparer.prepareInstance(instance, storage: storage)
		}

		func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
			switch binding {
			case .action(let x):
				let target = SignalActionTarget()
				instance.addTarget(target, action: SignalActionTarget.selector)
				return target.signal.map { _ in () }.cancellableBind(to: x)
			case .cancelsTouchesInView(let x): return x.apply(instance, storage) { i, s, v in i.cancelsTouchesInView = v }
			case .delaysTouchesBegan(let x): return x.apply(instance, storage) { i, s, v in i.delaysTouchesBegan = v }
			case .delaysTouchesEnded(let x): return x.apply(instance, storage) { i, s, v in i.delaysTouchesEnded = v }
			case .allowedPressTypes(let x): return x.apply(instance, storage) { i, s, v in i.allowedPressTypes = v }
			case .allowedTouchTypes(let x): return x.apply(instance, storage) { i, s, v in i.allowedTouchTypes = v }
			case .requiresExclusiveTouchType(let x):
				return x.apply(instance, storage) { i, s, v in
					if #available(iOS 9.2, *) {
						i.requiresExclusiveTouchType = v
					}
				}
			case .shouldBegin: return nil
			case .shouldReceiveTouch: return nil
			case .shouldRecognizeSimultanously: return nil
			case .shouldRequireFailure: return nil
			case .shouldBeRequiredToFail: return nil
			case .shouldReceivePress: return nil
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: instance, storage: storage)
			}
		}
	}

	class Storage: ObjectBinderStorage, UIGestureRecognizerDelegate {}

	class Delegate: DynamicDelegate, UIGestureRecognizerDelegate {
		required override init() {
			super.init()
		}
		
		var shouldBegin: ((UIGestureRecognizer) -> Bool)?
		func gestureRecognizerShouldBegin(_ gestureRecognizer: UIGestureRecognizer) -> Bool {
			return shouldBegin!(gestureRecognizer)
		}
		
		var shouldReceiveTouch: ((UIGestureRecognizer, UITouch) -> Bool)?
		func gestureRecognizer(_ gestureRecognizer: UIGestureRecognizer, shouldReceive touch: UITouch) -> Bool {
			return shouldReceiveTouch!(gestureRecognizer, touch)
		}
		
		var shouldRecognizeSimultanously: ((UIGestureRecognizer, UIGestureRecognizer) -> Bool)?
		func gestureRecognizer(_ gestureRecognizer: UIGestureRecognizer, shouldRecognizeSimultaneouslyWith otherGestureRecognizer: UIGestureRecognizer) -> Bool {
			return shouldRecognizeSimultanously!(gestureRecognizer, otherGestureRecognizer)
		}
		
		var shouldRequireFailure: ((UIGestureRecognizer, _ of: UIGestureRecognizer) -> Bool)?
		func gestureRecognizer(_ gestureRecognizer: UIGestureRecognizer, shouldRequireFailureOf otherGestureRecognizer: UIGestureRecognizer) -> Bool {
			return shouldRequireFailure!(gestureRecognizer, otherGestureRecognizer)
		}
		
		var shouldBeRequiredToFail: ((UIGestureRecognizer, _ by: UIGestureRecognizer) -> Bool)?
		func gestureRecognizer(_ gestureRecognizer: UIGestureRecognizer, shouldBeRequiredToFailBy otherGestureRecognizer: UIGestureRecognizer) -> Bool {
			return shouldBeRequiredToFail!(gestureRecognizer, otherGestureRecognizer)
		}
		
		var shouldReceivePress: ((UIGestureRecognizer, UIPress) -> Bool)?
		func gestureRecognizer(_ gestureRecognizer: UIGestureRecognizer, shouldReceive press: UIPress) -> Bool {
			return shouldReceivePress!(gestureRecognizer, press)
		}
	}
}

extension BindingName where Binding: GestureRecognizerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .gestureRecognizerBinding(GestureRecognizer.Binding.$1(v)) }) }
	static var cancelsTouchesInView: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .gestureRecognizerBinding(GestureRecognizer.Binding.cancelsTouchesInView(v)) }) }
	static var delaysTouchesBegan: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .gestureRecognizerBinding(GestureRecognizer.Binding.delaysTouchesBegan(v)) }) }
	static var delaysTouchesEnded: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .gestureRecognizerBinding(GestureRecognizer.Binding.delaysTouchesEnded(v)) }) }
	static var allowedPressTypes: BindingName<Dynamic<[NSNumber]>, Binding> { return BindingName<Dynamic<[NSNumber]>, Binding>({ v in .gestureRecognizerBinding(GestureRecognizer.Binding.allowedPressTypes(v)) }) }
	static var allowedTouchTypes: BindingName<Dynamic<[NSNumber]>, Binding> { return BindingName<Dynamic<[NSNumber]>, Binding>({ v in .gestureRecognizerBinding(GestureRecognizer.Binding.allowedTouchTypes(v)) }) }
	@available(iOS 9.2, *) static var requiresExclusiveTouchType: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .gestureRecognizerBinding(GestureRecognizer.Binding.requiresExclusiveTouchType(v)) }) }
	static var action: BindingName<SignalInput<Void>, Binding> { return BindingName<SignalInput<Void>, Binding>({ v in .gestureRecognizerBinding(GestureRecognizer.Binding.action(v)) }) }
	static var shouldBegin: BindingName<(UIGestureRecognizer) -> Bool, Binding> { return BindingName<(UIGestureRecognizer) -> Bool, Binding>({ v in .gestureRecognizerBinding(GestureRecognizer.Binding.shouldBegin(v)) }) }
	static var shouldReceiveTouch: BindingName<(UIGestureRecognizer, UITouch) -> Bool, Binding> { return BindingName<(UIGestureRecognizer, UITouch) -> Bool, Binding>({ v in .gestureRecognizerBinding(GestureRecognizer.Binding.shouldReceiveTouch(v)) }) }
	static var shouldRecognizeSimultanously: BindingName<(UIGestureRecognizer, UIGestureRecognizer) -> Bool, Binding> { return BindingName<(UIGestureRecognizer, UIGestureRecognizer) -> Bool, Binding>({ v in .gestureRecognizerBinding(GestureRecognizer.Binding.shouldRecognizeSimultanously(v)) }) }
	static var shouldRequireFailure: BindingName<(UIGestureRecognizer, _ of: UIGestureRecognizer) -> Bool, Binding> { return BindingName<(UIGestureRecognizer, _ of: UIGestureRecognizer) -> Bool, Binding>({ v in .gestureRecognizerBinding(GestureRecognizer.Binding.shouldRequireFailure(v)) }) }
	static var shouldBeRequiredToFail: BindingName<(UIGestureRecognizer, _ by: UIGestureRecognizer) -> Bool, Binding> { return BindingName<(UIGestureRecognizer, _ by: UIGestureRecognizer) -> Bool, Binding>({ v in .gestureRecognizerBinding(GestureRecognizer.Binding.shouldBeRequiredToFail(v)) }) }
	static var shouldReceivePress: BindingName<(UIGestureRecognizer, UIPress) -> Bool, Binding> { return BindingName<(UIGestureRecognizer, UIPress) -> Bool, Binding>({ v in .gestureRecognizerBinding(GestureRecognizer.Binding.shouldReceivePress(v)) }) }
}

protocol GestureRecognizerConvertible {
	func uiGestureRecognizer() -> GestureRecognizer.Instance
}
extension GestureRecognizer.Instance: GestureRecognizerConvertible {
	func uiGestureRecognizer() -> GestureRecognizer.Instance { return self }
}

protocol GestureRecognizerBinding: BaseBinding {
	static func gestureRecognizerBinding(_ binding: GestureRecognizer.Binding) -> Self
}

extension GestureRecognizerBinding {
	static func baseBinding(_ binding: BaseBinder.Binding) -> Self {
		return gestureRecognizerBinding(.inheritedBinding(binding))
	}
}

class Control: ConstructingBinder, ControlConvertible {
	typealias Instance = UIControl
	typealias Inherited = View
	
	var state: ConstructingBinderState<Instance, Binding>
	required init(state: ConstructingBinderState<Instance, Binding>) {
		self.state = state
	}
	static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	func uiControl() -> Instance { return instance() }
	
	enum Binding: ControlBinding {
		typealias EnclosingBinder = Control
		static func controlBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case isEnabled(Dynamic<Bool>)
		case isSelected(Dynamic<Bool>)
		case isHighlighted(Dynamic<Bool>)
		case contentVerticalAlignment(Dynamic<UIControl.ContentVerticalAlignment>)
		case contentHorizontalAlignment(Dynamic<UIControl.ContentHorizontalAlignment>)
		case actions(Dynamic<ControlActions>)
		
		// 2. Signal bindings are performed on the object after construction.
		
		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
	
	struct Preparer: ConstructingPreparer {
		typealias EnclosingBinder = Control
		var linkedPreparer = Inherited.Preparer()
		
		func constructStorage() -> EnclosingBinder.Storage { return Storage() }
		func constructInstance(subclass: EnclosingBinder.Instance.Type) -> EnclosingBinder.Instance { return subclass.init() }
		
		init() {}
		
		func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
			switch binding {
			case .isEnabled(let x): return x.apply(instance, storage) { i, s, v in i.isEnabled = v }
			case .isSelected(let x): return x.apply(instance, storage) { i, s, v in i.isSelected = v }
			case .isHighlighted(let x): return x.apply(instance, storage) { i, s, v in i.isHighlighted = v }
			case .contentVerticalAlignment(let x): return x.apply(instance, storage) { i, s, v in i.contentVerticalAlignment = v }
			case .contentHorizontalAlignment(let x): return x.apply(instance, storage) { i, s, v in i.contentHorizontalAlignment = v }
			case .actions(let x):
				var previous: ScopedValues<UIControl.Event, ControlAction>? = nil
				var junctions = [Lifetime]()
				var lifetime = x.apply(instance, storage) { i, s, v in
					if let p = previous {
						for c in p.pairs {
							i.removeTarget(nil, action: nil, for: c.0)
						}
					}
					previous = v
					junctions.removeAll()
					for c in v.pairs {
						switch c.1 {
						case .firstResponder(let s):
							i.addTarget(nil, action: s, for: c.0)
						case .singleTarget(let s):
							let target = SignalControlEventActionTarget()
							i.addTarget(target, action: target.selector, for: c.0)
							junctions += target.signal.cancellableBind(to: s)
						}
					}
				}
				return OnDelete {
					for var j in junctions {
						j.cancel()
					}
					lifetime?.cancel()
				}
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: instance, storage: storage)
			}
		}
	}
	
	typealias Storage = View.Storage
}

extension BindingName where Binding: ControlBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .controlBinding(Control.Binding.$1(v)) }) }
	static var isEnabled: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .controlBinding(Control.Binding.isEnabled(v)) }) }
	static var isSelected: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .controlBinding(Control.Binding.isSelected(v)) }) }
	static var isHighlighted: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .controlBinding(Control.Binding.isHighlighted(v)) }) }
	static var contentVerticalAlignment: BindingName<Dynamic<UIControl.ContentVerticalAlignment>, Binding> { return BindingName<Dynamic<UIControl.ContentVerticalAlignment>, Binding>({ v in .controlBinding(Control.Binding.contentVerticalAlignment(v)) }) }
	static var contentHorizontalAlignment: BindingName<Dynamic<UIControl.ContentHorizontalAlignment>, Binding> { return BindingName<Dynamic<UIControl.ContentHorizontalAlignment>, Binding>({ v in .controlBinding(Control.Binding.contentHorizontalAlignment(v)) }) }
	static var actions: BindingName<Dynamic<ControlActions>, Binding> { return BindingName<Dynamic<ControlActions>, Binding>({ v in .controlBinding(Control.Binding.actions(v)) }) }
}

extension BindingName where Binding: ControlBinding, Binding.EnclosingBinder: BinderChain {
	// Additional helper binding names
	
	// This is the *preferred* construction of actions.
	static func action<I: SignalInputInterface>(_ scope: UIControl.Event) -> BindingName<I, Binding> where I.InputValue == Void {
		return BindingName<I, Binding>({ (v: I) -> Binding in
			Binding.controlBinding(Control.Binding.actions(.constant(ControlActions.value(.singleTarget(Input<(UIControl, UIEvent)>().map { c, e in () }.bind(to: v.input)), for: scope))))
		})
	}
	static func action<I: SignalInputInterface, Value>(_ scope: UIControl.Event, _ keyPath: KeyPath<Binding.EnclosingBinder.Instance, Value>) -> BindingName<I, Binding> where I.InputValue == Value {
		return BindingName<I, Binding> { (v: I) -> Binding in
			Binding.controlBinding(
				Control.Binding.actions(
					.constant(
						ControlActions.value(
							.singleTarget(
								Input<(UIControl, UIEvent)>()
									.map { c, e -> Value in
										(c as! Binding.EnclosingBinder.Instance)[keyPath: keyPath]
									}.bind(to: v.input)
							),
							for: scope
						)
					)
				)
			)
		}
	}
}

protocol ControlConvertible: ViewConvertible {
	func uiControl() -> Control.Instance
}
extension ControlConvertible {
	func uiView() -> View.Instance { return uiControl() }
}
extension Control.Instance: ControlConvertible {
	func uiControl() -> Control.Instance { return self }
}

protocol ControlBinding: ViewBinding {
	static func controlBinding(_ binding: Control.Binding) -> Self
}
extension ControlBinding {
	static func viewBinding(_ binding: View.Binding) -> Self {
		return controlBinding(.inheritedBinding(binding))
	}
}

enum ControlAction {
	case firstResponder(Selector)
	case singleTarget(SignalInput<(UIControl, UIEvent)>)
}

typealias ControlActions = ScopedValues<UIControl.Event, ControlAction>

extension ScopedValues where Scope == UIControl.State {
	static func normal(_ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: .normal)
	}
	static func highlighted(_ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: .highlighted)
	}
	static func disabled(_ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: .disabled)
	}
	static func selected(_ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: .selected)
	}
	@available(iOS 9.0, *)
	static func focused(_ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: .focused)
	}
	static func application(_ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: .application)
	}
	static func reserved(_ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: .reserved)
	}
}

class SignalControlEventActionTarget: NSObject {
	private var signalInput: SignalInput<(UIControl, UIEvent)>? = nil
	
	// Ownership note: we are owned by the output signal so we only weakly retain it.
	private weak var signalOutput: SignalMulti<(UIControl, UIEvent)>? = nil
	
	/// The `signal` emits the actions received
	var signal: SignalMulti<(UIControl, UIEvent)> {
		// If there's a current signal output, return it
		if let so = signalOutput {
			return so
		}
		
		// Otherwise, create a new one
		let (i, s) = Signal<(UIControl, UIEvent)>.create { s in
			// Instead of using a `isContinuous` transform, use a `buffer` to do the same thing while capturing `self` so that we're owned by the signal.
			s.customActivation { (b: inout Array<(UIControl, UIEvent)>, e: inout Error?, r: Result<(UIControl, UIEvent)>) in
				withExtendedLifetime(self) {}
				switch r {
				case .success(let v):
					b.removeAll(keepingCapacity: true)
					b.append(v)
				case .failure(let err):
					e = err
				}
			}
		}
		self.signalInput = i
		self.signalOutput = s
		return s
	}
	
	/// Receiver function for the target-action events
	///
	/// - Parameter sender: typical target-action "sender" parameter
	@IBAction func cwlSignalAction(_ sender: UIControl, forEvent event: UIEvent) {
		_ = signalInput?.send(value: (sender, event))
	}
	
	/// Convenience accessor for `#selector(SignalActionTarget<Value>.action(_:))`
	var selector: Selector { return #selector(SignalControlEventActionTarget.cwlSignalAction(_:forEvent:)) }
}


class Button: ConstructingBinder, ButtonConvertible {
	typealias Instance = UIButton
	typealias Inherited = Control
	
	var state: ConstructingBinderState<Instance, Binding>
	required init(state: ConstructingBinderState<Instance, Binding>) {
		self.state = state
	}
	static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	func uiButton() -> Instance { return instance() }
	
	enum Binding: ButtonBinding {
		typealias EnclosingBinder = Button
		static func buttonBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case type(Constant<UIButton.ButtonType>)
		case titleLabel(Constant<Label>)
		case imageView(Constant<ImageView>)
	
		// 1. Value bindings may be applied at construction and may subsequently change.
		case adjustsImageWhenHighlighted(Dynamic<Bool>)
		case adjustsImageWhenDisabled(Dynamic<Bool>)
		case showsTouchWhenHighlighted(Dynamic<Bool>)
		case contentEdgeInsets(Dynamic<UIEdgeInsets>)
		case titleEdgeInsets(Dynamic<UIEdgeInsets>)
		case imageEdgeInsets(Dynamic<UIEdgeInsets>)
		
		case title(Dynamic<ScopedValues<UIControl.State, String?>>)
		case titleColor(Dynamic<ScopedValues<UIControl.State, UIColor?>>)
		case titleShadowColor(Dynamic<ScopedValues<UIControl.State, UIColor?>>)
		case attributedTitle(Dynamic<ScopedValues<UIControl.State, NSAttributedString?>>)
		case backgroundImage(Dynamic<ScopedValues<UIControl.State, UIImage?>>)
		case image(Dynamic<ScopedValues<UIControl.State, UIImage?>>)
		
		// 2. Signal bindings are performed on the object after construction.
		
		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
	
	struct Preparer: ConstructingPreparer {
		typealias EnclosingBinder = Button
		var linkedPreparer = Inherited.Preparer()
		
		func constructStorage() -> EnclosingBinder.Storage { return Storage() }
		func constructInstance(subclass: EnclosingBinder.Instance.Type) -> EnclosingBinder.Instance {
			return subclass.init(type: type)
		}
		
		var type: UIButton.ButtonType = .roundedRect
		
		init() {}
		
		mutating func prepareBinding(_ binding: Binding) {
			switch binding {
			case .type(let x): type = x.value
			case .inheritedBinding(let x): linkedPreparer.prepareBinding(x)
			default: break
			}
		}
		
		func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
			switch binding {
			case .titleLabel(let x):
				if let tl = instance.titleLabel {
					x.value.applyBindings(to: tl)
				}
				return nil
			case .imageView(let x):
				if let iv = instance.imageView {
					x.value.applyBindings(to: iv)
				}
				return nil
			case .type: return nil
			case .title(let x):
				var previous: ScopedValues<UIControl.State, String?>? = nil
				return x.apply(instance, storage) { i, s, v in
					if let p = previous {
						for c in p.pairs {
							i.setTitle(nil, for: c.0)
						}
					}
					previous = v
					for c in v.pairs {
						i.setTitle(c.1, for: c.0)
					}
				}
			case .titleColor(let x):
				var previous: ScopedValues<UIControl.State, UIColor?>? = nil
				return x.apply(instance, storage) { i, s, v in
					if let p = previous {
						for c in p.pairs {
							i.setTitleColor(nil, for: c.0)
						}
					}
					previous = v
					for c in v.pairs {
						i.setTitleColor(c.1, for: c.0)
					}
				}
			case .titleShadowColor(let x):
				var previous: ScopedValues<UIControl.State, UIColor?>? = nil
				return x.apply(instance, storage) { i, s, v in
					if let p = previous {
						for c in p.pairs {
							i.setTitleShadowColor(nil, for: c.0)
						}
					}
					previous = v
					for c in v.pairs {
						i.setTitleShadowColor(c.1, for: c.0)
					}
				}
			case .attributedTitle(let x):
				var previous: ScopedValues<UIControl.State, NSAttributedString?>? = nil
				return x.apply(instance, storage) { i, s, v in
					if let p = previous {
						for c in p.pairs {
							i.setAttributedTitle(nil, for: c.0)
						}
					}
					previous = v
					for c in v.pairs {
						i.setAttributedTitle(c.1, for: c.0)
					}
				}
			case .backgroundImage(let x):
				var previous: ScopedValues<UIControl.State, UIImage?>? = nil
				return x.apply(instance, storage) { i, s, v in
					if let p = previous {
						for c in p.pairs {
							i.setBackgroundImage(nil, for: c.0)
						}
					}
					previous = v
					for c in v.pairs {
						i.setBackgroundImage(c.1, for: c.0)
					}
				}
			case .image(let x):
				var previous: ScopedValues<UIControl.State, UIImage?>? = nil
				return x.apply(instance, storage) { i, s, v in
					if let p = previous {
						for c in p.pairs {
							i.setImage(nil, for: c.0)
						}
					}
					previous = v
					for c in v.pairs {
						i.setImage(c.1, for: c.0)
					}
				}
			case .adjustsImageWhenHighlighted(let x): return x.apply(instance, storage) { i, s, v in i.adjustsImageWhenHighlighted = v }
			case .adjustsImageWhenDisabled(let x): return x.apply(instance, storage) { i, s, v in i.adjustsImageWhenDisabled = v }
			case .showsTouchWhenHighlighted(let x): return x.apply(instance, storage) { i, s, v in i.showsTouchWhenHighlighted = v }
			case .contentEdgeInsets(let x): return x.apply(instance, storage) { i, s, v in i.contentEdgeInsets = v }
			case .titleEdgeInsets(let x): return x.apply(instance, storage) { i, s, v in i.titleEdgeInsets = v }
			case .imageEdgeInsets(let x): return x.apply(instance, storage) { i, s, v in i.imageEdgeInsets = v }
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: instance, storage: storage)
			}
		}
	}
	
	typealias Storage = Control.Storage
}

extension BindingName where Binding: ButtonBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .buttonBinding(Button.Binding.$1(v)) }) }
	static var type: BindingName<Constant<UIButton.ButtonType>, Binding> { return BindingName<Constant<UIButton.ButtonType>, Binding>({ v in .buttonBinding(Button.Binding.type(v)) }) }
	static var titleLabel: BindingName<Constant<Label>, Binding> { return BindingName<Constant<Label>, Binding>({ v in .buttonBinding(Button.Binding.titleLabel(v)) }) }
	static var imageView: BindingName<Constant<ImageView>, Binding> { return BindingName<Constant<ImageView>, Binding>({ v in .buttonBinding(Button.Binding.imageView(v)) }) }
	static var adjustsImageWhenHighlighted: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .buttonBinding(Button.Binding.adjustsImageWhenHighlighted(v)) }) }
	static var adjustsImageWhenDisabled: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .buttonBinding(Button.Binding.adjustsImageWhenDisabled(v)) }) }
	static var showsTouchWhenHighlighted: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .buttonBinding(Button.Binding.showsTouchWhenHighlighted(v)) }) }
	static var contentEdgeInsets: BindingName<Dynamic<UIEdgeInsets>, Binding> { return BindingName<Dynamic<UIEdgeInsets>, Binding>({ v in .buttonBinding(Button.Binding.contentEdgeInsets(v)) }) }
	static var titleEdgeInsets: BindingName<Dynamic<UIEdgeInsets>, Binding> { return BindingName<Dynamic<UIEdgeInsets>, Binding>({ v in .buttonBinding(Button.Binding.titleEdgeInsets(v)) }) }
	static var imageEdgeInsets: BindingName<Dynamic<UIEdgeInsets>, Binding> { return BindingName<Dynamic<UIEdgeInsets>, Binding>({ v in .buttonBinding(Button.Binding.imageEdgeInsets(v)) }) }
	static var title: BindingName<Dynamic<ScopedValues<UIControl.State, String?>>, Binding> { return BindingName<Dynamic<ScopedValues<UIControl.State, String?>>, Binding>({ v in .buttonBinding(Button.Binding.title(v)) }) }
	static var titleColor: BindingName<Dynamic<ScopedValues<UIControl.State, UIColor?>>, Binding> { return BindingName<Dynamic<ScopedValues<UIControl.State, UIColor?>>, Binding>({ v in .buttonBinding(Button.Binding.titleColor(v)) }) }
	static var titleShadowColor: BindingName<Dynamic<ScopedValues<UIControl.State, UIColor?>>, Binding> { return BindingName<Dynamic<ScopedValues<UIControl.State, UIColor?>>, Binding>({ v in .buttonBinding(Button.Binding.titleShadowColor(v)) }) }
	static var attributedTitle: BindingName<Dynamic<ScopedValues<UIControl.State, NSAttributedString?>>, Binding> { return BindingName<Dynamic<ScopedValues<UIControl.State, NSAttributedString?>>, Binding>({ v in .buttonBinding(Button.Binding.attributedTitle(v)) }) }
	static var backgroundImage: BindingName<Dynamic<ScopedValues<UIControl.State, UIImage?>>, Binding> { return BindingName<Dynamic<ScopedValues<UIControl.State, UIImage?>>, Binding>({ v in .buttonBinding(Button.Binding.backgroundImage(v)) }) }
	static var image: BindingName<Dynamic<ScopedValues<UIControl.State, UIImage?>>, Binding> { return BindingName<Dynamic<ScopedValues<UIControl.State, UIImage?>>, Binding>({ v in .buttonBinding(Button.Binding.image(v)) }) }
}

protocol ButtonConvertible: ControlConvertible {
	func uiButton() -> Button.Instance
}
extension ButtonConvertible {
	func uiControl() -> Control.Instance { return uiButton() }
}
extension Button.Instance: ButtonConvertible {
	func uiButton() -> Button.Instance { return self }
}

protocol ButtonBinding: ControlBinding {
	static func buttonBinding(_ binding: Button.Binding) -> Self
}

extension ButtonBinding {
	static func controlBinding(_ binding: Control.Binding) -> Self {
		return buttonBinding(.inheritedBinding(binding))
	}
}


struct TextInputTraits {
	let bindings: [Binding]
	init(bindings: [Binding]) {
		self.bindings = bindings
	}
	init(_ bindings: Binding...) {
		self.init(bindings: bindings)
	}
	
	enum Binding {
		case autocapitalizationType(Dynamic<UITextAutocapitalizationType>)
		case autocorrectionType(Dynamic<UITextAutocorrectionType>)
		case spellCheckingType(Dynamic<UITextSpellCheckingType>)
		case enablesReturnKeyAutomatically(Dynamic<Bool>)
		case keyboardAppearance(Dynamic<UIKeyboardAppearance>)
		case keyboardType(Dynamic<UIKeyboardType>)
		case returnKeyType(Dynamic<UIReturnKeyType>)
		@available(iOS 11.0, *)
		case smartDashesType(Dynamic<UITextSmartDashesType>)
		@available(iOS 11.0, *)
		case smartQuotesType(Dynamic<UITextSmartQuotesType>)
		@available(iOS 11.0, *)
		case smartInsertDeleteType(Dynamic<UITextSmartInsertDeleteType>)
		case isSecureTextEntry(Dynamic<Bool>)
		@available(iOS 10.0, *)
		case textContentType(Dynamic<UITextContentType>)
	}
}

extension BindingName where Binding == TextInputTraits.Binding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in TextInputTraits.$1(v) }) }
	static var autocapitalizationType: BindingName<Dynamic<UITextAutocapitalizationType>, Binding> { return BindingName<Dynamic<UITextAutocapitalizationType>, Binding>({ v in TextInputTraits.Binding.autocapitalizationType(v) }) }
	static var autocorrectionType: BindingName<Dynamic<UITextAutocorrectionType>, Binding> { return BindingName<Dynamic<UITextAutocorrectionType>, Binding>({ v in TextInputTraits.Binding.autocorrectionType(v) }) }
	static var spellCheckingType: BindingName<Dynamic<UITextSpellCheckingType>, Binding> { return BindingName<Dynamic<UITextSpellCheckingType>, Binding>({ v in TextInputTraits.Binding.spellCheckingType(v) }) }
	static var enablesReturnKeyAutomatically: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in TextInputTraits.Binding.enablesReturnKeyAutomatically(v) }) }
	static var keyboardAppearance: BindingName<Dynamic<UIKeyboardAppearance>, Binding> { return BindingName<Dynamic<UIKeyboardAppearance>, Binding>({ v in TextInputTraits.Binding.keyboardAppearance(v) }) }
	static var keyboardType: BindingName<Dynamic<UIKeyboardType>, Binding> { return BindingName<Dynamic<UIKeyboardType>, Binding>({ v in TextInputTraits.Binding.keyboardType(v) }) }
	static var returnKeyType: BindingName<Dynamic<UIReturnKeyType>, Binding> { return BindingName<Dynamic<UIReturnKeyType>, Binding>({ v in TextInputTraits.Binding.returnKeyType(v) }) }
	@available(iOS 11.0, *)
	static var smartDashesType: BindingName<Dynamic<UITextSmartDashesType>, Binding> { return BindingName<Dynamic<UITextSmartDashesType>, Binding>({ v in TextInputTraits.Binding.smartDashesType(v) }) }
	@available(iOS 11.0, *)
	static var smartQuotesType: BindingName<Dynamic<UITextSmartQuotesType>, Binding> { return BindingName<Dynamic<UITextSmartQuotesType>, Binding>({ v in TextInputTraits.Binding.smartQuotesType(v) }) }
	@available(iOS 11.0, *)
	static var smartInsertDeleteType: BindingName<Dynamic<UITextSmartInsertDeleteType>, Binding> { return BindingName<Dynamic<UITextSmartInsertDeleteType>, Binding>({ v in TextInputTraits.Binding.smartInsertDeleteType(v) }) }
	static var isSecureTextEntry: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in TextInputTraits.Binding.isSecureTextEntry(v) }) }
	@available(iOS 10.0, *)
	static var textContentType: BindingName<Dynamic<UITextContentType>, Binding> { return BindingName<Dynamic<UITextContentType>, Binding>({ v in TextInputTraits.Binding.textContentType(v) }) }
}

class ViewController: ConstructingBinder, ViewControllerConvertible {
	typealias Instance = UIViewController
	typealias Inherited = BaseBinder
	
	var state: ConstructingBinderState<Instance, Binding>
	required init(state: ConstructingBinderState<Instance, Binding>) {
		self.state = state
	}
	static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	func uiViewController() -> Instance { return instance() }
	
	enum Binding: ViewControllerBinding {
		typealias EnclosingBinder = ViewController
		static func viewControllerBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case navigationItem(Constant<NavigationItem>)
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case view(Dynamic<ViewConvertible>)
		@available(iOS, introduced: 7.0, deprecated: 11.0, message: "This property exists to access layout guides prior to iOS 11. On iOS 11 and later, use .layout on the .view")
		case layout(Dynamic<Layout>)
		case title(Dynamic<String>)
		case preferredContentSize(Dynamic<CGSize>)
		case modalPresentationStyle(Dynamic<UIModalPresentationStyle>)
		case modalTransitionStyle(Dynamic<UIModalTransitionStyle>)
		case isModalInPopover(Dynamic<Bool>)
		case definesPresentationContext(Dynamic<Bool>)
		case providesPresentationContextTransitionStyle(Dynamic<Bool>)
		case transitioningDelegate(Dynamic<UIViewControllerTransitioningDelegate>)
		case edgesForExtendedLayout(Dynamic<UIRectEdge>)
		case extendedLayoutIncludesOpaqueBars(Dynamic<Bool>)
		case automaticallyAdjustsScrollViewInsets(Dynamic<Bool>)
		case restorationIdentifier(Dynamic<String?>)
		case restorationClass(Dynamic<UIViewControllerRestoration.Type?>)
		case modalPresentationCapturesStatusBarAppearance(Dynamic<Bool>)
		case hidesBottomBarWhenPushed(Dynamic<Bool>)
		case toolbarItems(Dynamic<SetOrAnimate<[BarButtonItemConvertible]>>)
		case tabBarItem(Dynamic<TabBarItemConvertible>)
		case isEditing(Signal<SetOrAnimate<Bool>>)
		
		// 2. Signal bindings are performed on the object after construction.
		case present(Signal<ModalPresentation>)
		
		// 3. Action bindings are triggered by the object after construction.
		case traitCollectionDidChange(SignalInput<(previous: UITraitCollection?, new: UITraitCollection)>)
		case willAppear(SignalInput<Bool>)
		case didAppear(SignalInput<Bool>)
		case didDisappear(SignalInput<Bool>)
		case willDisappear(SignalInput<Bool>)
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case loadView(() -> ViewConvertible)
		case didReceiveMemoryWarning(() -> Void)
	}
	
	struct Preparer: ConstructingPreparer {
		typealias EnclosingBinder = ViewController
		var linkedPreparer = Inherited.Preparer()
		
		func constructStorage() -> EnclosingBinder.Storage { return Storage() }
		func constructInstance(subclass: EnclosingBinder.Instance.Type) -> EnclosingBinder.Instance { return subclass.init(nibName: nil, bundle: nil) }
		
		init() {}
		
		var view: InitialSubsequent<ViewConvertible>?
		var loadView: (() -> ViewConvertible)?
		
		mutating func prepareBinding(_ binding: Binding) {
			switch binding {
			case .loadView(let x):
				assert(view == nil, "Construct the view using either .loadView or .view, not both.")
				loadView = x
			case .view(let x):
				assert(loadView == nil, "Construct the view using either .loadView or .view, not both.")
				view = x.initialSubsequent()
			case .inheritedBinding(let preceeding): linkedPreparer.prepareBinding(preceeding)
			default: break
			}
		}
		
		mutating func prepareInstance(_ instance: Instance, storage: Storage) {
			// The loadView function needs to be ready in case one of the bindings triggers a view load.
			if let v = view?.initial() {
				storage.view = v
				instance.setBinderStorage(storage)
			} else if let lv = loadView {
				storage.viewConstructor = lv
				instance.setBinderStorage(storage)
			}
		}
		
		func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
			switch binding {
			case .loadView: return nil
			case .view:
				return view?.subsequent.flatMap { $0.apply(instance, storage) { i, s, v in
					storage.view = v
					if i.isViewLoaded {
						i.view = v.uiView()
					}
				} }
			case .layout(let x): return x.apply(instance, storage) { i, s, v in i.applyLayout(v) }
			case .title(let x): return x.apply(instance, storage) { i, s, v in i.title = v }
			case .preferredContentSize(let x): return x.apply(instance, storage) { i, s, v in i.preferredContentSize = v }
			case .modalPresentationStyle(let x): return x.apply(instance, storage) { i, s, v in i.modalPresentationStyle = v }
			case .modalTransitionStyle(let x): return x.apply(instance, storage) { i, s, v in i.modalTransitionStyle = v }
			case .isModalInPopover(let x): return x.apply(instance, storage) { i, s, v in i.isModalInPopover = v }
			case .definesPresentationContext(let x): return x.apply(instance, storage) { i, s, v in i.definesPresentationContext = v }
			case .providesPresentationContextTransitionStyle(let x): return x.apply(instance, storage) { i, s, v in i.providesPresentationContextTransitionStyle = v }
			case .transitioningDelegate(let x): return x.apply(instance, storage) { i, s, v in i.transitioningDelegate = v }
			case .edgesForExtendedLayout(let x): return x.apply(instance, storage) { i, s, v in i.edgesForExtendedLayout = v }
			case .extendedLayoutIncludesOpaqueBars(let x): return x.apply(instance, storage) { i, s, v in i.extendedLayoutIncludesOpaqueBars = v }
			case .automaticallyAdjustsScrollViewInsets(let x):
				return x.apply(instance, storage) { i, s, v in
					i.automaticallyAdjustsScrollViewInsets = v
				}
			case .restorationIdentifier(let x): return x.apply(instance, storage) { i, s, v in i.restorationIdentifier = v }
			case .restorationClass(let x): return x.apply(instance, storage) { i, s, v in i.restorationClass = v }
			case .modalPresentationCapturesStatusBarAppearance(let x): return x.apply(instance, storage) { i, s, v in i.modalPresentationCapturesStatusBarAppearance = v }
			case .hidesBottomBarWhenPushed(let x): return x.apply(instance, storage) { i, s, v in i.hidesBottomBarWhenPushed = v }
			case .toolbarItems(let x): return x.apply(instance, storage) { i, s, v in i.setToolbarItems(v.value.map { $0.uiBarButtonItem() }, animated: v.isAnimated) }
			case .tabBarItem(let x): return x.apply(instance, storage) { i, s, v in i.tabBarItem = v.uiTabBarItem() }
			case .isEditing(let x): return x.apply(instance, storage) { i, s, v in i.setEditing(v.value, animated: v.isAnimated) }
			case .present(let x):
				return x.apply(instance, storage) { i, s, v in
					s.queuedModalPresentations.append(v)
					s.processModalPresentations(viewController: i)
				}
			case .navigationItem(let x):
				x.value.applyBindings(to: instance.navigationItem)
				return nil
			case .traitCollectionDidChange(let x):
				storage.traitCollectionDidChange = x
				return x
			case .willAppear(let x):
				storage.willAppear = x
				return x
			case .didDisappear(let x):
				storage.didDisappear = x
				return x
			case .didAppear(let x):
				storage.didAppear = x
				return x
			case .willDisappear(let x):
				storage.willDisappear = x
				return x
			case .didReceiveMemoryWarning(let x):
				storage.didReceiveMemoryWarning = x
				return nil
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: (), storage: ())
			}
		}
		
		mutating func finalizeInstance(_ instance: Instance, storage: Storage) -> Lifetime? {
			let lifetime = linkedPreparer.finalizeInstance((), storage: ())
			
			// Send the initial "traitsCollection" once construction is complete.
			if let tcdc = storage.traitCollectionDidChange {
				tcdc.send(value: (previous: nil, new: instance.traitCollection))
			}
			return lifetime
		}
	}
	
	class Storage: ObjectBinderStorage {
		var traitCollectionDidChange: SignalInput<(previous: UITraitCollection?, new: UITraitCollection)>?
		var didDisappear: SignalInput<Bool>?
		var willAppear: SignalInput<Bool>?
		var willDisappear: SignalInput<Bool>?
		var didAppear: SignalInput<Bool>?
		var queuedModalPresentations: [ModalPresentation] = []
		var presentationInProgress: Bool = false
		var view: ViewConvertible?
		var viewConstructor: (() -> ViewConvertible?)?
		var didReceiveMemoryWarning: (() -> Void)?
		
		override var inUse: Bool {
			return super.inUse || view != nil || viewConstructor != nil || didReceiveMemoryWarning != nil
		}
		
		private static var isSwizzled: Bool = false
		private static let ensureSwizzled: () = {
			if isSwizzled {
				assertionFailure("This line should be unreachable")
				return
			}
			
			let loadViewSource = class_getInstanceMethod(UIViewController.self, #selector(UIViewController.loadView))!
			let loadViewDestination = class_getInstanceMethod(ViewController.Storage.self, #selector(ViewController.Storage.swizzledLoadView))!
			method_exchangeImplementations(loadViewSource, loadViewDestination)
			
			let traitCollectionDidChangeSource = class_getInstanceMethod(UIViewController.self, #selector(UIViewController.traitCollectionDidChange(_:)))!
			let traitCollectionDidChangeDestination = class_getInstanceMethod(ViewController.Storage.self, #selector(ViewController.Storage.swizzledTraitCollectionDidChange(_:)))!
			method_exchangeImplementations(traitCollectionDidChangeSource, traitCollectionDidChangeDestination)
			
			let willAppearSource = class_getInstanceMethod(UIViewController.self, #selector(UIViewController.viewWillAppear(_:)))!
			let willAppearDestination = class_getInstanceMethod(ViewController.Storage.self, #selector(ViewController.Storage.swizzledViewWillAppear(_:)))!
			method_exchangeImplementations(willAppearSource, willAppearDestination)
			
			let didDisappearSource = class_getInstanceMethod(UIViewController.self, #selector(UIViewController.viewDidDisappear(_:)))!
			let didDisappearDestination = class_getInstanceMethod(ViewController.Storage.self, #selector(ViewController.Storage.swizzledViewDidDisappear(_:)))!
			method_exchangeImplementations(didDisappearSource, didDisappearDestination)
			
			let didAppearSource = class_getInstanceMethod(UIViewController.self, #selector(UIViewController.viewDidAppear(_:)))!
			let didAppearDestination = class_getInstanceMethod(ViewController.Storage.self, #selector(ViewController.Storage.swizzledViewDidAppear(_:)))!
			method_exchangeImplementations(didAppearSource, didAppearDestination)
			
			let willDisappearSource = class_getInstanceMethod(UIViewController.self, #selector(UIViewController.viewWillDisappear(_:)))!
			let willDisappearDestination = class_getInstanceMethod(ViewController.Storage.self, #selector(ViewController.Storage.swizzledViewWillDisappear(_:)))!
			method_exchangeImplementations(willDisappearSource, willDisappearDestination)
			
			let didReceiveMemoryWarningSource = class_getInstanceMethod(UIViewController.self, #selector(UIViewController.didReceiveMemoryWarning))!
			let didReceiveMemoryWarningDestination = class_getInstanceMethod(ViewController.Storage.self, #selector(ViewController.Storage.swizzledDidReceiveMemoryWarning))!
			method_exchangeImplementations(didReceiveMemoryWarningSource, didReceiveMemoryWarningDestination)
			
			isSwizzled = true
		}()
		
		override init() {
			ViewController.Storage.ensureSwizzled
			super.init()
		}
		
		func processModalPresentations(viewController: UIViewController) {
			if presentationInProgress {
				return
			}
			if let mp = queuedModalPresentations.first {
				if let vc = mp.viewController {
					guard viewController.view.window != nil else {
						presentationInProgress = false
						return
					}
					presentationInProgress = true
					viewController.present(vc.uiViewController(), animated: mp.animated) {
						mp.completion?.send(value: ())
						self.queuedModalPresentations.removeFirst()
						self.presentationInProgress = false
						self.processModalPresentations(viewController: viewController)
					}
				} else {
					presentationInProgress = true
					if let vc = viewController.presentedViewController, !vc.isBeingDismissed {
						vc.dismiss(animated: mp.animated, completion: { () -> Void in
							mp.completion?.send(value: ())
							self.queuedModalPresentations.removeFirst()
							self.presentationInProgress = false
							self.processModalPresentations(viewController: viewController)
						})
					} else {
						mp.completion?.send(value: ())
						self.queuedModalPresentations.removeFirst()
						self.presentationInProgress = false
						self.processModalPresentations(viewController: viewController)
					}
				}
			}
		}
		
		func traitCollectionDidChange(_ previous: UITraitCollection?, _ new: UITraitCollection) {
			traitCollectionDidChange?.send(value: (previous: previous, new: new))
		}
		
		func viewWillAppear(controller: UIViewController, animated: Bool) {
			willAppear?.send(value: animated)
		}
		
		func viewDidDisappear(controller: UIViewController, animated: Bool) {
			didDisappear?.send(value: animated)
		}
		
		func viewDidAppear(controller: UIViewController, animated: Bool) {
			didAppear?.send(value: animated)
		}
		
		func viewWillDisappear(controller: UIViewController, animated: Bool) {
			willDisappear?.send(value: animated)
		}
		
		func controllerDidReceiveMemoryWarning(controller: UIViewController) {
			didReceiveMemoryWarning?()
			
			if viewConstructor != nil, let view = controller.viewIfLoaded, view.window == nil {
				controller.view = nil
			}
		}
		
		func loadView(for viewController: UIViewController) -> Bool {
			if let wrapper = view ?? viewConstructor?() {
				viewController.view = wrapper.uiView()
				return true
			}
			return false
		}
		
		@objc dynamic private func swizzledLoadView() {
			assert(ViewController.Storage.isSwizzled)
			
			// SWIZZLED METHOD WARNING: `self` is an instance of UIViewController, not ViewController.Storage. Don't access any instance members on `self`.
			if let storage = getBinderStorage(type: ViewController.Storage.self) {
				let vc = unsafeBitCast(self, to: UIViewController.self)
				
				if storage.loadView(for: vc) {
					return
				}
			}
			
			// Relay back to the original implementation
			let sel = #selector(ViewController.Storage.swizzledLoadView)
			let m = class_getMethodImplementation(ViewController.Storage.self, sel)!
			unsafeBitCast(m, to: (@convention(c) (NSObjectProtocol, Selector) -> Void).self)(self, sel)
		}
		
		@objc dynamic private func swizzledTraitCollectionDidChange(_ previous: UITraitCollection?) {
			assert(ViewController.Storage.isSwizzled)
			
			// SWIZZLED METHOD WARNING: `self` is an instance of UIViewController, not ViewController.Storage. Don't access any instance members on `self`.
			if let storage = getBinderStorage(type: ViewController.Storage.self) {
				let vc = unsafeBitCast(self, to: UIViewController.self)
				storage.traitCollectionDidChange(previous, vc.traitCollection)
			}
			
			// Relay back to the original implementation
			let sel = #selector(ViewController.Storage.swizzledTraitCollectionDidChange(_:))
			let m = class_getMethodImplementation(ViewController.Storage.self, sel)!
			unsafeBitCast(m, to: (@convention(c) (NSObjectProtocol, Selector, UITraitCollection?) -> Void).self)(self, sel, previous)
		}
		
		@objc dynamic private func swizzledViewWillAppear(_ animated: Bool) {
			assert(ViewController.Storage.isSwizzled)
			
			// SWIZZLED METHOD WARNING: `self` is an instance of UIViewController, not ViewController.Storage. Don't access any instance members on `self`.
			if let storage = getBinderStorage(type: ViewController.Storage.self) {
				let vc = unsafeBitCast(self, to: UIViewController.self)
				storage.viewWillAppear(controller: vc, animated: animated)
			}
			
			// Relay back to the original implementation
			let sel = #selector(ViewController.Storage.swizzledViewWillAppear(_:))
			let m = class_getMethodImplementation(ViewController.Storage.self, sel)!
			unsafeBitCast(m, to: (@convention(c) (NSObjectProtocol, Selector, Bool) -> Void).self)(self, sel, animated)
		}
		
		@objc dynamic private func swizzledViewDidDisappear(_ animated: Bool) {
			assert(ViewController.Storage.isSwizzled)
			
			// SWIZZLED METHOD WARNING: `self` is an instance of UIViewController, not ViewController.Storage. Don't access any instance members on `self`.
			if let storage = getBinderStorage(type: ViewController.Storage.self) {
				let vc = unsafeBitCast(self, to: UIViewController.self)
				storage.viewDidDisappear(controller: vc, animated: animated)
			}
			
			// Relay back to the original implementation
			let sel = #selector(ViewController.Storage.swizzledViewDidDisappear(_:))
			let m = class_getMethodImplementation(ViewController.Storage.self, sel)!
			unsafeBitCast(m, to: (@convention(c) (NSObjectProtocol, Selector, Bool) -> Void).self)(self, sel, animated)
		}
		
		@objc dynamic private func swizzledViewDidAppear(_ animated: Bool) {
			assert(ViewController.Storage.isSwizzled)
			
			// SWIZZLED METHOD WARNING: `self` is an instance of UIViewController, not ViewController.Storage. Don't access any instance members on `self`.
			if let storage = getBinderStorage(type: ViewController.Storage.self) {
				let vc = unsafeBitCast(self, to: UIViewController.self)
				storage.viewDidAppear(controller: vc, animated: animated)
				
				// Handle any modal presentation that were deferred until adding to the window
				storage.processModalPresentations(viewController: vc)
			}
			
			// Relay back to the original implementation
			let sel = #selector(ViewController.Storage.swizzledViewDidAppear(_:))
			let m = class_getMethodImplementation(ViewController.Storage.self, sel)!
			unsafeBitCast(m, to: (@convention(c) (NSObjectProtocol, Selector, Bool) -> Void).self)(self, sel, animated)
		}
		
		@objc dynamic private func swizzledViewWillDisappear(_ animated: Bool) {
			assert(ViewController.Storage.isSwizzled)
			
			// SWIZZLED METHOD WARNING: `self` is an instance of UIViewController, not ViewController.Storage. Don't access any instance members on `self`.
			if let storage = getBinderStorage(type: ViewController.Storage.self) {
				let vc = unsafeBitCast(self, to: UIViewController.self)
				storage.viewWillDisappear(controller: vc, animated: animated)
			}
			
			// Relay back to the original implementation
			let sel = #selector(ViewController.Storage.swizzledViewWillDisappear(_:))
			let m = class_getMethodImplementation(ViewController.Storage.self, sel)!
			unsafeBitCast(m, to: (@convention(c) (NSObjectProtocol, Selector, Bool) -> Void).self)(self, sel, animated)
		}
		
		@objc dynamic private func swizzledDidReceiveMemoryWarning() {
			assert(ViewController.Storage.isSwizzled)
			
			// SWIZZLED METHOD WARNING: `self` is an instance of UIViewController, not ViewController.Storage. Don't access any instance members on `self`.
			if let storage = getBinderStorage(type: ViewController.Storage.self) {
				let vc = unsafeBitCast(self, to: UIViewController.self)
				storage.controllerDidReceiveMemoryWarning(controller: vc)
			}
			
			// Relay back to the original implementation
			let sel = #selector(ViewController.Storage.swizzledDidReceiveMemoryWarning)
			let m = class_getMethodImplementation(ViewController.Storage.self, sel)!
			unsafeBitCast(m, to: (@convention(c) (NSObjectProtocol, Selector) -> Void).self)(self, sel)
		}
	}
}

extension BindingName where Binding: ViewControllerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .viewControllerBinding(ViewController.Binding.$1(v)) }) }
	static var view: BindingName<Dynamic<ViewConvertible>, Binding> { return BindingName<Dynamic<ViewConvertible>, Binding>({ v in .viewControllerBinding(ViewController.Binding.view(v)) }) }
	static var navigationItem: BindingName<Constant<NavigationItem>, Binding> { return BindingName<Constant<NavigationItem>, Binding>({ v in .viewControllerBinding(ViewController.Binding.navigationItem(v)) }) }
	@available(iOS, introduced: 7.0, deprecated: 11.0, message: "This property exists to access layout guides prior to iOS 11. On iOS 11 and later, use .layout on the .view")
	static var layout: BindingName<Dynamic<Layout>, Binding> { return BindingName<Dynamic<Layout>, Binding>({ v in .viewControllerBinding(ViewController.Binding.layout(v)) }) }
	static var title: BindingName<Dynamic<String>, Binding> { return BindingName<Dynamic<String>, Binding>({ v in .viewControllerBinding(ViewController.Binding.title(v)) }) }
	static var preferredContentSize: BindingName<Dynamic<CGSize>, Binding> { return BindingName<Dynamic<CGSize>, Binding>({ v in .viewControllerBinding(ViewController.Binding.preferredContentSize(v)) }) }
	static var modalPresentationStyle: BindingName<Dynamic<UIModalPresentationStyle>, Binding> { return BindingName<Dynamic<UIModalPresentationStyle>, Binding>({ v in .viewControllerBinding(ViewController.Binding.modalPresentationStyle(v)) }) }
	static var modalTransitionStyle: BindingName<Dynamic<UIModalTransitionStyle>, Binding> { return BindingName<Dynamic<UIModalTransitionStyle>, Binding>({ v in .viewControllerBinding(ViewController.Binding.modalTransitionStyle(v)) }) }
	static var isModalInPopover: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .viewControllerBinding(ViewController.Binding.isModalInPopover(v)) }) }
	static var definesPresentationContext: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .viewControllerBinding(ViewController.Binding.definesPresentationContext(v)) }) }
	static var providesPresentationContextTransitionStyle: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .viewControllerBinding(ViewController.Binding.providesPresentationContextTransitionStyle(v)) }) }
	static var transitioningDelegate: BindingName<Dynamic<UIViewControllerTransitioningDelegate>, Binding> { return BindingName<Dynamic<UIViewControllerTransitioningDelegate>, Binding>({ v in .viewControllerBinding(ViewController.Binding.transitioningDelegate(v)) }) }
	static var edgesForExtendedLayout: BindingName<Dynamic<UIRectEdge>, Binding> { return BindingName<Dynamic<UIRectEdge>, Binding>({ v in .viewControllerBinding(ViewController.Binding.edgesForExtendedLayout(v)) }) }
	static var extendedLayoutIncludesOpaqueBars: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .viewControllerBinding(ViewController.Binding.extendedLayoutIncludesOpaqueBars(v)) }) }
	static var automaticallyAdjustsScrollViewInsets: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .viewControllerBinding(ViewController.Binding.automaticallyAdjustsScrollViewInsets(v)) }) }
	static var restorationIdentifier: BindingName<Dynamic<String?>, Binding> { return BindingName<Dynamic<String?>, Binding>({ v in .viewControllerBinding(ViewController.Binding.restorationIdentifier(v)) }) }
	static var restorationClass: BindingName<Dynamic<UIViewControllerRestoration.Type?>, Binding> { return BindingName<Dynamic<UIViewControllerRestoration.Type?>, Binding>({ v in .viewControllerBinding(ViewController.Binding.restorationClass(v)) }) }
	static var modalPresentationCapturesStatusBarAppearance: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .viewControllerBinding(ViewController.Binding.modalPresentationCapturesStatusBarAppearance(v)) }) }
	static var hidesBottomBarWhenPushed: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .viewControllerBinding(ViewController.Binding.hidesBottomBarWhenPushed(v)) }) }
	static var toolbarItems: BindingName<Dynamic<SetOrAnimate<[BarButtonItemConvertible]>>, Binding> { return BindingName<Dynamic<SetOrAnimate<[BarButtonItemConvertible]>>, Binding>({ v in .viewControllerBinding(ViewController.Binding.toolbarItems(v)) }) }
	static var tabBarItem: BindingName<Dynamic<TabBarItemConvertible>, Binding> { return BindingName<Dynamic<TabBarItemConvertible>, Binding>({ v in .viewControllerBinding(ViewController.Binding.tabBarItem(v)) }) }
	static var isEditing: BindingName<Signal<SetOrAnimate<Bool>>, Binding> { return BindingName<Signal<SetOrAnimate<Bool>>, Binding>({ v in .viewControllerBinding(ViewController.Binding.isEditing(v)) }) }
	static var present: BindingName<Signal<ModalPresentation>, Binding> { return BindingName<Signal<ModalPresentation>, Binding>({ v in .viewControllerBinding(ViewController.Binding.present(v)) }) }
	static var traitCollectionDidChange: BindingName<SignalInput<(previous: UITraitCollection?, new: UITraitCollection)>, Binding> { return BindingName<SignalInput<(previous: UITraitCollection?, new: UITraitCollection)>, Binding>({ v in .viewControllerBinding(ViewController.Binding.traitCollectionDidChange(v)) }) }
	static var willAppear: BindingName<SignalInput<Bool>, Binding> { return BindingName<SignalInput<Bool>, Binding>({ v in .viewControllerBinding(ViewController.Binding.willAppear(v)) }) }
	static var didAppear: BindingName<SignalInput<Bool>, Binding> { return BindingName<SignalInput<Bool>, Binding>({ v in .viewControllerBinding(ViewController.Binding.didAppear(v)) }) }
	static var didDisappear: BindingName<SignalInput<Bool>, Binding> { return BindingName<SignalInput<Bool>, Binding>({ v in .viewControllerBinding(ViewController.Binding.didDisappear(v)) }) }
	static var willDisappear: BindingName<SignalInput<Bool>, Binding> { return BindingName<SignalInput<Bool>, Binding>({ v in .viewControllerBinding(ViewController.Binding.willDisappear(v)) }) }
	static var loadView: BindingName<() -> ViewConvertible, Binding> { return BindingName<() -> ViewConvertible, Binding>({ v in .viewControllerBinding(ViewController.Binding.loadView(v)) }) }
}

protocol ViewControllerConvertible {
	func uiViewController() -> ViewController.Instance
}
extension ViewController.Instance: ViewControllerConvertible {
	func uiViewController() -> ViewController.Instance { return self }
}

protocol ViewControllerBinding: BaseBinding {
	static func viewControllerBinding(_ binding: ViewController.Binding) -> Self
}
extension ViewControllerBinding {
	static func baseBinding(_ binding: BaseBinder.Binding) -> Self {
		return viewControllerBinding(.inheritedBinding(binding))
	}
}

struct ModalPresentation {
	let viewController: ViewControllerConvertible?
	let animated: Bool
	let completion: SignalInput<Void>?
	
	init(_ viewController: ViewControllerConvertible? = nil, animated: Bool = true, completion: SignalInput<Void>? = nil) {
		self.viewController = viewController
		self.animated = animated
		self.completion = completion
	}
}

extension SignalInterface {
	func modalPresentation<T>(_ construct: @escaping (T) -> ViewControllerConvertible) -> Signal<ModalPresentation> where OutputValue == Optional<T> {
		return transform { (result, next) in
			switch result {
			case .success(.some(let t)): next.send(value: ModalPresentation(construct(t)))
			case .success: next.send(value: ModalPresentation(nil))
			case .failure(let e): next.send(error: e)
			}
		}
	}
}

class SearchBar: ConstructingBinder, SearchBarConvertible {
	typealias Instance = UISearchBar
	typealias Inherited = View
	
	var state: ConstructingBinderState<Instance, Binding>
	required init(state: ConstructingBinderState<Instance, Binding>) {
		self.state = state
	}
	static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	func uiSearchBar() -> Instance { return instance() }
	
	enum Binding: SearchBarBinding {
		typealias EnclosingBinder = SearchBar
		static func searchBarBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case textInputTraits(Constant<TextInputTraits>)

		// 1. Value bindings may be applied at construction and may subsequently change.
		case placeholder(Dynamic<String>)
		case prompt(Dynamic<String>)
		case text(Dynamic<String>)
		case barStyle(Dynamic<UIBarStyle>)
		case tintColor(Dynamic<UIColor>)
		case isTranslucent(Dynamic<Bool>)
		case showsBookmarkButton(Dynamic<Bool>)
		case showsSearchResultsButton(Dynamic<Bool>)
		case showCancelButton(Dynamic<SetOrAnimate<Bool>>)
		case scopeButtonTitles(Dynamic<[String]?>)
		case selectedScopeButtonIndex(Dynamic<Int>)
		case showsScopeBar(Dynamic<Bool>)
		case backgroundImage(Dynamic<ScopedValues<PositionAndMetrics, UIImage?>>)
		case image(Dynamic<ScopedValues<IconAndControlState, UIImage?>>)
		case positionAdjustment(Dynamic<ScopedValues<UISearchBar.Icon, UIOffset>>)
		case inputAccessoryView(Dynamic<UIView?>)
		case scopeBarButtonBackgroundImage(Dynamic<ScopedValues<UIControl.State, UIImage?>>)
		case scopeBarButtonDividerImage(Dynamic<ScopedValues<LeftRightControlState, UIImage?>>)
		case scopeBarButtonTitleTextAttributes(Dynamic<ScopedValues<UIControl.State, [NSAttributedString.Key: Any]?>>)
		case searchFieldBackgroundImage(Dynamic<ScopedValues<UIControl.State, UIImage?>>)
		case searchFieldBackgroundPositionAdjustment(Dynamic<UIOffset>)
		case searchTextPositionAdjustment(Dynamic<UIOffset>)

		// 2. Signal bindings are performed on the object after construction.

		//	3. Action bindings are triggered by the object after construction.
		case didChange(SignalInput<String>)
		case didBeginEditing(SignalInput<Void>)
		case didEndEditing(SignalInput<Void>)
		case bookmarkButtonClicked(SignalInput<Void>)
		case cancelButtonClicked(SignalInput<Void>)
		case searchButtonClicked(SignalInput<String>)
		case resultsListButtonClicked(SignalInput<Void>)
		case selectedScopeButtonIndexDidChange(SignalInput<Int>)

		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case shouldChangeText((NSRange, String) -> Bool)
		case shouldBeginEditing((UISearchBar) -> Bool)
		case shouldEndEditing((UISearchBar) -> Bool)
		case position((UIBarPositioning) -> UIBarPosition)
	}

	struct Preparer: ConstructingPreparer {
		typealias EnclosingBinder = SearchBar
		var linkedPreparer = Inherited.Preparer()
		
		func constructStorage() -> EnclosingBinder.Storage { return Storage() }
		func constructInstance(subclass: EnclosingBinder.Instance.Type) -> EnclosingBinder.Instance { return subclass.init() }

		init() {
			self.init(delegateClass: Delegate.self)
		}
		init<Value>(delegateClass: Value.Type) where Value: Delegate {
			self.delegateClass = delegateClass
		}
		let delegateClass: Delegate.Type
		var possibleDelegate: Delegate? = nil
		mutating func delegate() -> Delegate {
			if let d = possibleDelegate {
				return d
			} else {
				let d = delegateClass.init()
				possibleDelegate = d
				return d
			}
		}

		mutating func prepareBinding(_ binding: Binding) {
			switch binding {
			case .didChange(let x):
				let s = #selector(UISearchBarDelegate.searchBar(_:textDidChange:))
				delegate().addSelector(s).didChange = x
			case .didBeginEditing(let x):
				let s = #selector(UISearchBarDelegate.searchBarTextDidBeginEditing(_:))
				delegate().addSelector(s).didBeginEditing = x
			case .didEndEditing(let x):
				let s = #selector(UISearchBarDelegate.searchBarTextDidEndEditing(_:))
				delegate().addSelector(s).didEndEditing = x
			case .bookmarkButtonClicked(let x):
				let s = #selector(UISearchBarDelegate.searchBarBookmarkButtonClicked(_:))
				delegate().addSelector(s).bookmarkButtonClicked = x
			case .cancelButtonClicked(let x):
				let s = #selector(UISearchBarDelegate.searchBarCancelButtonClicked(_:))
				delegate().addSelector(s).cancelButtonClicked = x
			case .searchButtonClicked(let x):
				let s = #selector(UISearchBarDelegate.searchBarSearchButtonClicked(_:))
				delegate().addSelector(s).searchButtonClicked = x
			case .resultsListButtonClicked(let x):
				let s = #selector(UISearchBarDelegate.searchBarResultsListButtonClicked(_:))
				delegate().addSelector(s).resultsListButtonClicked = x
			case .selectedScopeButtonIndexDidChange(let x):
				let s = #selector(UISearchBarDelegate.searchBar(_:selectedScopeButtonIndexDidChange:))
				delegate().addSelector(s).selectedScopeButtonIndexDidChange = x
			case .shouldChangeText(let x):
				let s = #selector(UISearchBarDelegate.searchBar(_:shouldChangeTextIn:replacementText:))
				delegate().addSelector(s).shouldChangeText = x
			case .shouldBeginEditing(let x):
				let s = #selector(UISearchBarDelegate.searchBarShouldBeginEditing(_:))
				delegate().addSelector(s).shouldBeginEditing = x
			case .shouldEndEditing(let x):
				let s = #selector(UISearchBarDelegate.searchBarShouldEndEditing(_:))
				delegate().addSelector(s).shouldEndEditing = x
			case .position(let x):
				let s = #selector(UISearchBarDelegate.position(for:))
				delegate().addSelector(s).position = x
			case .inheritedBinding(let x): linkedPreparer.prepareBinding(x)
			default: break
			}
		}

		mutating func prepareInstance(_ instance: Instance, storage: Storage) {
			precondition(instance.delegate == nil, "Conflicting delegate applied to instance")
			storage.dynamicDelegate = possibleDelegate
			if storage.inUse {
				instance.delegate = storage
			}

			linkedPreparer.prepareInstance(instance, storage: storage)
		}

		func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
			switch binding {
			case .textInputTraits(let x):
				return AggregateLifetime(lifetimes: x.value.bindings.lazy.compactMap { trait in
					switch trait {
					case .autocapitalizationType(let y): return y.apply(instance, storage) { i, s, v in i.autocapitalizationType = v }
					case .autocorrectionType(let y): return y.apply(instance, storage) { i, s, v in i.autocorrectionType = v }
					case .spellCheckingType(let y): return y.apply(instance, storage) { i, s, v in i.spellCheckingType = v }
					case .enablesReturnKeyAutomatically(let y): return y.apply(instance, storage) { i, s, v in i.enablesReturnKeyAutomatically = v }
					case .keyboardAppearance(let y): return y.apply(instance, storage) { i, s, v in i.keyboardAppearance = v }
					case .keyboardType(let y): return y.apply(instance, storage) { i, s, v in i.keyboardType = v }
					case .returnKeyType(let y): return y.apply(instance, storage) { i, s, v in i.returnKeyType = v }
					case .isSecureTextEntry(let y): return y.apply(instance, storage) { i, s, v in i.isSecureTextEntry = v }
					case .textContentType(let y):
						return y.apply(instance, storage) { i, s, v in
							if #available(iOS 10.0, *) {
								i.textContentType = v
							}
						}
					case .smartDashesType(let x):
						return x.apply(instance, storage) { i, s, v in
							if #available(iOS 11.0, *) {
								i.smartDashesType = v
							}
						}
					case .smartQuotesType(let x):
						return x.apply(instance, storage) { i, s, v in
							if #available(iOS 11.0, *) {
								i.smartQuotesType = v
							}
						}
					case .smartInsertDeleteType(let x):
						return x.apply(instance, storage) { i, s, v in
							if #available(iOS 11.0, *) {
								i.smartInsertDeleteType = v
							}
						}
					}
				})
			case .placeholder(let x): return x.apply(instance, storage) { i, s, v in i.placeholder = v }
			case .prompt(let x): return x.apply(instance, storage) { i, s, v in i.prompt = v }
			case .text(let x): return x.apply(instance, storage) { i, s, v in i.text = v }
			case .barStyle(let x): return x.apply(instance, storage) { i, s, v in i.barStyle = v }
			case .tintColor(let x): return x.apply(instance, storage) { i, s, v in i.tintColor = v }
			case .isTranslucent(let x): return x.apply(instance, storage) { i, s, v in i.isTranslucent = v }
			case .showsBookmarkButton(let x): return x.apply(instance, storage) { i, s, v in i.showsBookmarkButton = v }
			case .showsSearchResultsButton(let x): return x.apply(instance, storage) { i, s, v in i.showsSearchResultsButton = v }
			case .showCancelButton(let x): return x.apply(instance, storage) { i, s, v in i.setShowsCancelButton(v.value, animated: v.isAnimated) }
			case .scopeButtonTitles(let x): return x.apply(instance, storage) { i, s, v in i.scopeButtonTitles = v }
			case .selectedScopeButtonIndex(let x): return x.apply(instance, storage) { i, s, v in i.selectedScopeButtonIndex = v }
			case .showsScopeBar(let x): return x.apply(instance, storage) { i, s, v in i.showsScopeBar = v }
			case .inputAccessoryView(let x): return x.apply(instance, storage) { i, s, v in i.inputAccessoryView = v }
			case .searchFieldBackgroundPositionAdjustment(let x): return x.apply(instance, storage) { i, s, v in i.searchFieldBackgroundPositionAdjustment = v }
			case .searchTextPositionAdjustment(let x): return x.apply(instance, storage) { i, s, v in i.searchTextPositionAdjustment = v }
			
			case .backgroundImage(let x):
				var previous: ScopedValues<PositionAndMetrics, UIImage?>? = nil
				return x.apply(instance, storage) { i, s, v in
					if let p = previous {
						for conditions in p.pairs {
							if conditions.value != nil {
								i.setBackgroundImage(nil, for: conditions.scope.barPosition, barMetrics: conditions.scope.barMetrics)
							}
						}
					}
					previous = v
					for conditions in v.pairs {
						if let image = conditions.value {
							i.setBackgroundImage(image, for: conditions.scope.barPosition, barMetrics: conditions.scope.barMetrics)
						}
					}
				}
			case .image(let x):
				var previous: ScopedValues<IconAndControlState, UIImage?>? = nil
				return x.apply(instance, storage) { i, s, v in
					if let p = previous {
						for conditions in p.pairs {
							if conditions.value != nil {
								i.setImage(nil, for: conditions.scope.icon, state: conditions.scope.controlState)
							}
						}
					}
					previous = v
					for conditions in v.pairs {
						if let image = conditions.value {
							i.setImage(image, for: conditions.scope.icon, state: conditions.scope.controlState)
						}
					}
				}
			case .positionAdjustment(let x):
				var previous: ScopedValues<UISearchBar.Icon, UIOffset>? = nil
				return x.apply(instance, storage) { i, s, v in
					if let p = previous {
						for c in p.pairs {
							i.setPositionAdjustment(UIOffset(), for: c.0)
						}
					}
					previous = v
					for c in v.pairs {
						i.setPositionAdjustment(c.1, for: c.0)
					}
				}
			case .scopeBarButtonBackgroundImage(let x):
				var previous: ScopedValues<UIControl.State, UIImage?>? = nil
				return x.apply(instance, storage) { i, s, v in
					if let p = previous {
						for c in p.pairs {
							i.setScopeBarButtonBackgroundImage(nil, for: c.0)
						}
					}
					previous = v
					for c in v.pairs {
						i.setScopeBarButtonBackgroundImage(c.1, for: c.0)
					}
				}
			case .scopeBarButtonDividerImage(let x):
				var previous: ScopedValues<LeftRightControlState, UIImage?>? = nil
				return x.apply(instance, storage) { i, s, v -> Void in
					if let p = previous {
						for conditions in p.pairs {
							i.setScopeBarButtonDividerImage(nil, forLeftSegmentState: conditions.scope.left, rightSegmentState: conditions.scope.right)
						}
					}
					previous = v
					for conditions in v.pairs {
						i.setScopeBarButtonDividerImage(conditions.value, forLeftSegmentState: conditions.scope.left, rightSegmentState: conditions.scope.right)
					}
				}
			case .scopeBarButtonTitleTextAttributes(let x):
				var previous: ScopedValues<UIControl.State, [NSAttributedString.Key: Any]?>? = nil
				return x.apply(instance, storage) { i, s, v in
					if let p = previous {
						for c in p.pairs {
							i.setScopeBarButtonTitleTextAttributes(nil, for: c.0)
						}
					}
					previous = v
					for c in v.pairs {
						i.setScopeBarButtonTitleTextAttributes(c.1, for: c.0)
					}
				}
			case .searchFieldBackgroundImage(let x):
				var previous: ScopedValues<UIControl.State, UIImage?>? = nil
				return x.apply(instance, storage) { i, s, v in
					if let p = previous {
						for c in p.pairs {
							i.setScopeBarButtonBackgroundImage(nil, for: c.0)
						}
					}
					previous = v
					for c in v.pairs {
						i.setScopeBarButtonBackgroundImage(c.1, for: c.0)
					}
				}
			case .didChange: return nil
			case .didBeginEditing: return nil
			case .didEndEditing: return nil
			case .bookmarkButtonClicked: return nil
			case .cancelButtonClicked: return nil
			case .searchButtonClicked: return nil
			case .resultsListButtonClicked: return nil
			case .selectedScopeButtonIndexDidChange: return nil
			case .shouldChangeText: return nil
			case .shouldBeginEditing: return nil
			case .shouldEndEditing: return nil
			case .position: return nil
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: instance, storage: storage)
			}
		}
	}

	class Storage: View.Storage, UISearchBarDelegate {}
	
	class Delegate: DynamicDelegate, UISearchBarDelegate {
		required override init() {
			super.init()
		}
		
		var didChange: SignalInput<String>?
		func searchBar(_ searchBar: UISearchBar, textDidChange searchText: String) {
			didChange!.send(value: searchText)
		}
		
		var didBeginEditing: SignalInput<Void>?
		func searchBarTextDidBeginEditing(_ searchBar: UISearchBar) {
			didBeginEditing!.send(value: ())
		}
		
		var didEndEditing: SignalInput<Void>?
		func searchBarTextDidEndEditing(_ searchBar: UISearchBar) {
			didEndEditing!.send(value: ())
		}
		
		var bookmarkButtonClicked: SignalInput<Void>?
		func searchBarBookmarkButtonClicked(_ searchBar: UISearchBar) {
			bookmarkButtonClicked!.send(value: ())
		}
		
		var cancelButtonClicked: SignalInput<Void>?
		func searchBarCancelButtonClicked(_ searchBar: UISearchBar) {
			cancelButtonClicked!.send(value: ())
		}
		
		var searchButtonClicked: SignalInput<String>?
		func searchBarSearchButtonClicked(_ searchBar: UISearchBar) {
			searchButtonClicked!.send(value: searchBar.text ?? "")
		}
		
		var resultsListButtonClicked: SignalInput<Void>?
		func searchBarResultsListButtonClicked(_ searchBar: UISearchBar) {
			resultsListButtonClicked!.send(value: ())
		}
		
		var selectedScopeButtonIndexDidChange: SignalInput<Int>?
		func searchBarSelectedScopeButtonIndexDidChange(_ searchBar: UISearchBar, selectedScopeButtonIndexDidChange selectedScope: Int) {
			selectedScopeButtonIndexDidChange!.send(value: selectedScope)
		}
		
		var shouldBeginEditing: ((_ searchBar: UISearchBar) -> Bool)?
		func searchBarShouldBeginEditing(_ searchBar: UISearchBar) -> Bool {
			return shouldBeginEditing!(searchBar)
		}
		
		var shouldEndEditing: ((_ searchBar: UISearchBar) -> Bool)?
		func searchBarShouldEndEditing(_ searchBar: UISearchBar) -> Bool {
			return shouldEndEditing!(searchBar)
		}
		
		var shouldChangeText: ((_ range: NSRange, _ replacementString: String) -> Bool)?
		func searchBar(_ searchBar: UISearchBar, shouldChangeTextIn range: NSRange, replacementText text: String) -> Bool {
			return shouldChangeText!(range, text)
		}
		
		var position: ((UIBarPositioning) -> UIBarPosition)?
		func position(for bar: UIBarPositioning) -> UIBarPosition {
			return position!(bar)
		}
	}
}

extension BindingName where Binding: SearchBarBinding {
	// You can easily convert the `Binding` cases to `BindingName` by copying them to here and using the following Xcode-style regex:
	// Find:    case ([^\(]+)\((.+)\)$
	// Replace: static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .searchBarBinding(SearchBar.Binding.$1(v)) }) }
	static var textInputTraits: BindingName<Constant<TextInputTraits>, Binding> { return BindingName<Constant<TextInputTraits>, Binding>({ v in .searchBarBinding(SearchBar.Binding.textInputTraits(v)) }) }
	static var placeholder: BindingName<Dynamic<String>, Binding> { return BindingName<Dynamic<String>, Binding>({ v in .searchBarBinding(SearchBar.Binding.placeholder(v)) }) }
	static var prompt: BindingName<Dynamic<String>, Binding> { return BindingName<Dynamic<String>, Binding>({ v in .searchBarBinding(SearchBar.Binding.prompt(v)) }) }
	static var text: BindingName<Dynamic<String>, Binding> { return BindingName<Dynamic<String>, Binding>({ v in .searchBarBinding(SearchBar.Binding.text(v)) }) }
	static var barStyle: BindingName<Dynamic<UIBarStyle>, Binding> { return BindingName<Dynamic<UIBarStyle>, Binding>({ v in .searchBarBinding(SearchBar.Binding.barStyle(v)) }) }
	static var tintColor: BindingName<Dynamic<UIColor>, Binding> { return BindingName<Dynamic<UIColor>, Binding>({ v in .searchBarBinding(SearchBar.Binding.tintColor(v)) }) }
	static var isTranslucent: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .searchBarBinding(SearchBar.Binding.isTranslucent(v)) }) }
	static var showsBookmarkButton: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .searchBarBinding(SearchBar.Binding.showsBookmarkButton(v)) }) }
	static var showsSearchResultsButton: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .searchBarBinding(SearchBar.Binding.showsSearchResultsButton(v)) }) }
	static var showCancelButton: BindingName<Dynamic<SetOrAnimate<Bool>>, Binding> { return BindingName<Dynamic<SetOrAnimate<Bool>>, Binding>({ v in .searchBarBinding(SearchBar.Binding.showCancelButton(v)) }) }
	static var scopeButtonTitles: BindingName<Dynamic<[String]?>, Binding> { return BindingName<Dynamic<[String]?>, Binding>({ v in .searchBarBinding(SearchBar.Binding.scopeButtonTitles(v)) }) }
	static var selectedScopeButtonIndex: BindingName<Dynamic<Int>, Binding> { return BindingName<Dynamic<Int>, Binding>({ v in .searchBarBinding(SearchBar.Binding.selectedScopeButtonIndex(v)) }) }
	static var showsScopeBar: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .searchBarBinding(SearchBar.Binding.showsScopeBar(v)) }) }
	static var backgroundImage: BindingName<Dynamic<ScopedValues<PositionAndMetrics, UIImage?>>, Binding> { return BindingName<Dynamic<ScopedValues<PositionAndMetrics, UIImage?>>, Binding>({ v in .searchBarBinding(SearchBar.Binding.backgroundImage(v)) }) }
	static var image: BindingName<Dynamic<ScopedValues<IconAndControlState, UIImage?>>, Binding> { return BindingName<Dynamic<ScopedValues<IconAndControlState, UIImage?>>, Binding>({ v in .searchBarBinding(SearchBar.Binding.image(v)) }) }
	static var positionAdjustment: BindingName<Dynamic<ScopedValues<UISearchBar.Icon, UIOffset>>, Binding> { return BindingName<Dynamic<ScopedValues<UISearchBar.Icon, UIOffset>>, Binding>({ v in .searchBarBinding(SearchBar.Binding.positionAdjustment(v)) }) }
	static var inputAccessoryView: BindingName<Dynamic<UIView?>, Binding> { return BindingName<Dynamic<UIView?>, Binding>({ v in .searchBarBinding(SearchBar.Binding.inputAccessoryView(v)) }) }
	static var scopeBarButtonBackgroundImage: BindingName<Dynamic<ScopedValues<UIControl.State, UIImage?>>, Binding> { return BindingName<Dynamic<ScopedValues<UIControl.State, UIImage?>>, Binding>({ v in .searchBarBinding(SearchBar.Binding.scopeBarButtonBackgroundImage(v)) }) }
	static var scopeBarButtonDividerImage: BindingName<Dynamic<ScopedValues<LeftRightControlState, UIImage?>>, Binding> { return BindingName<Dynamic<ScopedValues<LeftRightControlState, UIImage?>>, Binding>({ v in .searchBarBinding(SearchBar.Binding.scopeBarButtonDividerImage(v)) }) }
	static var scopeBarButtonTitleTextAttributes: BindingName<Dynamic<ScopedValues<UIControl.State, [NSAttributedString.Key: Any]?>>, Binding> { return BindingName<Dynamic<ScopedValues<UIControl.State, [NSAttributedString.Key: Any]?>>, Binding>({ v in .searchBarBinding(SearchBar.Binding.scopeBarButtonTitleTextAttributes(v)) }) }
	static var searchFieldBackgroundImage: BindingName<Dynamic<ScopedValues<UIControl.State, UIImage?>>, Binding> { return BindingName<Dynamic<ScopedValues<UIControl.State, UIImage?>>, Binding>({ v in .searchBarBinding(SearchBar.Binding.searchFieldBackgroundImage(v)) }) }
	static var searchFieldBackgroundPositionAdjustment: BindingName<Dynamic<UIOffset>, Binding> { return BindingName<Dynamic<UIOffset>, Binding>({ v in .searchBarBinding(SearchBar.Binding.searchFieldBackgroundPositionAdjustment(v)) }) }
	static var searchTextPositionAdjustment: BindingName<Dynamic<UIOffset>, Binding> { return BindingName<Dynamic<UIOffset>, Binding>({ v in .searchBarBinding(SearchBar.Binding.searchTextPositionAdjustment(v)) }) }
	static var didChange: BindingName<SignalInput<String>, Binding> { return BindingName<SignalInput<String>, Binding>({ v in .searchBarBinding(SearchBar.Binding.didChange(v)) }) }
	static var didBeginEditing: BindingName<SignalInput<Void>, Binding> { return BindingName<SignalInput<Void>, Binding>({ v in .searchBarBinding(SearchBar.Binding.didBeginEditing(v)) }) }
	static var didEndEditing: BindingName<SignalInput<Void>, Binding> { return BindingName<SignalInput<Void>, Binding>({ v in .searchBarBinding(SearchBar.Binding.didEndEditing(v)) }) }
	static var bookmarkButtonClicked: BindingName<SignalInput<Void>, Binding> { return BindingName<SignalInput<Void>, Binding>({ v in .searchBarBinding(SearchBar.Binding.bookmarkButtonClicked(v)) }) }
	static var cancelButtonClicked: BindingName<SignalInput<Void>, Binding> { return BindingName<SignalInput<Void>, Binding>({ v in .searchBarBinding(SearchBar.Binding.cancelButtonClicked(v)) }) }
	static var searchButtonClicked: BindingName<SignalInput<String>, Binding> { return BindingName<SignalInput<String>, Binding>({ v in .searchBarBinding(SearchBar.Binding.searchButtonClicked(v)) }) }
	static var resultsListButtonClicked: BindingName<SignalInput<Void>, Binding> { return BindingName<SignalInput<Void>, Binding>({ v in .searchBarBinding(SearchBar.Binding.resultsListButtonClicked(v)) }) }
	static var selectedScopeButtonIndexDidChange: BindingName<SignalInput<Int>, Binding> { return BindingName<SignalInput<Int>, Binding>({ v in .searchBarBinding(SearchBar.Binding.selectedScopeButtonIndexDidChange(v)) }) }
	static var shouldChangeText: BindingName<(NSRange, String) -> Bool, Binding> { return BindingName<(NSRange, String) -> Bool, Binding>({ v in .searchBarBinding(SearchBar.Binding.shouldChangeText(v)) }) }
	static var shouldBeginEditing: BindingName<(UISearchBar) -> Bool, Binding> { return BindingName<(UISearchBar) -> Bool, Binding>({ v in .searchBarBinding(SearchBar.Binding.shouldBeginEditing(v)) }) }
	static var shouldEndEditing: BindingName<(UISearchBar) -> Bool, Binding> { return BindingName<(UISearchBar) -> Bool, Binding>({ v in .searchBarBinding(SearchBar.Binding.shouldEndEditing(v)) }) }
	static var position: BindingName<(UIBarPositioning) -> UIBarPosition, Binding> { return BindingName<(UIBarPositioning) -> UIBarPosition, Binding>({ v in .searchBarBinding(SearchBar.Binding.position(v)) }) }
}

protocol SearchBarConvertible: ViewConvertible {
	func uiSearchBar() -> SearchBar.Instance
}
extension SearchBarConvertible {
	func uiView() -> View.Instance { return uiSearchBar() }
}
extension SearchBar.Instance: SearchBarConvertible {
	func uiSearchBar() -> SearchBar.Instance { return self }
}

protocol SearchBarBinding: ViewBinding {
	static func searchBarBinding(_ binding: SearchBar.Binding) -> Self
}
extension SearchBarBinding {
	static func viewBinding(_ binding: View.Binding) -> Self {
		return searchBarBinding(.inheritedBinding(binding))
	}
}

struct LeftRightControlState {
	let left: UIControl.State
	let right: UIControl.State
	init(left: UIControl.State = .normal, right: UIControl.State = .normal) {
		self.left = left
		self.right = right
	}
}

struct IconAndControlState {
	let icon: UISearchBar.Icon
	let controlState: UIControl.State
	init(icon: UISearchBar.Icon = .search, state: UIControl.State = .normal) {
		self.icon = icon
		self.controlState = state
	}
}

extension ScopedValues where Scope == LeftRightControlState {
	static func normal(right: UIControl.State = .normal, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: LeftRightControlState(left: .normal, right: right))
	}
	static func highlighted(right: UIControl.State = .highlighted, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: LeftRightControlState(left: .highlighted, right: right))
	}
	static func disabled(right: UIControl.State = .disabled, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: LeftRightControlState(left: .disabled, right: right))
	}
	static func selected(right: UIControl.State = .selected, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: LeftRightControlState(left: .selected, right: right))
	}
	@available(iOS 9.0, *)
	static func focused(right: UIControl.State = .focused, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: LeftRightControlState(left: .focused, right: right))
	}
	static func application(right: UIControl.State = .application, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: LeftRightControlState(left: .application, right: right))
	}
	static func reserved(right: UIControl.State = .reserved, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: LeftRightControlState(left: .reserved, right: right))
	}
}

extension ScopedValues where Scope == IconAndControlState {
	static func search(state: UIControl.State = .normal, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: IconAndControlState(icon: .search, state: state))
	}
	static func clear(state: UIControl.State = .normal, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: IconAndControlState(icon: .clear, state: state))
	}
	static func bookmark(state: UIControl.State = .normal, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: IconAndControlState(icon: .bookmark, state: state))
	}
	static func resultsList(state: UIControl.State = .normal, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: IconAndControlState(icon: .resultsList, state: state))
	}
}

extension ScopedValues where Scope == UISearchBar.Icon {
	static func search(_ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: .search)
	}
	static func clear(_ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: .clear)
	}
	static func bookmark(_ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: .bookmark)
	}
	static func resultsList(_ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: .resultsList)
	}
}

class ScreenEdgePanGestureRecognizer: ConstructingBinder, ScreenEdgePanGestureRecognizerConvertible {
	typealias Instance = UIScreenEdgePanGestureRecognizer
	typealias Inherited = GestureRecognizer
	
	var state: ConstructingBinderState<Instance, Binding>
	required init(state: ConstructingBinderState<Instance, Binding>) {
		self.state = state
	}
	static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	func uiScreenEdgePanGestureRecognizer() -> Instance { return instance() }
	
	enum Binding: ScreenEdgePanGestureRecognizerBinding {
		typealias EnclosingBinder = ScreenEdgePanGestureRecognizer
		static func screenEdgePanGestureRecognizerBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case edges(Dynamic<UIRectEdge>)
		
		// 2. Signal bindings are performed on the object after construction.
		
		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		
		struct Name<Value> {
			// You can easily convert the `Binding` cases to `Binding.Name` using the following Xcode-style regex:
			// Replace: case ([^\(]+)\((.+)\)$
			// With:    static var $1: Name<$2> { return Name<$2>(Binding.$1) }
			static var edges: Name<Dynamic<UIRectEdge>> { return Name<Dynamic<UIRectEdge>>(Binding.edges) }
			
			let constructor: (Value) -> Binding
			init(_ constructor: @escaping (Value) -> Binding) {
				self.constructor = constructor
			}
		}
	}
	
	struct Preparer: ConstructingPreparer {
		typealias EnclosingBinder = ScreenEdgePanGestureRecognizer
		var linkedPreparer = Inherited.Preparer()
		
		func constructStorage() -> EnclosingBinder.Storage { return Storage() }
		func constructInstance(subclass: EnclosingBinder.Instance.Type) -> EnclosingBinder.Instance { return subclass.init() }
		
		init() {}
		
		func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
			switch binding {
			case .edges(let x): return x.apply(instance, storage) { i, s, v in i.edges = v }
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: instance, storage: storage)
			}
		}
	}
	
	typealias Storage = GestureRecognizer.Storage
}

extension BindingName where Binding: ScreenEdgePanGestureRecognizerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .screenEdgePanGestureRecognizerBinding(ScreenEdgePanGestureRecognizer.Binding.$1(v)) }) }
	static var edges: BindingName<Dynamic<UIRectEdge>, Binding> { return BindingName<Dynamic<UIRectEdge>, Binding>({ v in .screenEdgePanGestureRecognizerBinding(ScreenEdgePanGestureRecognizer.Binding.edges(v)) }) }
}

protocol ScreenEdgePanGestureRecognizerConvertible: GestureRecognizerConvertible {
	func uiScreenEdgePanGestureRecognizer() -> ScreenEdgePanGestureRecognizer.Instance
}
extension ScreenEdgePanGestureRecognizerConvertible {
	func uiGestureRecognizer() -> GestureRecognizer.Instance { return uiScreenEdgePanGestureRecognizer() }
}
extension ScreenEdgePanGestureRecognizer.Instance: ScreenEdgePanGestureRecognizerConvertible {
	func uiScreenEdgePanGestureRecognizer() -> ScreenEdgePanGestureRecognizer.Instance { return self }
}

protocol ScreenEdgePanGestureRecognizerBinding: GestureRecognizerBinding {
	static func screenEdgePanGestureRecognizerBinding(_ binding: ScreenEdgePanGestureRecognizer.Binding) -> Self
}
extension ScreenEdgePanGestureRecognizerBinding {
	static func gestureRecognizerBinding(_ binding: GestureRecognizer.Binding) -> Self {
		return screenEdgePanGestureRecognizerBinding(.inheritedBinding(binding))
	}
}

class RotationGestureRecognizer: ConstructingBinder, RotationGestureRecognizerConvertible {
	typealias Instance = UIRotationGestureRecognizer
	typealias Inherited = GestureRecognizer
	
	var state: ConstructingBinderState<Instance, Binding>
	required init(state: ConstructingBinderState<Instance, Binding>) {
		self.state = state
	}
	static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	func uiRotationGestureRecognizer() -> Instance { return instance() }
	
	enum Binding: RotationGestureRecognizerBinding {
		typealias EnclosingBinder = RotationGestureRecognizer
		static func rotationGestureRecognizerBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case rotation(Dynamic<CGFloat>)
		
		// 2. Signal bindings are performed on the object after construction.
		
		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
	
	struct Preparer: ConstructingPreparer {
		typealias EnclosingBinder = RotationGestureRecognizer
		var linkedPreparer = Inherited.Preparer()
		
		func constructStorage() -> EnclosingBinder.Storage { return Storage() }
		func constructInstance(subclass: EnclosingBinder.Instance.Type) -> EnclosingBinder.Instance { return subclass.init() }
		
		init() {}
		
		func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
			switch binding {
			case .rotation(let x): return x.apply(instance, storage) { i, s, v in i.rotation = v }
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: instance, storage: storage)
			}
		}
	}
	
	typealias Storage = GestureRecognizer.Storage
}

extension BindingName where Binding: RotationGestureRecognizerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .rotationGestureRecognizerBinding(RotationGestureRecognizer.Binding.$1(v)) }) }
	static var rotation: BindingName<Dynamic<CGFloat>, Binding> { return BindingName<Dynamic<CGFloat>, Binding>({ v in .rotationGestureRecognizerBinding(RotationGestureRecognizer.Binding.rotation(v)) }) }
}

protocol RotationGestureRecognizerConvertible: GestureRecognizerConvertible {
	func uiRotationGestureRecognizer() -> RotationGestureRecognizer.Instance
}
extension RotationGestureRecognizerConvertible {
	func uiGestureRecognizer() -> GestureRecognizer.Instance { return uiRotationGestureRecognizer() }
}
extension RotationGestureRecognizer.Instance: RotationGestureRecognizerConvertible {
	func uiRotationGestureRecognizer() -> RotationGestureRecognizer.Instance { return self }
}

protocol RotationGestureRecognizerBinding: GestureRecognizerBinding {
	static func rotationGestureRecognizerBinding(_ binding: RotationGestureRecognizer.Binding) -> Self
}
extension RotationGestureRecognizerBinding {
	static func gestureRecognizerBinding(_ binding: GestureRecognizer.Binding) -> Self {
		return rotationGestureRecognizerBinding(.inheritedBinding(binding))
	}
}

class BarButtonItem: ConstructingBinder, BarButtonItemConvertible {
	typealias Instance = UIBarButtonItem
	typealias Inherited = BarItem
	
	var state: ConstructingBinderState<Instance, Binding>
	required init(state: ConstructingBinderState<Instance, Binding>) {
		self.state = state
	}
	static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	func uiBarButtonItem() -> Instance { return instance() }
	
	enum Binding: BarButtonItemBinding {
		typealias EnclosingBinder = BarButtonItem
		static func barButtonItemBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case barButtonSystemItem(Constant<UIBarButtonItem.SystemItem>)
		
		//	1. Value bindings may be applied at construction and may subsequently change.
		case itemStyle(Dynamic<UIBarButtonItem.Style>)
		case possibleTitles(Dynamic<Set<String>?>)
		case width(Dynamic<CGFloat>)
		case customView(Dynamic<ViewConvertible?>)
		case tintColor(Dynamic<UIColor?>)
		case backgroundImage(Dynamic<ScopedValues<StateStyleAndMetrics, UIImage?>>)
		case backButtonBackgroundImage(Dynamic<ScopedValues<StateAndMetrics, UIImage?>>)
		case backButtonTitlePositionAdjustment(Dynamic<ScopedValues<UIBarMetrics, UIOffset>>)
		case backgroundVerticalPositionAdjustment(Dynamic<ScopedValues<UIBarMetrics, CGFloat>>)
		case titlePositionAdjustment(Dynamic<ScopedValues<UIBarMetrics, UIOffset>>)
		
		//	2. Signal bindings are performed on the object after construction.
		
		//	3. Action bindings are triggered by the object after construction.
		case action(TargetAction)
		
		//	4. Delegate bindings require synchronous evaluation within the object's context.
	}
	
	struct Preparer: ConstructingPreparer {
		typealias EnclosingBinder = BarButtonItem
		var linkedPreparer = Inherited.Preparer()
		
		func constructStorage() -> EnclosingBinder.Storage { return Storage() }
		func constructInstance(subclass: EnclosingBinder.Instance.Type) -> EnclosingBinder.Instance {
			let x: UIBarButtonItem
			if let si = systemItem {
				x = subclass.init(barButtonSystemItem: si, target: nil, action: nil)
			} else if case .some(.some(let cv)) = customViewInitial {
				x = subclass.init(customView: cv.uiView())
			} else if case .some(.some(let i)) = imageInitial {
				x = subclass.init(image: i, landscapeImagePhone: landscapeImagePhoneInitial ?? nil, style: itemStyleInitial ?? .plain, target: nil, action: nil)
			} else {
				x = subclass.init(title: titleInitial ?? nil, style: itemStyleInitial ?? .plain, target: nil, action: nil)
			}
			return x
		}
		
		var systemItem: UIBarButtonItem.SystemItem?
		var customView = InitialSubsequent<ViewConvertible?>()
		var customViewInitial: ViewConvertible?? = nil
		var itemStyle = InitialSubsequent<UIBarButtonItem.Style>()
		var itemStyleInitial: UIBarButtonItem.Style? = nil
		var image = InitialSubsequent<UIImage?>()
		var imageInitial: UIImage?? = nil
		var landscapeImagePhone = InitialSubsequent<UIImage?>()
		var landscapeImagePhoneInitial: UIImage?? = nil
		var title = InitialSubsequent<String>()
		var titleInitial: String? = nil
		
		init() {}
		
		mutating func prepareBinding(_ binding: Binding) {
			switch binding {
			case .barButtonSystemItem(let x): systemItem = x.value
			case .customView(let x):
				customView = x.initialSubsequent()
				customViewInitial = customView.initial()
			case .itemStyle(let x):
				itemStyle = x.initialSubsequent()
				itemStyleInitial = itemStyle.initial()
			case .inheritedBinding(.image(let x)):
				image = x.initialSubsequent()
				imageInitial = image.initial()
			case .inheritedBinding(.landscapeImagePhone(let x)):
				landscapeImagePhone = x.initialSubsequent()
				landscapeImagePhoneInitial = landscapeImagePhone.initial()
			case .inheritedBinding(.title(let x)):
				title = x.initialSubsequent()
				titleInitial = title.initial()
			case .inheritedBinding(let x): linkedPreparer.prepareBinding(x)
			default: break
			}
		}
		
		func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
			switch binding {
			case .barButtonSystemItem: return nil
			case .backgroundImage(let x):
				var previous: ScopedValues<StateStyleAndMetrics, UIImage?>? = nil
				return x.apply(instance, storage) { i, s, v in
					if let p = previous {
						for conditions in p.pairs {
							if conditions.value != nil {
								i.setBackgroundImage(nil, for: conditions.scope.controlState, style: conditions.scope.itemStyle, barMetrics: conditions.scope.barMetrics)
							}
						}
					}
					previous = v
					for conditions in v.pairs {
						if let image = conditions.value {
							i.setBackgroundImage(image, for: conditions.scope.controlState, style: conditions.scope.itemStyle, barMetrics: conditions.scope.barMetrics)
						}
					}
				}
			case .backButtonBackgroundImage(let x):
				var previous: ScopedValues<StateAndMetrics, UIImage?>? = nil
				return x.apply(instance, storage) { i, s, v in
					if let p = previous {
						for conditions in p.pairs {
							if conditions.value != nil {
								i.setBackButtonBackgroundImage(nil, for: conditions.scope.controlState, barMetrics: conditions.scope.barMetrics)
							}
						}
					}
					previous = v
					for conditions in v.pairs {
						if let image = conditions.value {
							i.setBackButtonBackgroundImage(image, for: conditions.scope.controlState, barMetrics: conditions.scope.barMetrics)
						}
					}
				}
			case .backButtonTitlePositionAdjustment(let x):
				var previous: ScopedValues<UIBarMetrics, UIOffset>? = nil
				return x.apply(instance, storage) { i, s, v in
					if let p = previous {
						for c in p.pairs {
							i.setBackButtonTitlePositionAdjustment(UIOffset(), for: c.scope)
						}
					}
					previous = v
					for c in v.pairs {
						i.setBackButtonTitlePositionAdjustment(c.value, for: c.scope)
					}
				}
			case .backgroundVerticalPositionAdjustment(let x):
				var previous: ScopedValues<UIBarMetrics, CGFloat>? = nil
				return x.apply(instance, storage) { i, s, v in
					if let p = previous {
						for c in p.pairs {
							i.setBackgroundVerticalPositionAdjustment(0, for: c.scope)
						}
					}
					previous = v
					for c in v.pairs {
						i.setBackgroundVerticalPositionAdjustment(c.value, for: c.scope)
					}
				}
			case .titlePositionAdjustment(let x):
				var previous: ScopedValues<UIBarMetrics, UIOffset>? = nil
				return x.apply(instance, storage) { i, s, v in
					if let p = previous {
						for c in p.pairs {
							i.setTitlePositionAdjustment(UIOffset(), for: c.scope)
						}
					}
					previous = v
					for c in v.pairs {
						i.setTitlePositionAdjustment(c.value, for: c.scope)
					}
				}
			case .itemStyle:
				return itemStyle.subsequent.flatMap { $0.apply(instance, storage) { i, s, v in i.style = v } }
			case .possibleTitles(let x): return x.apply(instance, storage) { i, s, v in i.possibleTitles = v }
			case .width(let x): return x.apply(instance, storage) { i, s, v in i.width = v }
			case .customView:
				return customView.subsequent.flatMap { $0.apply(instance, storage) { i, s, v in i.customView = v?.uiView() } }
			case .tintColor(let x): return x.apply(instance, storage) { i, s, v in i.tintColor = v }
			case .action(let x): return x.apply(instance: instance, constructTarget: SignalActionTarget.init, processor: { sender in () })
				
			case .inheritedBinding(.image): return image.subsequent.flatMap { $0.apply(instance, storage) { i, s, v in i.image = v } }
			case .inheritedBinding(.landscapeImagePhone): return landscapeImagePhone.subsequent.flatMap { $0.apply(instance, storage) { i, s, v in i.landscapeImagePhone = v } }
			case .inheritedBinding(.title): return title.subsequent.flatMap { $0.apply(instance, storage) { i, s, v in i.title = v } }
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: instance, storage: storage)
			}
		}
	}
	
	typealias Storage = BarItem.Storage
}

extension BindingName where Binding: BarButtonItemBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .barButtonItemBinding(BarButtonItem.Binding.$1(v)) }) }
	static var barButtonSystemItem: BindingName<Constant<UIBarButtonItem.SystemItem>, Binding> { return BindingName<Constant<UIBarButtonItem.SystemItem>, Binding>({ v in .barButtonItemBinding(BarButtonItem.Binding.barButtonSystemItem(v)) }) }
	static var itemStyle: BindingName<Dynamic<UIBarButtonItem.Style>, Binding> { return BindingName<Dynamic<UIBarButtonItem.Style>, Binding>({ v in .barButtonItemBinding(BarButtonItem.Binding.itemStyle(v)) }) }
	static var possibleTitles: BindingName<Dynamic<Set<String>?>, Binding> { return BindingName<Dynamic<Set<String>?>, Binding>({ v in .barButtonItemBinding(BarButtonItem.Binding.possibleTitles(v)) }) }
	static var width: BindingName<Dynamic<CGFloat>, Binding> { return BindingName<Dynamic<CGFloat>, Binding>({ v in .barButtonItemBinding(BarButtonItem.Binding.width(v)) }) }
	static var customView: BindingName<Dynamic<ViewConvertible?>, Binding> { return BindingName<Dynamic<ViewConvertible?>, Binding>({ v in .barButtonItemBinding(BarButtonItem.Binding.customView(v)) }) }
	static var tintColor: BindingName<Dynamic<UIColor?>, Binding> { return BindingName<Dynamic<UIColor?>, Binding>({ v in .barButtonItemBinding(BarButtonItem.Binding.tintColor(v)) }) }
	static var backgroundImage: BindingName<Dynamic<ScopedValues<StateStyleAndMetrics, UIImage?>>, Binding> { return BindingName<Dynamic<ScopedValues<StateStyleAndMetrics, UIImage?>>, Binding>({ v in .barButtonItemBinding(BarButtonItem.Binding.backgroundImage(v)) }) }
	static var backButtonBackgroundImage: BindingName<Dynamic<ScopedValues<StateAndMetrics, UIImage?>>, Binding> { return BindingName<Dynamic<ScopedValues<StateAndMetrics, UIImage?>>, Binding>({ v in .barButtonItemBinding(BarButtonItem.Binding.backButtonBackgroundImage(v)) }) }
	static var backButtonTitlePositionAdjustment: BindingName<Dynamic<ScopedValues<UIBarMetrics, UIOffset>>, Binding> { return BindingName<Dynamic<ScopedValues<UIBarMetrics, UIOffset>>, Binding>({ v in .barButtonItemBinding(BarButtonItem.Binding.backButtonTitlePositionAdjustment(v)) }) }
	static var backgroundVerticalPositionAdjustment: BindingName<Dynamic<ScopedValues<UIBarMetrics, CGFloat>>, Binding> { return BindingName<Dynamic<ScopedValues<UIBarMetrics, CGFloat>>, Binding>({ v in .barButtonItemBinding(BarButtonItem.Binding.backgroundVerticalPositionAdjustment(v)) }) }
	static var titlePositionAdjustment: BindingName<Dynamic<ScopedValues<UIBarMetrics, UIOffset>>, Binding> { return BindingName<Dynamic<ScopedValues<UIBarMetrics, UIOffset>>, Binding>({ v in .barButtonItemBinding(BarButtonItem.Binding.titlePositionAdjustment(v)) }) }
	static var action: BindingName<TargetAction, Binding> { return BindingName<TargetAction, Binding>({ v in .barButtonItemBinding(BarButtonItem.Binding.action(v)) }) }
}

extension BindingName where Binding: BarButtonItemBinding, Binding.EnclosingBinder: BinderChain {
	static func action<I: SignalInputInterface, Value>(_ keyPath: KeyPath<Binding.EnclosingBinder.Instance, Value>) -> BindingName<I, Binding> where I.InputValue == Value {
		return BindingName<I, Binding> { (v: I) -> Binding in
			Binding.barButtonItemBinding(
				BarButtonItem.Binding.action(
					TargetAction.singleTarget(
						Input<Any?>()
							.map { i -> Value in
								(i as! Binding.EnclosingBinder.Instance)[keyPath: keyPath]
							}
							.bind(to: v.input)
					)
				)
			)
		}
	}
}

protocol BarButtonItemConvertible: BarItemConvertible {
	func uiBarButtonItem() -> BarButtonItem.Instance
}
extension BarButtonItemConvertible {
	func uiBarItem() -> BarItem.Instance { return uiBarButtonItem() }
}
extension BarButtonItem.Instance: BarButtonItemConvertible {
	func uiBarButtonItem() -> BarButtonItem.Instance { return self }
}

protocol BarButtonItemBinding: BarItemBinding {
	static func barButtonItemBinding(_ binding: BarButtonItem.Binding) -> Self
}
extension BarButtonItemBinding {
	static func barItemBinding(_ binding: BarItem.Binding) -> Self {
		return barButtonItemBinding(.inheritedBinding(binding))
	}
}

extension UIBarButtonItem: TargetActionSender {}

struct StateStyleAndMetrics {
	let controlState: UIControl.State
	let itemStyle: UIBarButtonItem.Style
	let barMetrics: UIBarMetrics
	init(state: UIControl.State = .normal, style: UIBarButtonItem.Style = .plain, metrics: UIBarMetrics = .default) {
		self.controlState = state
		self.itemStyle = style
		self.barMetrics = metrics
	}
}

struct StateAndMetrics {
	let controlState: UIControl.State
	let barMetrics: UIBarMetrics
	init(state: UIControl.State = .normal, metrics: UIBarMetrics = .default) {
		self.controlState = state
		self.barMetrics = metrics
	}
}

extension ScopedValues where Scope == StateAndMetrics {
	static func normal(metrics: UIBarMetrics = .default, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: StateAndMetrics(state: .normal, metrics: metrics))
	}
	static func highlighted(metrics: UIBarMetrics = .default, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: StateAndMetrics(state: .highlighted, metrics: metrics))
	}
	static func disabled(metrics: UIBarMetrics = .default, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: StateAndMetrics(state: .disabled, metrics: metrics))
	}
	static func selected(metrics: UIBarMetrics = .default, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: StateAndMetrics(state: .selected, metrics: metrics))
	}
	@available(iOS 9.0, *)
	static func focused(metrics: UIBarMetrics = .default, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: StateAndMetrics(state: .focused, metrics: metrics))
	}
	static func application(metrics: UIBarMetrics = .default, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: StateAndMetrics(state: .application, metrics: metrics))
	}
	static func reserved(metrics: UIBarMetrics = .default, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: StateAndMetrics(state: .reserved, metrics: metrics))
	}
}

extension ScopedValues where Scope == StateStyleAndMetrics {
	static func normal(style: UIBarButtonItem.Style = .plain, metrics: UIBarMetrics = .default, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: StateStyleAndMetrics(state: .normal, metrics: metrics))
	}
	static func highlighted(style: UIBarButtonItem.Style = .plain, metrics: UIBarMetrics = .default, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: StateStyleAndMetrics(state: .highlighted, metrics: metrics))
	}
	static func disabled(style: UIBarButtonItem.Style = .plain, metrics: UIBarMetrics = .default, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: StateStyleAndMetrics(state: .disabled, metrics: metrics))
	}
	static func selected(style: UIBarButtonItem.Style = .plain, metrics: UIBarMetrics = .default, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: StateStyleAndMetrics(state: .selected, metrics: metrics))
	}
	@available(iOS 9.0, *)
	static func focused(style: UIBarButtonItem.Style = .plain, metrics: UIBarMetrics = .default, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: StateStyleAndMetrics(state: .focused, metrics: metrics))
	}
	static func application(style: UIBarButtonItem.Style = .plain, metrics: UIBarMetrics = .default, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: StateStyleAndMetrics(state: .application, metrics: metrics))
	}
	static func reserved(style: UIBarButtonItem.Style = .plain, metrics: UIBarMetrics = .default, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: StateStyleAndMetrics(state: .reserved, metrics: metrics))
	}
}

extension ScopedValues where Scope == UIBarMetrics {
	static func `default`(_ value: Value) -> ScopedValues<Scope, Value> {
		return ScopedValues<Scope, Value>(scope: .default, value: value)
	}
	static func compact(_ value: Value) -> ScopedValues<Scope, Value> {
		return ScopedValues<Scope, Value>(scope: .compact, value: value)
	}
	static func defaultPrompt(_ value: Value) -> ScopedValues<Scope, Value> {
		return ScopedValues<Scope, Value>(scope: .defaultPrompt, value: value)
	}
	static func compactPrompt(_ value: Value) -> ScopedValues<Scope, Value> {
		return ScopedValues<Scope, Value>(scope: .compactPrompt, value: value)
	}
}


import QuartzCore

class BackingLayer: Binder {
	typealias Instance = CALayer
	typealias Inherited = BaseBinder

	var state: BinderState<Instance, BindingsOnlyParameters<Binding>>
	required init(state: BinderState<Instance, BindingsOnlyParameters<Binding>>) {
		self.state = state
	}
	static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	
	enum Binding: BackingLayerBinding {
		typealias EnclosingBinder = BackingLayer
		static func backingLayerBinding(_ binding: BackingLayer.Binding) -> BackingLayer.Binding { return binding }
		
		case inheritedBinding(Inherited.Binding)
		
		//	1. Value bindings may be applied at construction and may subsequently change.
		case affineTransform(Dynamic<CGAffineTransform>)
		case anchorPoint(Dynamic<CGPoint>)
		case anchorPointZ(Dynamic<CGFloat>)
		case actions(Dynamic<[String: SignalInput<[AnyHashable: Any]?>?]>)
		case backgroundColor(Dynamic<CGColor?>)
		case borderColor(Dynamic<CGColor?>)
		case borderWidth(Dynamic<CGFloat>)
		case bounds(Dynamic<CGRect>)
		case contents(Dynamic<Any?>)
		case contentsCenter(Dynamic<CGRect>)
		case contentsGravity(Dynamic<CALayerContentsGravity>)
		case contentsRect(Dynamic<CGRect>)
		case contentsScale(Dynamic<CGFloat>)
		case cornerRadius(Dynamic<CGFloat>)
		case isDoubleSided(Dynamic<Bool>)
		case drawsAsynchronously(Dynamic<Bool>)
		case edgeAntialiasingMask(Dynamic<CAEdgeAntialiasingMask>)
		case frame(Dynamic<CGRect>)
		case isGeometryFlipped(Dynamic<Bool>)
		case isHidden(Dynamic<Bool>)
		case magnificationFilter(Dynamic<CALayerContentsFilter>)
		case masksToBounds(Dynamic<Bool>)
		case minificationFilter(Dynamic<CALayerContentsFilter>)
		case minificationFilterBias(Dynamic<Float>)
		case name(Dynamic<String>)
		case needsDisplayOnBoundsChange(Dynamic<Bool>)
		case opacity(Dynamic<Float>)
		case isOpaque(Dynamic<Bool>)
		case position(Dynamic<CGPoint>)
		case rasterizationScale(Dynamic<CGFloat>)
		case shadowColor(Dynamic<CGColor?>)
		case shadowOffset(Dynamic<CGSize>)
		case shadowOpacity(Dynamic<Float>)
		case shadowPath(Dynamic<CGPath?>)
		case shadowRadius(Dynamic<CGFloat>)
		case shouldRasterize(Dynamic<Bool>)
		case style(Dynamic<[AnyHashable: Any]>)
		case sublayerTransform(Dynamic<CATransform3D>)
		case transform(Dynamic<CATransform3D>)
		case zPosition(Dynamic<CGFloat>)
		case mask(Dynamic<LayerConvertible?>)
		case sublayers(Dynamic<[LayerConvertible]>)
		
		#if os(macOS)
			case autoresizingMask(Dynamic<CAAutoresizingMask>)
			case backgroundFilters(Dynamic<[CIFilter]?>)
			case compositingFilter(Dynamic<CIFilter?>)
			case filters(Dynamic<[CIFilter]?>)
		#else
			@available(*, unavailable)
			case autoresizingMask(())
			@available(*, unavailable)
			case backgroundFilters(())
			@available(*, unavailable)
			case compositingFilter(())
			@available(*, unavailable)
			case filters(())
		#endif
		
		//	2. Signal bindings are performed on the object after construction.
		case addAnimation(Signal<AnimationForKey>)
		case needsDisplay(Signal<Void>)
		case needsDisplayInRect(Signal<CGRect>)
		case removeAllAnimations(Signal<String>)
		case removeAnimationForKey(Signal<String>)
		case scrollRectToVisible(Signal<CGRect>)
		
		//	3. Action bindings are triggered by the object after construction.
		
		//	4. Delegate bindings require synchronous evaluation within the object's context.
	}
	
	struct Preparer: StoragePreparer {
		typealias EnclosingBinder = BackingLayer
		var linkedPreparer = EnclosingBinder.Inherited.Preparer()
		
		func constructStorage() -> EnclosingBinder.Storage { return Storage() }
		
		init() {}
		
		func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
			switch binding {
			case .autoresizingMask(let x):
				#if os(macOS)
					return x.apply(instance, storage) { i, s, v in i.autoresizingMask = v }
				#else
					return nil
				#endif
			case .backgroundFilters(let x):
				#if os(macOS)
					return x.apply(instance, storage) { i, s, v in i.backgroundFilters = v }
				#else
					return nil
				#endif
			case .compositingFilter(let x):
				#if os(macOS)
					return x.apply(instance, storage) { i, s, v in i.compositingFilter = v }
				#else
					return nil
				#endif
			case .filters(let x):
				#if os(macOS)
					return x.apply(instance, storage) { i, s, v in i.filters = v }
				#else
					return nil
				#endif
			case .sublayers(let x):
				return x.apply(instance, storage) { i, s, v in
					i.sublayers = v.map { $0.cgLayer }
				}
			case .affineTransform(let x): return x.apply(instance, storage) { i, s, v in i.setAffineTransform(v) }
			case .anchorPoint(let x): return x.apply(instance, storage) { i, s, v in i.anchorPoint = v }
			case .anchorPointZ(let x): return x.apply(instance, storage) { i, s, v in i.anchorPointZ = v }
			case .backgroundColor(let x): return x.apply(instance, storage) { i, s, v in i.backgroundColor = v }
			case .borderColor(let x): return x.apply(instance, storage) { i, s, v in i.borderColor = v }
			case .borderWidth(let x): return x.apply(instance, storage) { i, s, v in i.borderWidth = v }
			case .bounds(let x): return x.apply(instance, storage) { i, s, v in i.bounds = v }
			case .contents(let x): return x.apply(instance, storage) { i, s, v in i.contents = v }
			case .contentsCenter(let x): return x.apply(instance, storage) { i, s, v in i.contentsCenter = v }
			case .contentsGravity(let x): return x.apply(instance, storage) { i, s, v in i.contentsGravity = v }
			case .contentsRect(let x): return x.apply(instance, storage) { i, s, v in i.contentsRect = v }
			case .contentsScale(let x): return x.apply(instance, storage) { i, s, v in i.contentsScale = v }
			case .cornerRadius(let x): return x.apply(instance, storage) { i, s, v in i.cornerRadius = v }
			case .isDoubleSided(let x): return x.apply(instance, storage) { i, s, v in i.isDoubleSided = v }
			case .drawsAsynchronously(let x): return x.apply(instance, storage) { i, s, v in i.drawsAsynchronously = v }
			case .edgeAntialiasingMask(let x): return x.apply(instance, storage) { i, s, v in i.edgeAntialiasingMask = v }
			case .frame(let x): return x.apply(instance, storage) { i, s, v in i.frame = v }
			case .isGeometryFlipped(let x): return x.apply(instance, storage) { i, s, v in i.isGeometryFlipped = v }
			case .isHidden(let x): return x.apply(instance, storage) { i, s, v in i.isHidden = v }
			case .magnificationFilter(let x): return x.apply(instance, storage) { i, s, v in i.magnificationFilter = v }
			case .masksToBounds(let x): return x.apply(instance, storage) { i, s, v in i.masksToBounds = v }
			case .minificationFilter(let x): return x.apply(instance, storage) { i, s, v in i.minificationFilter = v }
			case .minificationFilterBias(let x): return x.apply(instance, storage) { i, s, v in i.minificationFilterBias = v }
			case .name(let x): return x.apply(instance, storage) { i, s, v in i.name = v }
			case .needsDisplayOnBoundsChange(let x): return x.apply(instance, storage) { i, s, v in i.needsDisplayOnBoundsChange = v }
			case .opacity(let x): return x.apply(instance, storage) { i, s, v in i.opacity = v }
			case .isOpaque(let x): return x.apply(instance, storage) { i, s, v in i.isOpaque = v }
			case .position(let x): return x.apply(instance, storage) { i, s, v in i.position = v }
			case .rasterizationScale(let x): return x.apply(instance, storage) { i, s, v in i.rasterizationScale = v }
			case .shadowColor(let x): return x.apply(instance, storage) { i, s, v in i.shadowColor = v }
			case .shadowOffset(let x): return x.apply(instance, storage) { i, s, v in i.shadowOffset = v }
			case .shadowOpacity(let x): return x.apply(instance, storage) { i, s, v in i.shadowOpacity = v }
			case .shadowPath(let x): return x.apply(instance, storage) { i, s, v in i.shadowPath = v }
			case .shadowRadius(let x): return x.apply(instance, storage) { i, s, v in i.shadowRadius = v }
			case .shouldRasterize(let x): return x.apply(instance, storage) { i, s, v in i.shouldRasterize = v }
			case .style(let x): return x.apply(instance, storage) { i, s, v in i.style = v }
			case .sublayerTransform(let x): return x.apply(instance, storage) { i, s, v in i.sublayerTransform = v }
			case .transform(let x): return x.apply(instance, storage) { i, s, v in i.transform = v }
			case .zPosition(let x): return x.apply(instance, storage) { i, s, v in i.zPosition = v }
			case .addAnimation(let x): return x.apply(instance, storage) { i, s, v in i.add(v.animation, forKey: v.key) }
			case .needsDisplay(let x): return x.apply(instance, storage) { i, s, v in i.setNeedsDisplay() }
			case .needsDisplayInRect(let x): return x.apply(instance, storage) { i, s, v in i.setNeedsDisplay(v) }
			case .removeAllAnimations(let x): return x.apply(instance, storage) { i, s, v in i.removeAllAnimations() }
			case .removeAnimationForKey(let x): return x.apply(instance, storage) { i, s, v in i.removeAnimation(forKey: v) }
			case .scrollRectToVisible(let x): return x.apply(instance, storage) { i, s, v in i.scrollRectToVisible(v) }
			case .actions(let x):
				return x.apply(instance, storage) { i, s, v in
					var actions = i.actions ?? [String: CAAction]()
					for (key, input) in v {
						if let i = input {
							actions[key] = storage
							storage.layerActions[key] = i
						} else {
							actions[key] = NSNull()
							storage.layerActions.removeValue(forKey: key)
						}
					}
					i.actions = actions
				}
			case .mask(let x):
				return x.apply(instance, storage) { i, s, v in
					i.mask = v?.cgLayer
				}
			case .inheritedBinding(let s):
				return linkedPreparer.applyBinding(s, instance: (), storage: ())
			}
		}
	}
	
	class Storage: ObjectBinderStorage, CAAction {
		override var inUse: Bool {
			return super.inUse || !layerActions.isEmpty
		}
		
		// LayerBinderStorage implementation
		var layerActions = [String: SignalInput<[AnyHashable: Any]?>]()
		@objc func run(forKey event: String, object anObject: Any, arguments dict: [AnyHashable: Any]?) {
			_ = layerActions[event]?.send(value: dict)
		}
	}
}

extension BindingName where Binding: BackingLayerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.$1(v)) }) }
	static var affineTransform: BindingName<Dynamic<CGAffineTransform>, Binding> { return BindingName<Dynamic<CGAffineTransform>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.affineTransform(v)) }) }
	static var anchorPoint: BindingName<Dynamic<CGPoint>, Binding> { return BindingName<Dynamic<CGPoint>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.anchorPoint(v)) }) }
	static var anchorPointZ: BindingName<Dynamic<CGFloat>, Binding> { return BindingName<Dynamic<CGFloat>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.anchorPointZ(v)) }) }
	static var actions: BindingName<Dynamic<[String: SignalInput<[AnyHashable: Any]?>?]>, Binding> { return BindingName<Dynamic<[String: SignalInput<[AnyHashable: Any]?>?]>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.actions(v)) }) }
	static var backgroundColor: BindingName<Dynamic<CGColor?>, Binding> { return BindingName<Dynamic<CGColor?>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.backgroundColor(v)) }) }
	static var borderColor: BindingName<Dynamic<CGColor?>, Binding> { return BindingName<Dynamic<CGColor?>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.borderColor(v)) }) }
	static var borderWidth: BindingName<Dynamic<CGFloat>, Binding> { return BindingName<Dynamic<CGFloat>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.borderWidth(v)) }) }
	static var bounds: BindingName<Dynamic<CGRect>, Binding> { return BindingName<Dynamic<CGRect>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.bounds(v)) }) }
	static var contents: BindingName<Dynamic<Any?>, Binding> { return BindingName<Dynamic<Any?>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.contents(v)) }) }
	static var contentsCenter: BindingName<Dynamic<CGRect>, Binding> { return BindingName<Dynamic<CGRect>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.contentsCenter(v)) }) }
	static var contentsGravity: BindingName<Dynamic<CALayerContentsGravity>, Binding> { return BindingName<Dynamic<CALayerContentsGravity>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.contentsGravity(v)) }) }
	static var contentsRect: BindingName<Dynamic<CGRect>, Binding> { return BindingName<Dynamic<CGRect>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.contentsRect(v)) }) }
	static var contentsScale: BindingName<Dynamic<CGFloat>, Binding> { return BindingName<Dynamic<CGFloat>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.contentsScale(v)) }) }
	static var cornerRadius: BindingName<Dynamic<CGFloat>, Binding> { return BindingName<Dynamic<CGFloat>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.cornerRadius(v)) }) }
	static var isDoubleSided: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.isDoubleSided(v)) }) }
	static var drawsAsynchronously: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.drawsAsynchronously(v)) }) }
	static var edgeAntialiasingMask: BindingName<Dynamic<CAEdgeAntialiasingMask>, Binding> { return BindingName<Dynamic<CAEdgeAntialiasingMask>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.edgeAntialiasingMask(v)) }) }
	static var frame: BindingName<Dynamic<CGRect>, Binding> { return BindingName<Dynamic<CGRect>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.frame(v)) }) }
	static var isGeometryFlipped: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.isGeometryFlipped(v)) }) }
	static var isHidden: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.isHidden(v)) }) }
	static var magnificationFilter: BindingName<Dynamic<CALayerContentsFilter>, Binding> { return BindingName<Dynamic<CALayerContentsFilter>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.magnificationFilter(v)) }) }
	static var masksToBounds: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.masksToBounds(v)) }) }
	static var minificationFilter: BindingName<Dynamic<CALayerContentsFilter>, Binding> { return BindingName<Dynamic<CALayerContentsFilter>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.minificationFilter(v)) }) }
	static var minificationFilterBias: BindingName<Dynamic<Float>, Binding> { return BindingName<Dynamic<Float>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.minificationFilterBias(v)) }) }
	static var name: BindingName<Dynamic<String>, Binding> { return BindingName<Dynamic<String>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.name(v)) }) }
	static var needsDisplayOnBoundsChange: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.needsDisplayOnBoundsChange(v)) }) }
	static var opacity: BindingName<Dynamic<Float>, Binding> { return BindingName<Dynamic<Float>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.opacity(v)) }) }
	static var isOpaque: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.isOpaque(v)) }) }
	static var position: BindingName<Dynamic<CGPoint>, Binding> { return BindingName<Dynamic<CGPoint>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.position(v)) }) }
	static var rasterizationScale: BindingName<Dynamic<CGFloat>, Binding> { return BindingName<Dynamic<CGFloat>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.rasterizationScale(v)) }) }
	static var shadowColor: BindingName<Dynamic<CGColor?>, Binding> { return BindingName<Dynamic<CGColor?>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.shadowColor(v)) }) }
	static var shadowOffset: BindingName<Dynamic<CGSize>, Binding> { return BindingName<Dynamic<CGSize>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.shadowOffset(v)) }) }
	static var shadowOpacity: BindingName<Dynamic<Float>, Binding> { return BindingName<Dynamic<Float>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.shadowOpacity(v)) }) }
	static var shadowPath: BindingName<Dynamic<CGPath?>, Binding> { return BindingName<Dynamic<CGPath?>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.shadowPath(v)) }) }
	static var shadowRadius: BindingName<Dynamic<CGFloat>, Binding> { return BindingName<Dynamic<CGFloat>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.shadowRadius(v)) }) }
	static var shouldRasterize: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.shouldRasterize(v)) }) }
	static var style: BindingName<Dynamic<[AnyHashable: Any]>, Binding> { return BindingName<Dynamic<[AnyHashable: Any]>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.style(v)) }) }
	static var sublayerTransform: BindingName<Dynamic<CATransform3D>, Binding> { return BindingName<Dynamic<CATransform3D>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.sublayerTransform(v)) }) }
	static var transform: BindingName<Dynamic<CATransform3D>, Binding> { return BindingName<Dynamic<CATransform3D>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.transform(v)) }) }
	static var zPosition: BindingName<Dynamic<CGFloat>, Binding> { return BindingName<Dynamic<CGFloat>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.zPosition(v)) }) }
	static var mask: BindingName<Dynamic<LayerConvertible?>, Binding> { return BindingName<Dynamic<LayerConvertible?>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.mask(v)) }) }
	static var sublayers: BindingName<Dynamic<[LayerConvertible]>, Binding> { return BindingName<Dynamic<[LayerConvertible]>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.sublayers(v)) }) }
	#if os(macOS)
		static var autoresizingMask: BindingName<Dynamic<CAAutoresizingMask>, Binding> { return BindingName<Dynamic<CAAutoresizingMask>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.autoresizingMask(v)) }) }
		static var backgroundFilters: BindingName<Dynamic<[CIFilter]?>, Binding> { return BindingName<Dynamic<[CIFilter]?>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.backgroundFilters(v)) }) }
		static var compositingFilter: BindingName<Dynamic<CIFilter?>, Binding> { return BindingName<Dynamic<CIFilter?>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.compositingFilter(v)) }) }
		static var filters: BindingName<Dynamic<[CIFilter]?>, Binding> { return BindingName<Dynamic<[CIFilter]?>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.filters(v)) }) }
	#endif
	static var addAnimation: BindingName<Signal<AnimationForKey>, Binding> { return BindingName<Signal<AnimationForKey>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.addAnimation(v)) }) }
	static var needsDisplay: BindingName<Signal<Void>, Binding> { return BindingName<Signal<Void>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.needsDisplay(v)) }) }
	static var needsDisplayInRect: BindingName<Signal<CGRect>, Binding> { return BindingName<Signal<CGRect>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.needsDisplayInRect(v)) }) }
	static var removeAllAnimations: BindingName<Signal<String>, Binding> { return BindingName<Signal<String>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.removeAllAnimations(v)) }) }
	static var removeAnimationForKey: BindingName<Signal<String>, Binding> { return BindingName<Signal<String>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.removeAnimationForKey(v)) }) }
	static var scrollRectToVisible: BindingName<Signal<CGRect>, Binding> { return BindingName<Signal<CGRect>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.scrollRectToVisible(v)) }) }
}

protocol BackingLayerBinding: BaseBinding {
	static func backingLayerBinding(_ binding: BackingLayer.Binding) -> Self
}

extension BackingLayerBinding {
	static func baseBinding(_ binding: BaseBinder.Binding) -> Self {
		return backingLayerBinding(.inheritedBinding(binding))
	}
}

struct AnimationForKey {
	let animation: CAAnimation
	let key: String?
	
	init(animation: CAAnimation, forKey: String? = nil) {
		self.animation = animation
		self.key = forKey
	}
	
	static var fade: AnimationForKey {
		let t = CATransition()
		t.type = CATransitionType.fade
		return AnimationForKey(animation: t)
	}
	
	enum Direction {
		case left
		case right
		case top
		case bottom
		
		func transition(ofType: CATransitionType) -> AnimationForKey {
			let t = CATransition()
			t.type = ofType
			switch self {
			case .left: t.subtype = CATransitionSubtype.fromLeft
			case .right: t.subtype = CATransitionSubtype.fromRight
			case .top: t.subtype = CATransitionSubtype.fromTop
			case .bottom: t.subtype = CATransitionSubtype.fromBottom
			}
			return AnimationForKey(animation: t)
		}
	}
	
	static func moveIn(from: Direction) -> AnimationForKey {
		return from.transition(ofType: CATransitionType.moveIn)
	}
	
	static func push(from: Direction) -> AnimationForKey {
		return from.transition(ofType: CATransitionType.push)
	}
	
	static func reveal(from: Direction) -> AnimationForKey {
		return from.transition(ofType: CATransitionType.reveal)
	}
}

class GradientLayer: ConstructingBinder, GradientLayerConvertible {
	typealias Instance = CAGradientLayer
	typealias Inherited = Layer
	
	var state: BinderState<Instance, BinderSubclassParameters<Instance, Binding>>
	required init(state: ConstructingBinderState<Instance, Binding>) {
		self.state = state
	}
	static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	func uiGradientLayer() -> Instance { return instance() }

	enum Binding: GradientLayerBinding {
		typealias EnclosingBinder = GradientLayer
		static func gradientLayerBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		//	1. Value bindings may be applied at construction and may subsequently change.
		case colors(Dynamic<[CGColor]>)
		case locations(Dynamic<[CGFloat]>)
		case endPoint(Dynamic<CGPoint>)
		case startPoint(Dynamic<CGPoint>)

		// 2. Signal bindings are performed on the object after construction.

		// 3. Action bindings are triggered by the object after construction.

		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}

	struct Preparer: ConstructingPreparer {
		typealias EnclosingBinder = GradientLayer
		var linkedPreparer = Inherited.Preparer()
		
		func constructStorage() -> EnclosingBinder.Storage { return Storage() }
		func constructInstance(subclass: EnclosingBinder.Instance.Type) -> EnclosingBinder.Instance { return subclass.init() }
		
		init() {}
		
		func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
			switch binding {
			case .colors(let x): return x.apply(instance, storage) { i, s, v in i.colors = v }
			case .locations(let x): return x.apply(instance, storage) { i, s, v in i.locations = v.map { NSNumber(value: Double($0)) } }
			case .endPoint(let x): return x.apply(instance, storage) { i, s, v in i.endPoint = v }
			case .startPoint(let x): return x.apply(instance, storage) { i, s, v in i.startPoint = v }
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: instance, storage: storage)
			}
		}
	}

	typealias Storage = Layer.Storage
}

extension BindingName where Binding: GradientLayerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .gradientLayerBinding(GradientLayer.Binding.$1(v)) }) }
	static var colors: BindingName<Dynamic<[CGColor]>, Binding> { return BindingName<Dynamic<[CGColor]>, Binding>({ v in .gradientLayerBinding(GradientLayer.Binding.colors(v)) }) }
	static var locations: BindingName<Dynamic<[CGFloat]>, Binding> { return BindingName<Dynamic<[CGFloat]>, Binding>({ v in .gradientLayerBinding(GradientLayer.Binding.locations(v)) }) }
	static var endPoint: BindingName<Dynamic<CGPoint>, Binding> { return BindingName<Dynamic<CGPoint>, Binding>({ v in .gradientLayerBinding(GradientLayer.Binding.endPoint(v)) }) }
	static var startPoint: BindingName<Dynamic<CGPoint>, Binding> { return BindingName<Dynamic<CGPoint>, Binding>({ v in .gradientLayerBinding(GradientLayer.Binding.startPoint(v)) }) }
}

protocol GradientLayerConvertible: LayerConvertible {
	func uiGradientLayer() -> GradientLayer.Instance
}
extension GradientLayerConvertible {
	var cgLayer: Layer.Instance { return uiGradientLayer() }
}
extension GradientLayer.Instance: GradientLayerConvertible {
	func uiGradientLayer() -> GradientLayer.Instance { return self }
}

protocol GradientLayerBinding: LayerBinding {
	static func gradientLayerBinding(_ binding: GradientLayer.Binding) -> Self
}

extension GradientLayerBinding {
	static func layerBinding(_ binding: Layer.Binding) -> Self {
		return gradientLayerBinding(.inheritedBinding(binding))
	}
}

import WebKit

class WebView: ConstructingBinder, WebViewConvertible {
	typealias Instance = WKWebView
	typealias Inherited = View
	
	var state: ConstructingBinderState<Instance, Binding>
	required init(state: ConstructingBinderState<Instance, Binding>) {
		self.state = state
	}
	static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	var wkWebView: Instance { return instance() }
	
	enum Binding: WebViewBinding {
		typealias EnclosingBinder = WebView
		static func webViewBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case configuration(Constant<WKWebViewConfiguration>)
		#if os(iOS)
			case scrollView(Constant<ScrollView>)
		#else
			@available(*, unavailable)
			case scrollView(())
		#endif
		
		//	1. Value bindings may be applied at construction and may subsequently change.
		@available(macOS 10.11, *)
		case customUserAgent(Dynamic<String?>)
		#if os(macOS)
			case allowsMagnification(Dynamic<Bool>)
			case magnification(Dynamic<(factor: CGFloat, centeredAt: CGPoint)>)
		#else
			@available(*, unavailable)
			case allowsMagnification(())
			@available(*, unavailable)
			case magnification(())
		#endif
		case allowsBackForwardNavigationGestures(Dynamic<Bool>)
		@available(macOS 10.11, *)
		case allowsLinkPreview(Dynamic<Bool>)
		
		//	2. Signal bindings are performed on the object after construction.
		case load(Signal<Callback<URLRequest, WKNavigation?>>)
		@available(macOS 10.11, *)
		case loadFile(Signal<Callback<(url: URL, allowingReadAccessTo: URL), WKNavigation?>>)
		case loadHTMLString(Signal<Callback<(string: String, baseURL: URL?), WKNavigation?>>)
		@available(macOS 10.11, *)
		case loadData(Signal<Callback<(data: Data, mimeType: String, baseURL: URL, characterEncodingName: String), WKNavigation?>>)
		case reload(Signal<Callback<Void, WKNavigation?>>)
		case reloadFromOrigin(Signal<Callback<Void, WKNavigation?>>)
		case goBack(Signal<Callback<Void, WKNavigation?>>)
		case goForward(Signal<Callback<Void, WKNavigation?>>)
		case goTo(Signal<Callback<WKBackForwardListItem, WKNavigation?>>)
		case stopLoading(Signal<Void>)
		case evaluateJavaScript(Signal<Callback<String, (Any?, Error?)>>)
		
		//	3. Action bindings are triggered by the object after construction.
		case didCommit(SignalInput<WKNavigation>)
		case didStartProvisionalNavigation(SignalInput<WKNavigation>)
		case didReceiveServerRedirectForProvisionalNavigation(SignalInput<WKNavigation>)
		case didFail(SignalInput<(WKNavigation, Error)>)
		case didFailProvisionalNavigation(SignalInput<(WKNavigation, Error)>)
		case didFinish(SignalInput<WKNavigation>)
		case contentProcessDidTerminate(SignalInput<Void>)
		case decideActionPolicy(SignalInput<Callback<WKNavigationAction, WKNavigationActionPolicy>>)
		case decideResponsePolicy(SignalInput<Callback<WKNavigationResponse, WKNavigationResponsePolicy>>)
		case didReceiveAuthenticationChallenge(SignalInput<Callback<URLAuthenticationChallenge, (URLSession.AuthChallengeDisposition, URLCredential?)>>)
		case runJavaScriptAlertPanel(SignalInput<Callback<(message: String, frame: WKFrameInfo), ()>>)
		case runJavaScriptConfirmPanel(SignalInput<Callback<(message: String, frame: WKFrameInfo), Bool>>)
		case runJavaScriptTextInputPanel(SignalInput<Callback<(prompt: String, defaultText: String?, frame: WKFrameInfo), String?>>)
		@available(macOS 10.11, iOS 9.0, *)
		case didClose(SignalInput<Void>)
		#if os(macOS)
			@available(macOS 10.12, *)
			case runOpenPanel(SignalInput<(parameters: WKOpenPanelParameters, frame: WKFrameInfo, completion: SignalInput<[URL]?>)>)
		#else
			@available(*, unavailable)
			case runOpenPanel(())
		#endif
		
		//	4. Delegate bindings require synchronous evaluation within the object's context.
		case createWebView((_ webView: WKWebView, _ with: WKWebViewConfiguration, _ for: WKNavigationAction, _ windowFeatures: WKWindowFeatures) -> WKWebView?)
		#if os(iOS)
			@available(iOS 10.0, *)
			case shouldPreviewElement((_ webView: WKWebView, _ elementInfo: WKPreviewElementInfo) -> Bool)
			@available(iOS 10.0, *)
			case previewingViewController((_ webView: WKWebView, _ elementInfo: WKPreviewElementInfo, _ previewActions: [WKPreviewActionItem]) -> UIViewController?)
			@available(iOS 10.0, *)
			case commitPreviewingViewController((_ webView: WKWebView, _ previewingViewController: UIViewController) -> Void)
		#else
			@available(*, unavailable)
			case shouldPreviewElement(())
			@available(*, unavailable)
			case previewingViewController(())
			@available(*, unavailable)
			case commitPreviewingViewController(())
		#endif
	}

	struct Preparer: ConstructingPreparer {
		typealias EnclosingBinder = WebView
		var linkedPreparer = Inherited.Preparer()
		
		func constructStorage() -> EnclosingBinder.Storage { return Storage() }
		func constructInstance(subclass: EnclosingBinder.Instance.Type) -> EnclosingBinder.Instance { return subclass.init(frame: .zero, configuration: configuration ?? WKWebViewConfiguration()) }
		
		init() {
			self.init(delegateClass: Delegate.self)
		}
		init<Value>(delegateClass: Value.Type) where Value: Delegate {
			self.delegateClass = delegateClass
		}
		let delegateClass: Delegate.Type
		var possibleDelegate: Delegate? = nil
		mutating func delegate() -> Delegate {
			if let d = possibleDelegate {
				return d
			} else {
				let d = delegateClass.init()
				possibleDelegate = d
				return d
			}
		}
		
		var configuration: WKWebViewConfiguration?
		
		mutating func prepareBinding(_ binding: Binding) {
			switch binding {
			case .configuration(let x): configuration = x.value
			case .didCommit(let x):
				let s = #selector(WKNavigationDelegate.webView(_:didCommit:))
				delegate().addSelector(s).didCommit = x
			case .didStartProvisionalNavigation(let x):
				let s = #selector(WKNavigationDelegate.webView(_:didStartProvisionalNavigation:))
				delegate().addSelector(s).didStartProvisionalNavigation = x
			case .didReceiveServerRedirectForProvisionalNavigation(let x):
				let s = #selector(WKNavigationDelegate.webView(_:didReceiveServerRedirectForProvisionalNavigation:))
				delegate().addSelector(s).didReceiveServerRedirectForProvisionalNavigation = x
			case .didFail(let x):
				let s = #selector(WKNavigationDelegate.webView(_:didFail:withError:))
				delegate().addSelector(s).didFail = x
			case .didFailProvisionalNavigation(let x):
				let s = #selector(WKNavigationDelegate.webView(_:didFailProvisionalNavigation:withError:))
				delegate().addSelector(s).didFailProvisionalNavigation = x
			case .didFinish(let x):
				let s = #selector(WKNavigationDelegate.webView(_:didFinish:))
				delegate().addSelector(s).didFinish = x
			case .contentProcessDidTerminate(let x):
				if #available(macOS 10.11, *) {
					let s = #selector(WKNavigationDelegate.webViewWebContentProcessDidTerminate(_:))
					delegate().addSelector(s).contentProcessDidTerminate = x
				}
			case .decideActionPolicy(let x):
				let s = #selector(WKNavigationDelegate.webView(_:decidePolicyFor:decisionHandler:) as ((WKNavigationDelegate) -> (WKWebView,WKNavigationAction, @escaping (WKNavigationActionPolicy) -> Void) -> Void)?)
				delegate().addSelector(s).decideActionPolicy = x
			case .decideResponsePolicy(let x):
				let s = #selector(WKNavigationDelegate.webView(_:decidePolicyFor:decisionHandler:) as ((WKNavigationDelegate) -> (WKWebView, WKNavigationResponse, @escaping (WKNavigationResponsePolicy) -> Void) -> Void)?)
				delegate().addSelector(s).decideResponsePolicy = x
			case .didReceiveAuthenticationChallenge(let x):
				let s = #selector(WKNavigationDelegate.webView(_:didReceive:completionHandler:))
				delegate().addSelector(s).didReceiveAuthenticationChallenge = x
			case .runJavaScriptAlertPanel(let x):
				let s = #selector(WKUIDelegate.webView(_:runJavaScriptAlertPanelWithMessage:initiatedByFrame:completionHandler:))
				delegate().addSelector(s).runJavaScriptAlertPanel = x
			case .runJavaScriptConfirmPanel(let x):
				let s = #selector(WKUIDelegate.webView(_:runJavaScriptConfirmPanelWithMessage:initiatedByFrame:completionHandler:))
				delegate().addSelector(s).runJavaScriptConfirmPanel = x
			case .runJavaScriptTextInputPanel(let x):
				let s = #selector(WKUIDelegate.webView(_:runJavaScriptTextInputPanelWithPrompt:defaultText:initiatedByFrame:completionHandler:))
				delegate().addSelector(s).runJavaScriptTextInputPanel = x
			case .createWebView(let x):
				let s = #selector(WKUIDelegate.webView(_:createWebViewWith:for:windowFeatures:))
				delegate().addSelector(s).createWebView = x
			case .didClose(let x):
				if #available(macOS 10.11, iOS 9.0, *) {
					let s = #selector(WKUIDelegate.webViewDidClose(_:))
					delegate().addSelector(s).didClose = x
				}
			case .runOpenPanel(let x):
				#if os(macOS)
					if #available(macOS 10.12, *) {
						let s = #selector(WKUIDelegate.webView(_:runOpenPanelWith:initiatedByFrame:completionHandler:))
						delegate().addSelector(s).runOpenPanel = x
					}
				#endif
			case .shouldPreviewElement(let x):
				#if os(iOS)
					if #available(iOS 10.0, *) {
						let s = #selector(WKUIDelegate.webView(_:shouldPreviewElement:))
						delegate().addSelector(s).shouldPreviewElement = x
					}
				#endif
			case .previewingViewController(let x):
				#if os(iOS)
					if #available(iOS 10.0, *) {
						let s = #selector(WKUIDelegate.webView(_:previewingViewControllerForElement:defaultActions:))
						delegate().addSelector(s).previewingViewController = x
					}
				#endif
			case .commitPreviewingViewController(let x):
				#if os(iOS)
					if #available(iOS 10.0, *) {
						let s = #selector(WKUIDelegate.webView(_:commitPreviewingViewController:))
						delegate().addSelector(s).commitPreviewingViewController = x
					}
				#endif
			case .inheritedBinding(let x): linkedPreparer.prepareBinding(x)
			default: break
			}
		}
		
		mutating func prepareInstance(_ instance: Instance, storage: Storage) {
			if possibleDelegate != nil {
				precondition(instance.navigationDelegate == nil && instance.uiDelegate == nil, "Conflicting delegate applied to instance")
				storage.dynamicDelegate = possibleDelegate
				instance.navigationDelegate = storage
				instance.uiDelegate = storage
			}
			
			linkedPreparer.prepareInstance(instance, storage: storage)
		}

		func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
			switch binding {
			case .configuration: return nil
			case .scrollView(let x):
				#if os(macOS)
					return nil
				#else
					x.value.applyBindings(to: instance.scrollView)
					return nil
				#endif
			case .customUserAgent(let x):
				return x.apply(instance, storage) { i, s, v in
					if #available(macOS 10.11, *) {
						i.customUserAgent = v
					}
				}
			case .allowsMagnification(let x):
				#if os(macOS)
					return x.apply(instance, storage) { i, s, v in i.allowsMagnification = v }
				#else
					return nil
				#endif
			case .magnification(let x):
				#if os(macOS)
					return x.apply(instance, storage) { i, s, v in i.setMagnification(v.factor, centeredAt: v.centeredAt) }
				#else
					return nil
				#endif
			case .allowsBackForwardNavigationGestures(let x): return x.apply(instance, storage) { i, s, v in i.allowsBackForwardNavigationGestures = v }
			case .allowsLinkPreview(let x):
				return x.apply(instance, storage) { i, s, v in
					if #available(macOS 10.11, *) {
						i.allowsLinkPreview = v
					}
				}
			case .load(let x):
				return x.apply(instance, storage) { i, s, v in
					let n = i.load(v.value)
					v.callback?.send(value: n)
				}
			case .loadFile(let x):
				return x.apply(instance, storage) { i, s, v in
					if #available(macOS 10.11, *) {
						let n = i.loadFileURL(v.value.url, allowingReadAccessTo: v.value.allowingReadAccessTo)
						v.callback?.send(value: n)
					}
				}
			case .loadHTMLString(let x):
				return x.apply(instance, storage) { i, s, v in
					let n = i.loadHTMLString(v.value.string, baseURL: v.value.baseURL)
					v.callback?.send(value: n)
				}
			case .loadData(let x):
				return x.apply(instance, storage) { i, s, v in
					if #available(macOS 10.11, *) {
						let n = i.load(v.value.data, mimeType: v.value.mimeType, characterEncodingName: v.value.characterEncodingName, baseURL: v.value.baseURL)
						v.callback?.send(value: n)
					}
				}
			case .reload(let x):
				return x.apply(instance, storage) { i, s, v in
					let n = i.reload()
					v.callback?.send(value: n)
				}
			case .reloadFromOrigin(let x):
				return x.apply(instance, storage) { i, s, v in
					let n = i.reloadFromOrigin()
					v.callback?.send(value: n)
				}
			case .goBack(let x):
				return x.apply(instance, storage) { i, s, v in
					let n = i.goBack()
					v.callback?.send(value: n)
				}
			case .goForward(let x):
				return x.apply(instance, storage) { i, s, v in
					let n = i.goForward()
					v.callback?.send(value: n)
				}
			case .goTo(let x):
				return x.apply(instance, storage) { i, s, v in
					let n = i.go(to: v.value)
					v.callback?.send(value: n)
				}
			case .stopLoading(let x):
				return x.apply(instance, storage) { i, s, v in i.stopLoading() }
			case .evaluateJavaScript(let x):
				return x.apply(instance, storage) { i, s, v in
					i.evaluateJavaScript(v.value) { (output, error) in
						v.callback?.send(value: (output, error))
					}
				}
				
			case .didCommit: return nil
			case .didStartProvisionalNavigation: return nil
			case .didReceiveServerRedirectForProvisionalNavigation: return nil
			case .didFail: return nil
			case .didFailProvisionalNavigation: return nil
			case .didFinish: return nil
			case .contentProcessDidTerminate: return nil
			case .decideActionPolicy: return nil
			case .decideResponsePolicy: return nil
			case .didReceiveAuthenticationChallenge: return nil
			case .runJavaScriptAlertPanel: return nil
			case .runJavaScriptConfirmPanel: return nil
			case .runJavaScriptTextInputPanel: return nil
			case .didClose: return nil
			case .runOpenPanel: return nil
			case .createWebView: return nil
			case .shouldPreviewElement: return nil
			case .previewingViewController: return nil
			case .commitPreviewingViewController: return nil
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: instance, storage: storage)
			}
		}
	}

	class Storage: View.Storage, WKUIDelegate, WKNavigationDelegate {}

	class Delegate: DynamicDelegate, WKUIDelegate, WKNavigationDelegate {
		required override init() {
			super.init()
		}
		
		var didCommit: SignalInput<WKNavigation>?
		func webView(_ webView: WKWebView, didCommit navigation: WKNavigation!) {
			didCommit!.send(value: navigation)
		}
		
		var didStartProvisionalNavigation: SignalInput<WKNavigation>?
		func webView(_ webView: WKWebView, didStartProvisionalNavigation navigation: WKNavigation!) {
			didStartProvisionalNavigation!.send(value: navigation)
		}
		
		var didReceiveServerRedirectForProvisionalNavigation: SignalInput<WKNavigation>?
		func webView(_ webView: WKWebView, didReceiveServerRedirectForProvisionalNavigation navigation: WKNavigation!) {
			didReceiveServerRedirectForProvisionalNavigation!.send(value: navigation)
		}
		
		var didFail: SignalInput<(WKNavigation, Error)>?
		func webView(_ webView: WKWebView, didFail navigation: WKNavigation!, withError error: Error) {
			didFail!.send(value: (navigation, error))
		}
		
		var didFailProvisionalNavigation: SignalInput<(WKNavigation, Error)>?
		func webView(_ webView: WKWebView, didFailProvisionalNavigation navigation: WKNavigation!, withError error: Error) {
			didFailProvisionalNavigation!.send(value: (navigation, error))
		}
		
		var didFinish: SignalInput<WKNavigation>?
		func webView(_ webView: WKWebView, didFinish navigation: WKNavigation!) {
			didFinish!.send(value: navigation)
		}
		
		var contentProcessDidTerminate: SignalInput<Void>?
		func webViewWebContentProcessDidTerminate(_ webView: WKWebView) {
			contentProcessDidTerminate!.send(value: ())
		}
		
		var decideActionPolicy: SignalInput<Callback<WKNavigationAction, WKNavigationActionPolicy>>?
		func webView(_ webView: WKWebView, decidePolicyFor navigationAction: WKNavigationAction, decisionHandler: @escaping (WKNavigationActionPolicy) -> Void) {
			decideActionPolicy!.send(value: Callback(navigationAction, Input().subscribeWhile(context: .main) { r in decisionHandler(r.value ?? .cancel); return false }))
		}
		
		var decideResponsePolicy: SignalInput<Callback<WKNavigationResponse, WKNavigationResponsePolicy>>?
		func webView(_ webView: WKWebView, decidePolicyFor navigationResponse: WKNavigationResponse, decisionHandler: @escaping (WKNavigationResponsePolicy) -> Void) {
			decideResponsePolicy!.send(value: Callback(navigationResponse, Input().subscribeWhile(context: .main) { r in decisionHandler(r.value ?? .cancel); return false }))
		}
		
		var didReceiveAuthenticationChallenge: SignalInput<Callback<URLAuthenticationChallenge, (URLSession.AuthChallengeDisposition, URLCredential?)>>?
		func webView(_ webView: WKWebView, didReceive challenge: URLAuthenticationChallenge, completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void) {
			didReceiveAuthenticationChallenge!.send(value: Callback(challenge, Input().subscribeWhile(context: .main) { r in completionHandler(r.value?.0 ?? .cancelAuthenticationChallenge, r.value?.1); return false }))
		}
		
		var runJavaScriptAlertPanel: SignalInput<Callback<(message: String, frame: WKFrameInfo), ()>>?
		func webView(_ webView: WKWebView, runJavaScriptAlertPanelWithMessage message: String, initiatedByFrame frame: WKFrameInfo, completionHandler: @escaping () -> Void) {
			runJavaScriptAlertPanel!.send(value: Callback((message: message, frame: frame), Input().subscribeWhile(context: .main) { r in completionHandler(); return false }))
		}
		
		var runJavaScriptConfirmPanel: SignalInput<Callback<(message: String, frame: WKFrameInfo), Bool>>?
		func webView(_ webView: WKWebView, runJavaScriptConfirmPanelWithMessage message: String, initiatedByFrame frame: WKFrameInfo, completionHandler: @escaping (Bool) -> Void) {
			runJavaScriptConfirmPanel!.send(value: Callback((message: message, frame: frame), Input().subscribeWhile(context: .main) { r in completionHandler(r.value ?? false); return false }))
		}
		
		var runJavaScriptTextInputPanel: SignalInput<Callback<(prompt: String, defaultText: String?, frame: WKFrameInfo), String?>>?
		func webView(_ webView: WKWebView, runJavaScriptTextInputPanelWithPrompt prompt: String, defaultText: String?, initiatedByFrame frame: WKFrameInfo, completionHandler: @escaping (String?) -> Void) {
			runJavaScriptTextInputPanel!.send(value: Callback((prompt: prompt, defaultText: defaultText, frame: frame), Input().subscribeWhile(context: .main) { r in completionHandler(r.value ?? nil); return false }))
		}
		
		var createWebView: ((_ webView: WKWebView, _ configuration: WKWebViewConfiguration, _ navigationAction: WKNavigationAction, _ windowFeatures: WKWindowFeatures) -> WKWebView?)?
		func webView(_ webView: WKWebView, createWebViewWith configuration: WKWebViewConfiguration, for navigationAction: WKNavigationAction, windowFeatures: WKWindowFeatures) -> WKWebView? {
			return createWebView!(webView, configuration, navigationAction, windowFeatures)
		}

		var didClose: SignalInput<Void>?
		func webViewDidClose(_ webView: WKWebView) {
			didClose!.send(value: ())
		}

		#if os(iOS)
			var shouldPreviewElement: Any?
			@available(iOS 10.0, *)
			func webView(_ webView: WKWebView, shouldPreviewElement elementInfo: WKPreviewElementInfo) -> Bool {
				return (shouldPreviewElement as! (_ webView: WKWebView, _ elementInfo: WKPreviewElementInfo) -> Bool)(webView, elementInfo)
			}
			
			var commitPreviewingViewController: ((_ webView: WKWebView, _ previewingViewController: UIViewController) -> Void)?
			func webView(_ webView: WKWebView, commitPreviewingViewController previewingViewController: UIViewController) {
				commitPreviewingViewController!(webView, previewingViewController)
			}
			
			var previewingViewController: Any?
			@available(iOS 10.0, *)
			func webView(_ webView: WKWebView, previewingViewControllerForElement elementInfo: WKPreviewElementInfo, defaultActions previewActions: [WKPreviewActionItem]) -> UIViewController? {
				return (previewingViewController as! (_ webView: WKWebView, _ elementInfo: WKPreviewElementInfo, _ previewActions: [WKPreviewActionItem]) -> UIViewController?)(webView, elementInfo, previewActions)
			}
		#else
			var runOpenPanel: Any?
			@available(macOS 10.12, *)
			func webView(_ webView: WKWebView, runOpenPanelWith parameters: WKOpenPanelParameters, initiatedByFrame frame: WKFrameInfo, completionHandler: @escaping ([URL]?) -> Void) {
				(runOpenPanel as! SignalInput<(parameters: WKOpenPanelParameters, frame: WKFrameInfo, completion: SignalInput<[URL]?>)>).send(value: (parameters: parameters, frame: frame, completion: Input().subscribeWhile(context: .main) { r in completionHandler(r.value ?? nil); return false }))
			}
		#endif
	}
}

extension BindingName where Binding: WebViewBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .webViewBinding(WebView.Binding.$1(v)) }) }

	static var configuration: BindingName<Constant<WKWebViewConfiguration>, Binding> { return BindingName<Constant<WKWebViewConfiguration>, Binding>({ v in .webViewBinding(WebView.Binding.configuration(v)) }) }
	
	#if os(iOS)
		static var scrollView: BindingName<Constant<ScrollView>, Binding> { return BindingName<Constant<ScrollView>, Binding>({ v in .webViewBinding(WebView.Binding.scrollView(v)) }) }
	#endif
	
	//	1. Value bindings may be applied at construction and may subsequently change.
	@available(macOS 10.11, *)
	static var customUserAgent: BindingName<Dynamic<String?>, Binding> { return BindingName<Dynamic<String?>, Binding>({ v in .webViewBinding(WebView.Binding.customUserAgent(v)) }) }
	
	#if os(macOS)
		static var allowsMagnification: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .webViewBinding(WebView.Binding.allowsMagnification(v)) }) }
		static var magnification: BindingName<Dynamic<(factor: CGFloat, centeredAt: CGPoint)>, Binding> { return BindingName<Dynamic<(factor: CGFloat, centeredAt: CGPoint)>, Binding>({ v in .webViewBinding(WebView.Binding.magnification(v)) }) }
	#endif
	
	static var allowsBackForwardNavigationGestures: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .webViewBinding(WebView.Binding.allowsBackForwardNavigationGestures(v)) }) }
	@available(macOS 10.11, *)
	static var allowsLinkPreview: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .webViewBinding(WebView.Binding.allowsLinkPreview(v)) }) }
	
	//	2. Signal bindings are performed on the object after construction.
	static var load: BindingName<Signal<Callback<URLRequest, WKNavigation?>>, Binding> { return BindingName<Signal<Callback<URLRequest, WKNavigation?>>, Binding>({ v in .webViewBinding(WebView.Binding.load(v)) }) }
	@available(macOS 10.11, *)
	static var loadFile: BindingName<Signal<Callback<(url: URL, allowingReadAccessTo: URL), WKNavigation?>>, Binding> { return BindingName<Signal<Callback<(url: URL, allowingReadAccessTo: URL), WKNavigation?>>, Binding>({ v in .webViewBinding(WebView.Binding.loadFile(v)) }) }
	static var loadHTMLString: BindingName<Signal<Callback<(string: String, baseURL: URL?), WKNavigation?>>, Binding> { return BindingName<Signal<Callback<(string: String, baseURL: URL?), WKNavigation?>>, Binding>({ v in .webViewBinding(WebView.Binding.loadHTMLString(v)) }) }
	@available(macOS 10.11, *)
	static var loadData: BindingName<Signal<Callback<(data: Data, mimeType: String, baseURL: URL, characterEncodingName: String), WKNavigation?>>, Binding> { return BindingName<Signal<Callback<(data: Data, mimeType: String, baseURL: URL, characterEncodingName: String), WKNavigation?>>, Binding>({ v in .webViewBinding(WebView.Binding.loadData(v)) }) }
	static var reload: BindingName<Signal<Callback<Void, WKNavigation?>>, Binding> { return BindingName<Signal<Callback<Void, WKNavigation?>>, Binding>({ v in .webViewBinding(WebView.Binding.reload(v)) }) }
	static var reloadFromOrigin: BindingName<Signal<Callback<Void, WKNavigation?>>, Binding> { return BindingName<Signal<Callback<Void, WKNavigation?>>, Binding>({ v in .webViewBinding(WebView.Binding.reloadFromOrigin(v)) }) }
	static var goBack: BindingName<Signal<Callback<Void, WKNavigation?>>, Binding> { return BindingName<Signal<Callback<Void, WKNavigation?>>, Binding>({ v in .webViewBinding(WebView.Binding.goBack(v)) }) }
	static var goForward: BindingName<Signal<Callback<Void, WKNavigation?>>, Binding> { return BindingName<Signal<Callback<Void, WKNavigation?>>, Binding>({ v in .webViewBinding(WebView.Binding.goForward(v)) }) }
	static var goTo: BindingName<Signal<Callback<WKBackForwardListItem, WKNavigation?>>, Binding> { return BindingName<Signal<Callback<WKBackForwardListItem, WKNavigation?>>, Binding>({ v in .webViewBinding(WebView.Binding.goTo(v)) }) }
	static var stopLoading: BindingName<Signal<Void>, Binding> { return BindingName<Signal<Void>, Binding>({ v in .webViewBinding(WebView.Binding.stopLoading(v)) }) }
	static var evaluateJavaScript: BindingName<Signal<Callback<String, (Any?, Error?)>>, Binding> { return BindingName<Signal<Callback<String, (Any?, Error?)>>, Binding>({ v in .webViewBinding(WebView.Binding.evaluateJavaScript(v)) }) }
	
	//	3. Action bindings are triggered by the object after construction.
	static var didCommit: BindingName<SignalInput<WKNavigation>, Binding> { return BindingName<SignalInput<WKNavigation>, Binding>({ v in .webViewBinding(WebView.Binding.didCommit(v)) }) }
	static var didStartProvisionalNavigation: BindingName<SignalInput<WKNavigation>, Binding> { return BindingName<SignalInput<WKNavigation>, Binding>({ v in .webViewBinding(WebView.Binding.didStartProvisionalNavigation(v)) }) }
	static var didReceiveServerRedirectForProvisionalNavigation: BindingName<SignalInput<WKNavigation>, Binding> { return BindingName<SignalInput<WKNavigation>, Binding>({ v in .webViewBinding(WebView.Binding.didReceiveServerRedirectForProvisionalNavigation(v)) }) }
	static var didFail: BindingName<SignalInput<(WKNavigation, Error)>, Binding> { return BindingName<SignalInput<(WKNavigation, Error)>, Binding>({ v in .webViewBinding(WebView.Binding.didFail(v)) }) }
	static var didFailProvisionalNavigation: BindingName<SignalInput<(WKNavigation, Error)>, Binding> { return BindingName<SignalInput<(WKNavigation, Error)>, Binding>({ v in .webViewBinding(WebView.Binding.didFailProvisionalNavigation(v)) }) }
	static var didFinish: BindingName<SignalInput<WKNavigation>, Binding> { return BindingName<SignalInput<WKNavigation>, Binding>({ v in .webViewBinding(WebView.Binding.didFinish(v)) }) }
	static var contentProcessDidTerminate: BindingName<SignalInput<Void>, Binding> { return BindingName<SignalInput<Void>, Binding>({ v in .webViewBinding(WebView.Binding.contentProcessDidTerminate(v)) }) }
	static var decideActionPolicy: BindingName<SignalInput<Callback<WKNavigationAction, WKNavigationActionPolicy>>, Binding> { return BindingName<SignalInput<Callback<WKNavigationAction, WKNavigationActionPolicy>>, Binding>({ v in .webViewBinding(WebView.Binding.decideActionPolicy(v)) }) }
	static var decideResponsePolicy: BindingName<SignalInput<Callback<WKNavigationResponse, WKNavigationResponsePolicy>>, Binding> { return BindingName<SignalInput<Callback<WKNavigationResponse, WKNavigationResponsePolicy>>, Binding>({ v in .webViewBinding(WebView.Binding.decideResponsePolicy(v)) }) }
	static var didReceiveAuthenticationChallenge: BindingName<SignalInput<Callback<URLAuthenticationChallenge, (URLSession.AuthChallengeDisposition, URLCredential?)>>, Binding> { return BindingName<SignalInput<Callback<URLAuthenticationChallenge, (URLSession.AuthChallengeDisposition, URLCredential?)>>, Binding>({ v in .webViewBinding(WebView.Binding.didReceiveAuthenticationChallenge(v)) }) }
	static var runJavaScriptAlertPanel: BindingName<SignalInput<Callback<(message: String, frame: WKFrameInfo), ()>>, Binding> { return BindingName<SignalInput<Callback<(message: String, frame: WKFrameInfo), ()>>, Binding>({ v in .webViewBinding(WebView.Binding.runJavaScriptAlertPanel(v)) }) }
	static var runJavaScriptConfirmPanel: BindingName<SignalInput<Callback<(message: String, frame: WKFrameInfo), Bool>>, Binding> { return BindingName<SignalInput<Callback<(message: String, frame: WKFrameInfo), Bool>>, Binding>({ v in .webViewBinding(WebView.Binding.runJavaScriptConfirmPanel(v)) }) }
	static var runJavaScriptTextInputPanel: BindingName<SignalInput<Callback<(prompt: String, defaultText: String?, frame: WKFrameInfo), String?>>, Binding> { return BindingName<SignalInput<Callback<(prompt: String, defaultText: String?, frame: WKFrameInfo), String?>>, Binding>({ v in .webViewBinding(WebView.Binding.runJavaScriptTextInputPanel(v)) }) }
	@available(macOS 10.11, iOS 9.0, *)
	static var didClose: BindingName<SignalInput<Void>, Binding> { return BindingName<SignalInput<Void>, Binding>({ v in .webViewBinding(WebView.Binding.didClose(v)) }) }
	
	#if os(macOS)
		@available(macOS 10.12, *)
		static var runOpenPanel: BindingName<SignalInput<(parameters: WKOpenPanelParameters, frame: WKFrameInfo, completion: SignalInput<[URL]?>)>, Binding> { return BindingName<SignalInput<(parameters: WKOpenPanelParameters, frame: WKFrameInfo, completion: SignalInput<[URL]?>)>, Binding>({ v in .webViewBinding(WebView.Binding.runOpenPanel(v)) }) }
	#endif
	
	//	4. Delegate bindings require synchronous evaluation within the object's context.
	static var createWebView: BindingName<(_ webView: WKWebView, _ with: WKWebViewConfiguration, _ for: WKNavigationAction, _ windowFeatures: WKWindowFeatures) -> WKWebView?, Binding> { return BindingName<(_ webView: WKWebView, _ with: WKWebViewConfiguration, _ for: WKNavigationAction, _ windowFeatures: WKWindowFeatures) -> WKWebView?, Binding>({ v in .webViewBinding(WebView.Binding.createWebView(v)) }) }
	
	#if os(iOS)
		@available(iOS 10.0, *)
		static var shouldPreviewElement: BindingName<(_ webView: WKWebView, _ elementInfo: WKPreviewElementInfo) -> Bool, Binding> { return BindingName<(_ webView: WKWebView, _ elementInfo: WKPreviewElementInfo) -> Bool, Binding>({ v in .webViewBinding(WebView.Binding.shouldPreviewElement(v)) }) }
		@available(iOS 10.0, *)
		static var previewingViewController: BindingName<(_ webView: WKWebView, _ elementInfo: WKPreviewElementInfo, _ previewActions: [WKPreviewActionItem]) -> UIViewController?, Binding> { return BindingName<(_ webView: WKWebView, _ elementInfo: WKPreviewElementInfo, _ previewActions: [WKPreviewActionItem]) -> UIViewController?, Binding>({ v in .webViewBinding(WebView.Binding.previewingViewController(v)) }) }
		@available(iOS 10.0, *)
		static var commitPreviewingViewController: BindingName<(_ webView: WKWebView, _ previewingViewController: UIViewController) -> Void, Binding> { return BindingName<(_ webView: WKWebView, _ previewingViewController: UIViewController) -> Void, Binding>({ v in .webViewBinding(WebView.Binding.commitPreviewingViewController(v)) }) }
	#endif
}

protocol WebViewConvertible: ViewConvertible {
	var wkWebView: WebView.Instance { get }
}
extension WebViewConvertible {
	#if os(macOS)
		func nsView() -> View.Instance { return wkWebView }
	#else
		func uiView() -> View.Instance { return wkWebView }
	#endif
}
extension WKWebView: WebViewConvertible {
	var wkWebView: WebView.Instance { return self }
}

protocol WebViewBinding: ViewBinding {
	static func webViewBinding(_ binding: WebView.Binding) -> Self
}
extension WebViewBinding {
	static func viewBinding(_ binding: View.Binding) -> Self {
		return webViewBinding(.inheritedBinding(binding))
	}
}

class StackView: ConstructingBinder, StackViewConvertible {
#if os(macOS)
	typealias NSUIView = NSView
	typealias NSUIStackView = NSStackView
	typealias NSUIStackViewDistribution = NSStackView.Gravity
	typealias NSUIStackViewAlignment = NSLayoutConstraint.Attribute
	typealias NSUIUserInterfaceLayoutOrientation = NSUserInterfaceLayoutOrientation
	typealias NSUILayoutPriority = NSLayoutConstraint.Priority
#else
	typealias NSUIView = UIView
	typealias NSUIStackView = UIStackView
	typealias NSUIStackViewDistribution = UIStackView.Distribution
	typealias NSUIStackViewAlignment = UIStackView.Alignment
	typealias NSUIUserInterfaceLayoutOrientation = NSLayoutConstraint.Axis
	typealias NSUILayoutPriority = UILayoutPriority
#endif

	typealias Instance = NSUIStackView
	typealias Inherited = View
	
	var state: ConstructingBinderState<Instance, Binding>
	required init(state: ConstructingBinderState<Instance, Binding>) {
		self.state = state
	}
	static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}

	#if os(macOS)
		func nsStackView() -> Instance { return instance() }
	#else
		func uiStackView() -> Instance { return instance() }
	#endif
	
	enum Binding: StackViewBinding {
		typealias EnclosingBinder = StackView
		static func stackViewBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case alignment(Dynamic<NSUIStackViewAlignment>)
		case spacing(Dynamic<CGFloat>)
		case distribution(Dynamic<NSUIStackViewDistribution>)
		case axis(Dynamic<NSUIUserInterfaceLayoutOrientation>)
		case views(Dynamic<[ViewConvertible]>)
		#if os(macOS)
			case horizontalClippingResistance(Dynamic<NSUILayoutPriority>)
			case verticalClippingResistance(Dynamic<NSUILayoutPriority>)
			case horizontalHuggingPriority(Dynamic<NSUILayoutPriority>)
			case verticalHuggingPriority(Dynamic<NSUILayoutPriority>)
			case edgeInsets(Dynamic<NSEdgeInsets>)
			@available(*, unavailable)
			case isLayoutMarginsRelativeArrangement(())
		#else
			case isLayoutMarginsRelativeArrangement(Dynamic<Bool>)
			@available(*, unavailable)
			case edgeInsets(())
			@available(*, unavailable)
			case horizontalClippingResistance(Dynamic<NSUILayoutPriority>)
			@available(*, unavailable)
			case verticalClippingResistance(Dynamic<NSUILayoutPriority>)
			@available(*, unavailable)
			case horizontalHuggingPriority(Dynamic<NSUILayoutPriority>)
			@available(*, unavailable)
			case verticalHuggingPriority(Dynamic<NSUILayoutPriority>)
		#endif
		
		// 2. Signal bindings are performed on the object after construction.
		
		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}

	struct Preparer: ConstructingPreparer {
		typealias EnclosingBinder = StackView
		var linkedPreparer = Inherited.Preparer()
		
		func constructStorage() -> EnclosingBinder.Storage { return Storage() }
		func constructInstance(subclass: EnclosingBinder.Instance.Type) -> EnclosingBinder.Instance { return subclass.init() }
		
		init() {}
		
		func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
			switch binding {
			case .alignment(let x): return x.apply(instance, storage) { i, s, v in i.alignment = v }
			case .spacing(let x): return x.apply(instance, storage) { i, s, v in i.spacing = v }
			case .distribution(let x):
				return x.apply(instance, storage) { i, s, v in
					#if os(macOS)
						s.gravity = v
						if #available(macOS 10.11, *) {
							i.setViews(i.arrangedSubviews, in: s.gravity)
						} else {
							i.setViews(i.subviews, in: s.gravity)
						}
					#else
						i.distribution = v
					#endif
				}
			case .axis(let x):
				return x.apply(instance, storage) { i, s, v in
					#if os(macOS)
						i.orientation = v
					#else
						i.axis = v
					#endif
				}
			case .horizontalClippingResistance(let x):
				#if os(macOS)
					return x.apply(instance, storage) { i, s, v in i.setClippingResistancePriority(v, for: .horizontal) }
				#else
					return nil
				#endif
			case .verticalClippingResistance(let x):
				#if os(macOS)
					return x.apply(instance, storage) { i, s, v in i.setClippingResistancePriority(v, for: .vertical) }
				#else
					return nil
				#endif
			case .horizontalHuggingPriority(let x):
				#if os(macOS)
					return x.apply(instance, storage) { i, s, v in i.setHuggingPriority(v, for: .horizontal) }
				#else
					return nil
				#endif
			case .verticalHuggingPriority(let x):
				#if os(macOS)
					return x.apply(instance, storage) { i, s, v in i.setHuggingPriority(v, for: .vertical) }
				#else
					return nil
				#endif
			case .views(let x):
				return x.apply(instance, storage) { i, s, v in
					#if os(macOS)
						i.setViews(v.map { $0.nsView() }, in: s.gravity)
					#else
						for view in i.arrangedSubviews {
							view.removeFromSuperview()
						}
						for view in v {
							i.addArrangedSubview(view.uiView())
						}
					#endif
				}
			case .edgeInsets(let x):
				#if os(macOS)
					return x.apply(instance, storage) { i, s, v in i.edgeInsets = v }
				#else
					return nil
				#endif
			case .isLayoutMarginsRelativeArrangement(let x):
				#if os(macOS)
					return nil
				#else
					return x.apply(instance, storage) { i, s, v in i.isLayoutMarginsRelativeArrangement = v }
				#endif
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: instance, storage: storage)
			}
		}
	}

	#if os(macOS)
		class Storage: View.Storage {
			var gravity: NSStackView.Gravity = .center
		}
	#else
		typealias Storage = View.Storage
	#endif
}

extension BindingName where Binding: StackViewBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .stackViewBinding(StackView.Binding.$1(v)) }) }
	static var alignment: BindingName<Dynamic<StackView.NSUIStackViewAlignment>, Binding> { return BindingName<Dynamic<StackView.NSUIStackViewAlignment>, Binding>({ v in .stackViewBinding(StackView.Binding.alignment(v)) }) }
	static var spacing: BindingName<Dynamic<CGFloat>, Binding> { return BindingName<Dynamic<CGFloat>, Binding>({ v in .stackViewBinding(StackView.Binding.spacing(v)) }) }
	static var distribution: BindingName<Dynamic<StackView.NSUIStackViewDistribution>, Binding> { return BindingName<Dynamic<StackView.NSUIStackViewDistribution>, Binding>({ v in .stackViewBinding(StackView.Binding.distribution(v)) }) }
	static var axis: BindingName<Dynamic<StackView.NSUIUserInterfaceLayoutOrientation>, Binding> { return BindingName<Dynamic<StackView.NSUIUserInterfaceLayoutOrientation>, Binding>({ v in .stackViewBinding(StackView.Binding.axis(v)) }) }
	static var views: BindingName<Dynamic<[ViewConvertible]>, Binding> { return BindingName<Dynamic<[ViewConvertible]>, Binding>({ v in .stackViewBinding(StackView.Binding.views(v)) }) }
	#if os(macOS)
		static var horizontalClippingResistance: BindingName<Dynamic<StackView.NSUILayoutPriority>, Binding> { return BindingName<Dynamic<StackView.NSUILayoutPriority>, Binding>({ v in .stackViewBinding(StackView.Binding.horizontalClippingResistance(v)) }) }
		static var verticalClippingResistance: BindingName<Dynamic<StackView.NSUILayoutPriority>, Binding> { return BindingName<Dynamic<StackView.NSUILayoutPriority>, Binding>({ v in .stackViewBinding(StackView.Binding.verticalClippingResistance(v)) }) }
		static var horizontalHuggingPriority: BindingName<Dynamic<StackView.NSUILayoutPriority>, Binding> { return BindingName<Dynamic<StackView.NSUILayoutPriority>, Binding>({ v in .stackViewBinding(StackView.Binding.horizontalHuggingPriority(v)) }) }
		static var verticalHuggingPriority: BindingName<Dynamic<StackView.NSUILayoutPriority>, Binding> { return BindingName<Dynamic<StackView.NSUILayoutPriority>, Binding>({ v in .stackViewBinding(StackView.Binding.verticalHuggingPriority(v)) }) }
		static var edgeInsets: BindingName<Dynamic<NSEdgeInsets>, Binding> { return BindingName<Dynamic<NSEdgeInsets>, Binding>({ v in .stackViewBinding(StackView.Binding.edgeInsets(v)) }) }
		@available(*, unavailable)
		static var isLayoutMarginsRelativeArrangement: BindingName<(), Binding> { return BindingName<(), Binding>({ v in .baseBinding(.lifetimes(.constant([]))) }) }
	#endif
}

#if os(macOS)
	protocol StackViewConvertible: ViewConvertible {
		func nsStackView() -> StackView.Instance
	}
	extension StackViewConvertible {
		func nsView() -> View.Instance { return nsStackView() }
	}
	extension StackView.Instance: StackViewConvertible {
		func nsStackView() -> StackView.Instance { return self }
	}
#else
	protocol StackViewConvertible: ViewConvertible {
		func uiStackView() -> StackView.Instance
	}
	extension StackViewConvertible {
		func uiView() -> View.Instance { return uiStackView() }
	}
	extension StackView.Instance: StackViewConvertible {
		func uiStackView() -> StackView.Instance { return self }
	}
#endif

protocol StackViewBinding: ViewBinding {
	static func stackViewBinding(_ binding: StackView.Binding) -> Self
}

extension StackViewBinding {
	static func viewBinding(_ binding: View.Binding) -> Self {
		return stackViewBinding(.inheritedBinding(binding))
	}
}

class Layer: ConstructingBinder, LayerConvertible {
	typealias Instance = CALayer
	typealias Inherited = BackingLayer

	var state: ConstructingBinderState<Instance, Binding>
	required init(state: ConstructingBinderState<Instance, Binding>) {
		self.state = state
	}
	static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	var cgLayer: Instance { return instance() }
	
	enum Binding: LayerBinding {
		typealias EnclosingBinder = Layer
		static func layerBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)

		//	1. Value bindings may be applied at construction and may subsequently change.
		#if os(macOS)
			case constraints(Dynamic<[CAConstraint]>)
		#else
			@available(*, unavailable)
			case constraints(())
		#endif

		//	2. Signal bindings are performed on the object after construction.

		//	3. Action bindings are triggered by the object after construction.

		//	4. Delegate bindings require synchronous evaluation within the object's context.
		case display((CALayer) -> Void)
		case draw((CALayer, CGContext) -> Void)
	}

	struct Preparer: ConstructingPreparer {
		typealias EnclosingBinder = Layer
		var linkedPreparer = Inherited.Preparer()
		
		func constructStorage() -> EnclosingBinder.Storage { return Storage() }
		func constructInstance(subclass: EnclosingBinder.Instance.Type) -> EnclosingBinder.Instance { return subclass.init() }
		
		init() {
			self.init(delegateClass: InternalDelegate.self)
		}
		init<Value>(delegateClass: Value.Type) where Value: InternalDelegate {
			self.delegateClass = delegateClass
		}
		let delegateClass: InternalDelegate.Type
		var possibleDelegate: InternalDelegate? = nil
		mutating func delegate() -> InternalDelegate {
			if let d = possibleDelegate {
				return d
			} else {
				let d = delegateClass.init()
				possibleDelegate = d
				return d
			}
		}
		
		mutating func prepareBinding(_ binding: Binding) {
			switch binding {
			case .display(let x):
				let s = #selector(CALayerDelegate.display(_:))
				delegate().addSelector(s).display = x
			case .draw(let x):
				let s = #selector(CALayerDelegate.draw(_:in:))
				delegate().addSelector(s).drawLayer = x
			case .inheritedBinding(let x): linkedPreparer.prepareBinding(x)
			default: break
			}
		}
		
		mutating func prepareInstance(_ instance: Instance, storage: Storage) {
			// Don't steal the delegate from the view if already set
			if possibleDelegate != nil {
				precondition(instance.delegate == nil, "Conflicting delegate applied to instance")
				storage.dynamicDelegate = possibleDelegate
				instance.delegate = storage
			}
			
			linkedPreparer.prepareInstance(instance, storage: storage)
		}
		
		func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
			switch binding {
			case .constraints(let x):
				#if os(macOS)
					return x.apply(instance, storage) { i, s, v in i.constraints = v }
				#else
					return nil
				#endif
			case .display: return nil
			case .draw: return nil
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: instance, storage: storage)
			}
		}
	}

	class Storage: BackingLayer.Storage, CALayerDelegate {}

	class InternalDelegate: DynamicDelegate, CALayerDelegate {
		required override init() {
			super.init()
		}
		
		var display: ((CALayer) -> Void)?
		func display(_ layer: CALayer) {
			return display!(layer)
		}
		
		var drawLayer: ((CALayer, CGContext) -> Void)?
		@objc(drawLayer:inContext:) func draw(_ layer: CALayer, in ctx: CGContext) {
			return drawLayer!(layer, ctx)
		}
		
		var layoutSublayers: ((CALayer) -> Void)?
		func layoutSublayers(of layer: CALayer) {
			return layoutSublayers!(layer)
		}
		
		var action: ((CALayer, String) -> CAAction?)?
		func action(for layer: CALayer, forKey event: String) -> CAAction? {
			return action!(layer, event)
		}
	}
}

extension BindingName where Binding: LayerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .layerBinding(Layer.Binding.$1(v)) }) }
	#if os(macOS)
		static var constraints: BindingName<Dynamic<[CAConstraint]>, Binding> { return BindingName<Dynamic<[CAConstraint]>, Binding>({ v in .layerBinding(Layer.Binding.constraints(v)) }) }
	#endif
	static var display: BindingName<(CALayer) -> Void, Binding> { return BindingName<(CALayer) -> Void, Binding>({ v in .layerBinding(Layer.Binding.display(v)) }) }
	static var draw: BindingName<(CALayer, CGContext) -> Void, Binding> { return BindingName<(CALayer, CGContext) -> Void, Binding>({ v in .layerBinding(Layer.Binding.draw(v)) }) }
}

protocol LayerConvertible {
	var cgLayer: Layer.Instance { get }
}
extension Layer.Instance: LayerConvertible {
	var cgLayer: Layer.Instance { return self }
}

protocol LayerBinding: BackingLayerBinding {
	static func layerBinding(_ binding: Layer.Binding) -> Self
}

extension LayerBinding {
	static func backingLayerBinding(_ binding: BackingLayer.Binding) -> Self {
		return layerBinding(.inheritedBinding(binding))
	}
}
