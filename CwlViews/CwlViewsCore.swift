//
//  This file is part of a concatenation of the CwlViews framework with internal
//  interfaces for direct inclusion in projects instead of library inclusion).
//  For details, visit: https://github.com/mattgallagher/CwlViews
//
//  Copyright © 2015-2018 Matt Gallagher ( https://www.cocoawithlove.com ). All rights reserved.
//
//  Permission to use, copy, modify, and/or distribute this software for any
//  purpose with or without fee is hereby granted, provided that the above
//  copyright notice and this permission notice appear in all copies.
//
//  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
//  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
//  SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
//  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
//  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR
//  IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
//
//  This file was generated by the CwlConcat tool on 2018-10-25 10:12:07 +0000 from the following files:
//   CwlArrayMutation.swift
//   CwlScopedValues.swift
//   CwlBinderBase.swift
//   CwlTableRowMutation.swift
//   CwlBindingName.swift
//   CwlStackMutation.swift
//   CwlStateContainer.swift
//   CwlBinder.swift
//   CwlTargetAction.swift
//   CwlBinderParameters.swift
//   CwlBinderState.swift
//   CwlSetMutation.swift
//   CwlSignalCallback.swift
//   CwlFilteredAdapter.swift
//   CwlObjectStorage.swift
//   CwlArrayMutationUtilities.swift
//   CwlCoder.swift
//   CwlStateAdapter.swift
//   CwlBinderPreparer.swift
//   CwlDynamicValue.swift
//   CwlStackAdapter.swift
//   CwlConstructingBinder.swift
//   CwlLayout.swift

import Foundation

/// This enum is intended to be embedded in an ArrayMutation<Value>. The ArrayMutation<Value> combines an IndexSet with this enum. This enum specifies what actions should be taken at the locations specified by the IndexSet.
///
/// 
enum ArrayMutationKind {
	/// The values at the locations specified by the IndexSet should be deleted.
	/// NOTE: the IndexSet specifies the indexes *before* deletion (and must therefore be applied in reverse).
	case delete

	/// The associated Array<Value> contains values that should be inserted such that they have the indexes specified in IndexSet. The Array<Value> and IndexSet must have identical counts.
	/// NOTE: the IndexSet specifies the indexes *after* insertion (and must therefore be applied in forward order).
	case insert

	/// Values are deleted from one end and inserted onto the other. If `Int` is positive, values are deleted from the `startIndex` end and inserted at the `endIndex` end, if `Int` is negative, value are deleted from the `endIndex` end and inserted at the `startIndex`end.
	/// The magnitude of `Int` specifies the number of deleted rows and the sign specified the end.
	/// The Array<Value> contains values that should be inserted at the other end of the collection.
	/// The IndexSet contains the indexes of any revealed (scrolled into view) rows
	case scroll(Int)

	/// The associated Array<Value> contains updated values at locations specified by the IndexSet. Semantically, the item should be modelled as updated but not replaced. The Array<Value> and IndexSet must have identical counts.
	// In many cases, update and replace are the same. The only differences relate to scenarios where the items are considered to have "identity". An update *retains* the previous identity whereas a replace *discards* any previous identity.
	case update
	
	/// The values at the locations specified by the IndexSet should be removed from their locations and spliced back in at the location specified by the associated Int index. For scrolled subranges, items may not be moved from outside or to outside the visible range (items moved from outside the visible range must be inserted and items moved outside the visible range must be deleted)
	/// NOTE: the IndexSet specifies the indexes *before* removal (and must therefore be applied in reverse) and the Int index specifies an index *after* removal.
	case move(Int)

	/// Equivalent to a Deletion of all previous indexes and an Insertion of the new values. The associated Array<Value> contains the new state of the array. All previous values should be discarded and the entire array replaced with this new version. The Array<Value> and IndexSet must have identical counts.
	/// NOTE: the IndexSet specifies the indexes *after* insertion (and must therefore be applied in forward order).
	case reload
}

/// An `ArrayMutation` communicates changes to an array in one context so that another array, mirroring its contents in another context, can mimic the same changes.
/// Subscribing to a stream of `ArrayMutation`s is sufficient to communication the complete state and animatable transitions of an array between to parts of a program.
/// In most cases, the source and destination will need to keep their own complete copy of the array to correctly calculate the effect of the mutation.
struct ArrayMutation<Value>: ExpressibleByArrayLiteral {
	/// Determines the meaning of this `ArrayMutation`
	let kind: ArrayMutationKind

	/// The meaning of the indexSet is dependent on the `kind` – it may contain indexes in the array that will be deleted by this mutation or it may contain indexes that new entries will occupy after application of this mutation.
	let indexSet: IndexSet
	
	/// New values that will be inserted at locations determined by the `kind` and the `indexSet`.
	let values: Array<Value>
	
	/// Construct an empty array mutation that represents a no-op.
	init() {
		self.kind = .update
		self.indexSet = IndexSet()
		self.values = []
	}
	
	/// Construct from components.
	init<S>(indexSet: IndexSet, kind: ArrayMutationKind, values: S) where S: Sequence, S.Element == Value {
		self.kind = kind
		self.indexSet = indexSet
		self.values = Array(values)
	}
	
	/// Construct a mutation that represents the deletion of the values at a set of indices.
	init(deletedIndexSet: IndexSet) {
		self.kind = .delete
		self.indexSet = deletedIndexSet
		self.values = []
	}
	
	/// Construct a mutation that represents the deletion of a value at an index.
	init(deletedIndex: Int) {
		self.kind = .delete
		self.indexSet = IndexSet(integer: deletedIndex)
		self.values = []
	}
	
	/// Construct a mutation that represents the deletion of a value at an index.
	static func deleted(at index: Int) -> ArrayMutation<Value> {
		return ArrayMutation(deletedIndex: index)
	}
	
	/// Construct a mutation that represents the deletion of the values within a range indices.
	init(deletedRange: CountableRange<Int>) {
		self.kind = .delete
		self.indexSet = IndexSet(integersIn: deletedRange)
		self.values = []
	}
	
	/// Construct a mutation that represents the deletion of a value at an index.
	init<S>(scrollForwardRevealing indexSet: IndexSet, values: S) where S: Sequence, S.Element == Value {
		let array = Array(values)
		assert(indexSet.count == array.count)
		self.kind = .scroll(indexSet.count)
		self.indexSet = indexSet
		self.values = Array(array)
	}
	
	/// Construct a mutation that represents the deletion of a value at an index.
	init<S>(scrollBackwardRevealing indexSet: IndexSet, values: S) where S: Sequence, S.Element == Value {
		let array = Array(values)
		assert(indexSet.count == array.count)
		self.kind = .scroll(-indexSet.count)
		self.indexSet = indexSet
		self.values = array
	}
	
	/// Construct a mutation that represents the insertion of a number of values at a set of indices. The count of indices must match the count of values.
	init<S>(insertedIndexSet: IndexSet, values: S) where S: Sequence, S.Element == Value {
		let array = Array(values)
		assert(insertedIndexSet.count == array.count)
		self.kind = .insert
		self.indexSet = insertedIndexSet
		self.values = array
	}
	
	/// Construct a mutation that represents the insertion of a value at an index.
	init(insertedIndex: Int, value: Value) {
		self.kind = .insert
		self.indexSet = IndexSet(integer: insertedIndex)
		self.values = [value]
	}

	/// Construct a mutation that represents the insertion of a number of values within a range of indices. The count of the range must match the count of values.
	init<S>(insertedRange: CountableRange<Int>, values: S) where S: Sequence, S.Element == Value {
		let array = Array(values)
		assert(insertedRange.count == array.count)
		self.kind = .insert
		self.indexSet = IndexSet(integersIn: insertedRange)
		self.values = array
	}
	
	/// Construct a mutation that discards any previous history and simply starts with a completely new array.
	init<S>(reload values: S) where S: Sequence, S.Element == Value {
		let array = Array(values)
		self.kind = .reload
		self.indexSet = IndexSet(integersIn: array.indices)
		self.values = array
	}
	
	/// A .Reload mutation can be constructed from an array literal (since it is equivalent to an array assignment).
	init(arrayLiteral elements: Value...) {
		self.init(reload: elements)
	}
	
	/// Construct a mutation that represents the update of a number of values at a set of indices. The count of indices must match the count of values.
	init<S>(updatedIndexSet: IndexSet, values: S) where S: Sequence, S.Element == Value {
		let array = Array(values)
		assert(updatedIndexSet.count == array.count)
		self.kind = .update
		self.indexSet = updatedIndexSet
		self.values = array
	}
	
	/// Construct a mutation that represents the update of a value at an index.
	init(updatedIndex: Int, value: Value) {
		self.kind = .update
		self.indexSet = IndexSet(integer: updatedIndex)
		self.values = [value]
	}
	
	/// Construct a mutation that represents the udpate of a number of values within a range of indices. The count of the range must match the count of values.
	init<S>(updatedRange: CountableRange<Int>, values: S) where S: Sequence, S.Element == Value {
		let array = Array(values)
		assert(updatedRange.count == array.count)
		self.kind = .update
		self.indexSet = IndexSet(integersIn: updatedRange)
		self.values = array
	}
	
	/// Construct a mutation that represents the move of a number of values from a set of indices to a new range starting at targetIndex. NOTE: the order of values once inserted at targetIndex must be the same as the order in movedIndexSet.
	init(movedIndexSet: IndexSet, targetIndex: Int) {
		self.kind = .move(targetIndex)
		self.indexSet = movedIndexSet
		self.values = []
	}

	/// Construct a mutation that represents the move of a value at movedIndex to a new range starting at targetIndex.
	init(movedIndex: Int, targetIndex: Int) {
		self.kind = .move(targetIndex)
		self.indexSet = IndexSet(integer: movedIndex)
		self.values = []
	}

	/// Construct a mutation that represents the move of a range of values to a new range starting at targetIndex. NOTE: the order of values once inserted at targetIndex must be the same as the order in movedRange.
	init(movedRange: CountableRange<Int>, targetIndex: Int) {
		self.kind = .move(targetIndex)
		self.indexSet = IndexSet(integersIn: movedRange)
		self.values = []
	}

	/// Apply the mutation described by this value to the provided array
	func apply<C: RangeReplaceableCollection>(to a: inout C) where C.Index == Int, C.Iterator.Element == Value {
		switch kind {
		case .delete:
			indexSet.rangeView.reversed().forEach { a.removeSubrange($0) }
		case .scroll(let offset):
			a.removeSubrange(offset > 0 ? a.startIndex..<offset : (a.endIndex + offset)..<a.endIndex)
			a.insert(contentsOf: values, at: offset > 0 ? a.endIndex : a.startIndex)
		case .move(let index):
			let moving = indexSet.map { a[$0] }
			indexSet.rangeView.reversed().forEach { a.removeSubrange($0) }
			a.insert(contentsOf: moving, at: index)
		case .insert:
			for (i, v) in zip(indexSet, values) {
				a.insert(v, at: i)
			}
		case .update:
			for (i, v) in zip(indexSet, values) {
				a.insert(v, at: i)
			}
		case .reload:
			a.replaceSubrange(a.startIndex..<a.endIndex, with: values)
		}
	}
	
	func map<Other>(_ transform: (Value) -> Other) -> ArrayMutation<Other> {
		return ArrayMutation<Other>(indexSet: indexSet, kind: kind, values: values.map(transform))
	}
	
	func removed(previousIndices a: CountableRange<Int>) -> IndexSet {
		switch kind {
		case .delete: return indexSet
		case .scroll(let offset): return IndexSet(integersIn: offset > 0 ? (a.endIndex - offset)..<a.endIndex : a.startIndex..<(a.startIndex + offset))
		case .reload: return IndexSet(integersIn: a)
		case .move: fallthrough
		case .insert: fallthrough
		case .update: return IndexSet()
		}
	}
	
	func inserted(subsequentIndices a: CountableRange<Int>) -> IndexSet {
		switch kind {
		case .insert: return indexSet
		case .scroll(let offset): return IndexSet(integersIn: offset > 0 ? a.startIndex..<offset : (a.endIndex + offset)..<a.endIndex)
		case .reload: return IndexSet(integersIn: a)
		case .delete: return indexSet
		case .move: fallthrough
		case .update: return IndexSet()
		}
	}
	
	/// Updates a row count due to this mutation.
	func delta(_ rowCount: inout Int) {
		switch kind {
		case .reload: rowCount = values.count
		case .delete: rowCount -= indexSet.count
		case .scroll(let offset): rowCount += values.count - (offset > 0 ? offset : -offset)
		case .insert: rowCount += values.count
		case .move: return
		case .update: return
		}
	}
}

import Foundation

struct ScopedValues<Scope, Value>: ExpressibleByArrayLiteral {
	typealias ArrayLiteralElement = ScopedValues<Scope, Value>
	init(arrayLiteral elements: ScopedValues<Scope, Value>...) {
		self.pairs = elements.flatMap { $0.pairs }
	}
	
	let pairs: [(scope: Scope, value: Value)]
	init(pairs: (Scope, Value)...) {
		self.pairs = pairs
	}
	init(pairs: [(Scope, Value)]) {
		self.pairs = pairs
	}
	init(scope: Scope, value: Value) {
		self.pairs = [(scope, value)]
	}
	static func value(_ value: Value, for scope: Scope) -> ScopedValues<Scope, Value> {
		return ScopedValues(scope: scope, value: value)
	}
}

/// On its own, `BinderChain` is a description of the connecting structure of `Binder`.
protocol BinderChain: class {
	/// The purpose of a binder is to construct and configure an underlying `Instance`
	associatedtype Instance

	/// Instances are configured with a set of properties and behaviors over time. These are called "bindings"
	associatedtype Binding: BaseBinding where Binding.EnclosingBinder == Self

	/// Bindings are applied to the instance by a helper preparer type. This type exists only during applying of bindings.
	associatedtype Preparer: BinderPreparer where Preparer.EnclosingBinder == Self

	/// Binders inherit from each other with `BaseBinder` usually being the last link in the chain
	associatedtype Inherited

	/// To maintain the lifetime of behaviors over time, binders typically need somewhere to store resources
	associatedtype Storage
}

/// This protocol converts a derived binding to a base binding. This type of up-conversion is how bindings simulate inheritance.
protocol BaseBinding {
	associatedtype EnclosingBinder
	static func baseBinding(_ binding: BaseBinder.Binding) -> Self
}

/// The primary purpose of the base binder is to terminate the BinderChain but it also includes the `lifetimes` binding which can be used for tying lifetimes to the lifetime of the binder's storage.
class BaseBinder: BinderChain {
	typealias Instance = Any
	typealias Storage = Any
	typealias Inherited = ()
	
	/// BaseBinder bindings implement a single `lifetimes` binding to tie the lifetime of arbitrary `Lifetime`s to the lifetime of the bound instance.
	enum Binding: BaseBinding {
		typealias EnclosingBinder = BaseBinder
		static func baseBinding(_ binding: Binding) -> Binding { return binding }

		case lifetimes(Dynamic<[Lifetime]>)
	}

	/// BaseBinder preparer appends the `lifetimes` lifetimes to the bound instance's lifetimes.
	struct Preparer: BinderPreparer {
		typealias EnclosingBinder = BaseBinder

		init() {}
		var linkedPreparer: () {
			get { return () }
			set { }
		}
		mutating func prepareBinding(_ binding: Binding) {}
		mutating func prepareInstance(_ instance: Instance, storage: Storage) {}
		mutating func finalizeInstance(_ instance: Instance, storage: Storage) -> Lifetime? { return nil }
		func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
			switch binding {
			case .lifetimes(let x):
				switch x {
				case .constant(let array): return AggregateLifetime(lifetimes: array)
				case .dynamic(let signal): return signal.continuous().subscribe { r in }
				}
			}
		}
	}
}

extension BindingName where Binding: BaseBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .baseBinding(BaseBinder.Binding.$1(v)) }) }

	/// Each value in the lifetimes will be cancelled when the `Storage` is released. This is guaranteed to be invoked on the main thread (if `Storage` is released on a non-main thread, the effect will occur asynchronously on the main thread).
	static var lifetimes: BindingName<Dynamic<[Lifetime]>, Binding> { return BindingName<Dynamic<[Lifetime]>, Binding>({ v in .baseBinding(BaseBinder.Binding.lifetimes(v)) }) }
}

/// All bound instances are required to have a binder storage for storing lifetime bound instances of type `Lifetime`. This is the standard representation of `Signal` and `SignalInput` implemented bindings.
protocol BinderStorage: class, Lifetime {
	/// The `BinderStorage` needs to maintain the lifetime of all the self-managing objects, the most common of which are `Signal` and `SignalInput` instances but others may include `DispatchSourceTimer`. Most of these objects implement `Lifetime` so maintaining their lifetime is as simple as retaining these `Lifetime` instances in an array.
	/// The `bindings` array should be set precisely once, at the end of construction and an assertion may be raised if subsequent mutations are attempted.
	func setLifetimes(_ lifetimes: [Lifetime])
	
	/// Since the `BinderStorage` object is a supporting instance for the stateful object and exists to manage interactions but it is possible that the stateful object is constructed without the intention of mutation or interaction – in which case, the `BinderStorage` is not needed. The `inUse` getter is provided to ask if the `BinderStorage` is really necessary (a result of `true` may result in the `BinderStorage` being immediately discarded).
	var inUse: Bool { get }
}

/// This data type models updates to the visible rows of a single-dimensional array in a scrolling view.
/// A combination of a `ArrayMutation` and an `AnimationType` which specifies how that mutation should be displayed, along with a local offset and global count which track a global array of which the `ArrayMutation` might merely be a subrange.
/// This type can communicate changes to rows in an `NSTableView` or sections in a `UITableView`. When `Value` is a `TableSectionMutation`, this type can model a two-tiered `UITableView` with multiple sections.
struct TableRowMutation<Value>: ExpressibleByArrayLiteral {
	#if os(macOS)
		typealias AnimationType = NSTableView.AnimationOptions
	#elseif os(iOS)
		typealias AnimationType = UITableView.RowAnimation
	#else
		typealias AnimationType = Int
	#endif
	
	/// A `TableRowMutation` is primarily an `ArrayMutation` with some additional features suitable for animating an 
	let arrayMutation: ArrayMutation<Value>
	
	/// This is offset for the `arrayMutation` in greater array *after* the mutation is applied.
	let localOffset: Int
	
	/// This is the length of the greater array *after* the mutation is applied.
	let globalCount: Int
	
	/// This is the animation to use for the mutation
	let animation: AnimationType
	
	init(arrayMutation: ArrayMutation<Value>, localOffset: Int = 0, globalCount: Int? = nil, animation: AnimationType = defaultTableViewAnimation) {
		self.arrayMutation = arrayMutation
		self.localOffset = localOffset
		self.globalCount = globalCount ?? arrayMutation.values.count
		self.animation = animation
	}
	
	init(arrayLiteral elements: Value...) {
		self.init(arrayMutation: ArrayMutation(reload: elements), localOffset: 0, globalCount: elements.count, animation: noTableViewAnimation)
	}
	
	init(array elements: [Value]) {
		self.init(arrayMutation: ArrayMutation(reload: elements), localOffset: 0, globalCount: elements.count, animation: noTableViewAnimation)
	}
	
	func apply(to rowState: inout TableRowState<Value>) {
		arrayMutation.apply(to: &rowState.rows)
		rowState.localOffset = localOffset
		rowState.globalCount = globalCount
	}
	
	static func defaultAnimation(_ kind: ArrayMutationKind) -> AnimationType {
		switch kind {
		case .update: fallthrough
		case .reload: fallthrough
		case .scroll: return noTableViewAnimation
		default: return defaultTableViewAnimation
		}
	}
}

extension IndexSet {
	/// Maintaining an `ArrayMutation` with a local offset may require offsetting an `IndexSet`
	func offset(by: Int) -> IndexSet {
		if by == 0 {
			return self
		}
		var result = IndexSet()
		for range in self.rangeView {
			result.insert(integersIn: (range.startIndex + by)..<(range.endIndex + by))
		}
		return result
	}
}

#if os(macOS)
	let defaultTableViewAnimation = NSTableView.AnimationOptions.effectFade
#elseif os(iOS)
	let defaultTableViewAnimation = UITableView.RowAnimation.automatic
#else
	let defaultTableViewAnimation = 0
#endif

#if os(macOS)
	let noTableViewAnimation = NSTableView.AnimationOptions()
#elseif os(iOS)
	let noTableViewAnimation = UITableView.RowAnimation.none
#else
	let noTableViewAnimation = 0
#endif

/// A data type that can be used to cache the destination end of a `TableRowMutation<Value>` change stream.
struct TableRowState<Value> {
	var rows: Deque<Value> = []
	var localOffset: Int = 0
	var globalCount: Int = 0
	init() {}
}

private var associatedInputKey = NSObject()
func getSignalInput<B>(for object: NSObject, valueType: B.Type) -> 
SignalInput<B>? {
	return objc_getAssociatedObject(object, &associatedInputKey) as? SignalInput<B>
}

func setSignalInput<B>(for object: NSObject, to input: SignalInput<B>) {
	objc_setAssociatedObject(object, &associatedInputKey, input, objc_AssociationPolicy.OBJC_ASSOCIATION_RETAIN)
}

infix operator --: AssignmentPrecedence
infix operator <--: AssignmentPrecedence
infix operator -->: AssignmentPrecedence

struct BindingName<Value, Binding> {
	var constructor: (Value) -> Binding
	init(_ constructor: @escaping (Value) -> Binding) {
		self.constructor = constructor
	}

	/// Build a signal binding (invocations on the instance after construction) from a name and a signal
	///
	/// - Parameters:
	///   - name: the binding name
	///   - value: the binding argument
	/// - Returns: the binding
	static func <--<Interface: SignalInterface>(name: BindingName<Value, Binding>, value: Interface) -> Binding where Signal<Interface.OutputValue> == Value {
		return name.constructor(value.signal)
	}

	/// Build a value binding (property changes on the instance) from a name and a signal (values over time)
	///
	/// - Parameters:
	///   - name: the binding name
	///   - value: the binding argument
	/// - Returns: the binding
	static func <--<Interface: SignalInterface>(name: BindingName<Value, Binding>, value: Interface) -> Binding where Dynamic<Interface.OutputValue> == Value {
		return name.constructor(Dynamic<Interface.OutputValue>.dynamic(value.signal))
	}

	/// Build an action binding (callbacks triggered by the instance) from a name and a signal input.
	///
	/// - Parameters:
	///   - name: the binding name
	///   - value: the binding argument
	/// - Returns: the binding
	static func --><InputInterface: SignalInputInterface>(name: BindingName<Value, Binding>, value: InputInterface) -> Binding where SignalInput<InputInterface.InputValue> == Value {
		return name.constructor(value.input)
	}

	/// Build a static binding (construction-only property) from a name and a constant value
	///
	/// - Parameters:
	///   - name: the binding name
	///   - value: the binding argument
	/// - Returns: the binding
	static func --<A>(name: BindingName<Value, Binding>, value: A) -> Binding where Constant<A> == Value {
		return name.constructor(Value.constant(value))
	}

	/// Build a value binding (property changes on the instance) from a name and a constant value
	///
	/// - Parameters:
	///   - name: the binding name
	///   - value: the binding argument
	/// - Returns: the binding
	static func --<A>(name: BindingName<Value, Binding>, value: A) -> Binding where Dynamic<A> == Value {
		return name.constructor(Dynamic<A>.constant(value))
	}

	/// Build a delegate binding (synchronous callback) from a name and function with no parameters
	///
	/// - Parameters:
	///   - name: the binding name
	///   - value: the binding argument
	/// - Returns: the binding
	static func --<R>(name: BindingName<Value, Binding>, value: @escaping () -> R) -> Binding where Value == () -> R {
		return name.constructor(value)
	}

	/// Build a delegate binding (synchronous callback) from a name and function with one parameter
	///
	/// - Parameters:
	///   - name: the binding name
	///   - value: the binding argument
	/// - Returns: the binding
	static func --<A, R>(name: BindingName<Value, Binding>, value: @escaping (A) -> R) -> Binding where Value == (A) -> R {
		return name.constructor(value)
	}

	/// Build a delegate binding (synchronous callback) from a name and function with two parameters
	///
	/// - Parameters:
	///   - name: the binding name
	///   - value: the binding argument
	/// - Returns: the binding
	static func --<A, B, R>(name: BindingName<Value, Binding>, value: @escaping (A, B) -> R) -> Binding where Value == (A, B) -> R {
		return name.constructor(value)
	}

	/// Build a delegate binding (synchronous callback) from a name and function with three parameters
	///
	/// - Parameters:
	///   - name: the binding name
	///   - value: the binding argument
	/// - Returns: the binding
	static func --<A, B, C, R>(name: BindingName<Value, Binding>, value: @escaping (A, B, C) -> R) -> Binding where Value == (A, B, C) -> R {
		return name.constructor(value)
	}

	/// Build a delegate binding (synchronous callback) from a name and function with four parameters
	///
	/// - Parameters:
	///   - name: the binding name
	///   - value: the binding argument
	/// - Returns: the binding
	static func --<A, B, C, D, R>(name: BindingName<Value, Binding>, value: @escaping (A, B, C, D) -> R) -> Binding where Value == (A, B, C, D) -> R {
		return name.constructor(value)
	}

	/// Build a delegate binding (synchronous callback) from a name and function with five parameters
	///
	/// - Parameters:
	///   - name: the binding name
	///   - value: the binding argument
	/// - Returns: the binding
	static func --<A, B, C, D, E, R>(name: BindingName<Value, Binding>, value: @escaping (A, B, C, D, E) -> R) -> Binding where Value == (A, B, C, D, E) -> R {
		return name.constructor(value)
	}
}

extension BindingName where Value == TargetAction {
	/// Build an `TargetAction` binding (callbacks triggered by the instance) from a name and a signal input.
	///
	/// - Parameters:
	///   - name: the binding name
	///   - value: the binding argument
	/// - Returns: the binding
	static func --><InputInterface: SignalInputInterface>(name: BindingName<TargetAction, Binding>, value: InputInterface) -> Binding where InputInterface.InputValue == Any? {
		return name.constructor(.singleTarget(value.input))
	}
	
	/// Build a first-responder `TargetAction` binding (callbacks triggered by the instance) from a name and a selector.
	///
	/// - Parameters:
	///   - name: the binding name
	///   - value: the binding argument
	/// - Returns: the binding
	static func -->(name: BindingName<TargetAction, Binding>, value: Selector) -> Binding {
		return name.constructor(TargetAction.firstResponder(value))
	}
}

enum StackMutation<Value>: ExpressibleByArrayLiteral {
	init(arrayLiteral elements: Value...) {
		self = .reload(elements)
	}
	
	typealias ArrayLiteralElement = Value
	
	case push(Value)
	case pop
	case popToCount(Int)
	case reload([Value])
	
	func apply(to stack: inout Array<Value>) {
		switch self {
		case .push(let v): stack.append(v)
		case .pop: stack.removeLast()
		case .popToCount(let c): stack.removeLast(stack.count - c)
		case .reload(let newStack): stack = newStack
		}
	}
}

extension SignalInterface {
	func stackMap<A, B>(_ transform: @escaping (A) -> B) -> Signal<StackMutation<B>> where OutputValue == StackMutation<A> {
		return map { m in
			switch m {
				case .push(let a): return StackMutation<B>.push(transform(a))
				case .pop: return StackMutation<B>.pop
				case .popToCount(let i): return StackMutation<B>.popToCount(i)
				case .reload(let array): return StackMutation<B>.reload(array.map { transform($0) })
			}
		}
	}
}

protocol StateContainer: Lifetime, Codable {
	var persistentValueChanged: Signal<Void> { get }
	var childValues: [StateContainer] { get }
}

extension StateContainer {
	var childValues: [StateContainer] { return [] }
	var persistentValueChanged: Signal<Void> {
		return Signal<Void>.merge(sequence: childValues.map {
			return $0.persistentValueChanged
		})
	}
	mutating func cancel() {
		for var v in childValues {
			v.cancel()
		}
	}
}

extension Array: Lifetime where Element: StateContainer {
	mutating func cancel() {
		for var v in self {
			v.cancel()
		}
	}
}

extension Optional: Lifetime where Wrapped: StateContainer {
	mutating func cancel() {
		self?.cancel()
	}
}

extension Array: StateContainer where Element: StateContainer {
	var childValues: [StateContainer] {
		return flatMap { $0.childValues }
	}
}

extension Optional: StateContainer where Wrapped: StateContainer {
	var childValues: [StateContainer] {
		return self?.childValues ?? []
	}
}

/// This protocol is the minimum definition for a "binder". A binder takes a list of properties and behaviors (called bindings) and constructs an object with the properties and conforming to the behaviors.
protocol Binder: BinderChain where Preparer: DerivedPreparer, Storage: BinderStorage, Inherited: BinderChain {
	associatedtype Parameters: BinderParameters where Parameters.Binding == Binding
	associatedtype Output
	var state: BinderState<Output, Parameters> { get set }
	
	static func bindingToInherited(_ binding: Binding) -> Inherited.Binding?
	func applyBindings(to instance: Instance)
	func consumeBindings() -> [Binding]
	init(state: BinderState<Output, Parameters>)
}

extension Binder where Parameters == BindingsOnlyParameters<Binding> {
	/// A constructor used when dynamically assembling arrays of bindings
	///
	/// - Parameters:
	///   - bindings: array of bindings
	init(bindings: [Binding]) {
		self.init(state: .pending(BindingsOnlyParameters(bindings: bindings)))
	}

	/// A constructor for a binder.
	///
	/// - Parameters:
	///   - bindings: list of bindings
	init(_ bindings: Binding...) {
		self.init(state: .pending(BindingsOnlyParameters(bindings: bindings)))
	}
}

extension Binder where Parameters == BinderSubclassParameters<Instance, Binding> {
	/// A constructor used when dynamically assembling arrays of bindings. Takes an optional subclass for the constructed instance.
	///
	/// - Parameters:
	///   - subclass: runtime subclass of the instance
	///   - bindings: array of bindings
	init(subclass: Instance.Type = Instance.self, bindings: [Binding]) {
		let params = BinderSubclassParameters<Instance, Binding>(subclass: subclass, bindings: bindings)
		self.init(state: .pending(params))
	}
	
	/// The preferred constructor for binders. Takes an optional subclass for the constructed instance and a list of bindings as a variable argument list.
	///
	/// - Parameters:
	///   - subclass: runtime subclass of the instance
	///   - bindings: list of bindings
	init(subclass: Instance.Type = Instance.self, _ bindings: Binding...) {
		let params = BinderSubclassParameters<Instance, Binding>(subclass: subclass, bindings: bindings)
		self.init(state: .pending(params))
	}
}

extension Binder {
	/// Invokes `consume` on the underlying state. If the state is not `pending`, this will trigger a fatal error. State will be set to `consumed`.
	///
	/// - Returns: the array of `Binding` from the state parameters.
	func consumeBindings() -> [Binding] {
		return state.consume().bindings
	}

	/// A utility function that can be called from ConstructingBinder.instance or other functions to turn parameters from a BinderState into a Binder.Output using the Binder.Preparer. The default invocation in ConstructingBinder.instance is normally used unless special construction requirements are involved.
	///
	/// - Parameters:
	///   - additional: ad hoc bindings, applied after other bindings
	///   - storageConstructor: function to construct an empty BinderStorage, usually Preparer.constructStorage()
	///   - instanceConstructor: function to construct an unconfigured instance, usually Preparer.constructInstance(subclass:)
	///   - combine: function to link the instance, storage and generated Lifetimes
	///   - output: chooses the instance or storage to return as the primary output
	/// - Returns: the output
	func binderConstruct(
		additional: ((Instance) -> Lifetime?)?,
		storageConstructor: (Preparer, Parameters, Instance) -> Storage,
		instanceConstructor: (Preparer, Parameters) -> Instance,
		combine: (Instance, Storage, [Lifetime]) -> Void,
		output: (Instance, Storage) -> Output) -> Output {
		return state.construct { parameters in
			var preparer = Preparer.init()
			preparer.prepareBindings(parameters.bindings)
			let instance = instanceConstructor(preparer, parameters)
			let storage = storageConstructor(preparer, parameters, instance)
			preparer.applyBindings(parameters.bindings, instance: instance, storage: storage, additional: additional, combine: combine)
			return output(instance, storage)
		}
	}

	/// A utility function that can be called from Binder.applyBindings(to:) or other functions to turn parameters from a BinderState into a Binder.Output using the Binder.Preparer. The default implementation of Binder.applyBindings(to:) is normally used unless special construction requirements are involved.
	///
	/// - Parameters:
	///	- instance: the instance to which bindings should be applied
	///   - additional: ad hoc bindings, applied after other bindings
	///   - storageConstructor: function to construct an empty BinderStorage, usually Preparer.constructStorage()
	///   - combine: function to link the instance, storage and generated Lifetimes
	/// - Returns: the output
	func binderApply(to instance: Instance,
		additional: ((Instance) -> Lifetime?)?,
		storageConstructor: (Preparer, Parameters, Instance) -> Storage,
		combine: (Instance, Storage, [Lifetime]) -> Void) {
		state.apply(instance: instance) { inst, parameters in
			var preparer = Preparer.init()
			preparer.prepareBindings(parameters.bindings)
			let storage = storageConstructor(preparer, parameters, instance)
			preparer.applyBindings(parameters.bindings, instance: instance, storage: storage, additional: additional, combine: combine)
		}
	}
}

extension Binder where Preparer: StoragePreparer, Instance: NSObject, Output == Instance {
	/// A default implementation of `applyBindings` for the common case.
	///
	/// - Parameter instance: the instance to which bindings should be applied
	func applyBindings(to instance: Instance) {
		binderApply(to: instance, additional: nil, storageConstructor: { prep, params, i in prep.constructStorage() }, combine: embedStorageIfInUse)
	}
}

/// This type encapsulates the idea that target-action pairs in Cocoa may target a specific object (by setting the target to non-nil) or may let the responder chain search for a responder that handles a specific selector.
enum TargetAction {
	case firstResponder(Selector)
	case singleTarget(SignalInput<Any?>)
}

protocol TargetActionSender: class {
	var action: Selector? { get set }
	var target: AnyObject? { get set }
}

extension TargetAction {
	func apply<Source: TargetActionSender, Value>(instance: Source, constructTarget: () -> SignalActionTarget, processor: @escaping (Any?) -> Value) -> Lifetime? {
		switch self {
		case .firstResponder(let s):
			instance.target = nil
			instance.action = s
			return nil
		case .singleTarget(let s):
			let target = constructTarget()
			instance.target = target
			instance.action = SignalActionTarget.selector
			return target.signal.map(processor).cancellableBind(to: s)
		}
	}
}

/// The mandatory requirement of BinderParameters is that they include an array of bindings
protocol BinderParameters {
	associatedtype Binding
	var bindings: [Binding] { get }
}

/// A minimalist implementation of `BinderParameters`
struct BindingsOnlyParameters<Binding>: BinderParameters {
	let bindings: [Binding]
	init(bindings: [Binding]) {
		self.bindings = bindings
	}
}

struct BinderSubclassParameters<Instance, Binding>: BinderParameters {
	let subclass: Instance.Type
	let bindings: [Binding]
	init(subclass: Instance.Type, bindings: [Binding]) {
		self.subclass = subclass
		self.bindings = bindings
	}
}

struct BinderAdditionalParameters<Instance, Binding, Additional>: BinderParameters {
	let subclass: Instance.Type
	let additional: Additional
	let bindings: [Binding]
	init(subclass: Instance.Type, additional: Additional, bindings: [Binding]) {
		self.subclass = subclass
		self.additional = additional
		self.bindings = bindings
	}
}


/// A binder exists in one of three states, a pre-constructed state, a constructed state (with the constructed output cached) and a consumed state (bindings applied to another instance or removed for testing purposes).
///
/// - constructed: the output object was constructed and remains cached as long as the state is retained
/// - pending: the set of parameters for construction 
/// - consumed: this object is no longer valid
enum BinderState<Output, Parameters: BinderParameters> {
	case constructed(Output)
	case pending(Parameters)
	case consumed

	/// If the state is not `pending`, this will trigger a fatal error. State will be set to `consumed`.
	///
	/// - Returns: the parameters of the `pending` state. State will be set to `consumed`.
	mutating func consume() -> Parameters {
		switch self {
		case .pending(let p): return p
		default: fatalError("Attempt to consume already consumed bindings")
		}
	}
	
	/// If the state is `consumed`, this will trigger a fatal error. If the state is `constructed`, this will return the already constructed output. Otherwise, the `generate` closure will be run to get a new `Output` and the state will be set to `constructed`.
	///
	/// - Parameters:
	///   - generate: a function that can create an `Output` with properties and behaviors from `Parameters`.
	/// - Returns: the parameters of the `pending` state
	mutating func construct(generate: (Parameters) -> Output) -> Output {
		switch self {
		case .constructed(let i): return i
		case .pending(let p):
			self = .consumed
			let instance = generate(p)
			self = .constructed(instance)
			return instance
		default: fatalError("Attempt to apply already consumed bindings")
		}
	}

	/// If the state is not `pending`, this will trigger a fatal error. State will be set to `consumed`.
	///
	/// NOTE: this function is generic over `Instance`. The `Instance` and `Output` types are usually but not necessarily the same (e.g. when you're configuring an internal instance but you hold the instance using a separate output wrapper).
	///
	/// - Parameters:
	///   - instance: an existing `Instance` that will receive properties and behaviors from the `Parameters`
	///   - handle: a function that can configure `Instance` with properties and behaviors from `Parameters`.
	mutating func apply<Instance>(instance: Instance, handle: (Instance, Parameters) -> Void) {
		switch self {
		case .pending(let p):
			self = .consumed
			handle(instance, p)
		default: fatalError("Attempt to apply already consumed bindings")
		}
	}
}

/// The standard parameters for constructing a subclass
typealias ConstructingBinderState<Instance, Binding> = BinderState<Instance, BinderSubclassParameters<Instance, Binding>>


import Foundation

enum SetMutationKind {
	case delete
	case insert
	case update
	case reload
}

struct SetMutation<Element> {
	let kind: SetMutationKind
	let values: Array<Element>
	
	init(kind: SetMutationKind, values: Array<Element>) {
		self.kind = kind
		self.values = values
	}
	
	static func delete(_ values: Array<Element>) -> SetMutation<Element> {
		return SetMutation(kind: .delete, values: values)
	}
	
	static func insert(_ values: Array<Element>) -> SetMutation<Element> {
		return SetMutation(kind: .insert, values: values)
	}
	
	static func update(_ values: Array<Element>) -> SetMutation<Element> {
		return SetMutation(kind: .update, values: values)
	}
	
	static func reload(_ values: Array<Element>) -> SetMutation<Element> {
		return SetMutation(kind: .reload, values: values)
	}
	
	func apply(to array: inout Array<Element>, equate: @escaping (Element, Element) -> Bool, compare: @escaping (Element, Element) -> Bool) -> [ArrayMutation<Element>] {
		switch kind {
		case .delete:
			var sorted = values.sorted(by: compare)
			var oldIndices = IndexSet()
			var arrayIndex = 0
			var sortedIndex = 0
			while arrayIndex < array.count && sortedIndex < sorted.count {
				if !equate(array[arrayIndex], sorted[sortedIndex]) {
					arrayIndex += 1
				} else {
					oldIndices.insert(arrayIndex)
					sortedIndex += 1
					arrayIndex += 1
				}
			}
			precondition(sortedIndex == sorted.count, "Unable to find deleted items.")
			oldIndices.reversed().forEach { array.remove(at: $0) }
			return [ArrayMutation<Element>(deletedIndexSet: oldIndices)]
		case .insert:
			var sorted = values.sorted(by: compare)
			var newIndices = IndexSet()
			var arrayIndex = 0
			var sortedIndex = 0
			while arrayIndex < array.count && sortedIndex < sorted.count {
				if compare(array[arrayIndex], sorted[sortedIndex]) {
					arrayIndex += 1
				} else {
					newIndices.insert(arrayIndex)
					array.insert(sorted[sortedIndex], at: arrayIndex)
					sortedIndex += 1
					arrayIndex += 1
				}
			}
			while sortedIndex < sorted.count {
				newIndices.insert(arrayIndex)
				array.insert(sorted[sortedIndex], at: arrayIndex)
				sortedIndex += 1
				arrayIndex += 1
			}
			return [ArrayMutation<Element>(insertedIndexSet: newIndices, values: sorted)]
		case .update:
			// It would be nice if this was better than n squared complexity and aggregated the updates, rather than issueing updates for individual rows.
			var result = Array<ArrayMutation<Element>>()
			for v in values {
				let oldIndex = array.index { u in equate(v, u) }!
				array.remove(at: oldIndex)
				let newIndex = array.index { u in compare(v, u) } ?? array.count
				array.insert(v, at: newIndex)
				if newIndex == oldIndex {
					result.append(.updated(v, at: oldIndex))
				} else {
					// This ordering (moved, then updated) is required to make UITableView animations work correctly.
					result.append(.moved(from: oldIndex, to: newIndex))
					result.append(.updated(v, at: newIndex))
				}
			}
			return result
		case .reload:
			array = values.sorted(by: compare)
			return [ArrayMutation<Element>(reload: array)]
		}
	}
}

extension SignalInterface {
	func sortedArrayMutation<Element>(equate: @escaping (Element, Element) -> Bool, compare: @escaping (Element, Element) -> Bool) -> Signal<ArrayMutation<Element>> where SetMutation<Element> == OutputValue {
		return transform(initialState: Array<Element>()) { (array: inout Array<Element>, result: Result<SetMutation<Element>>, next: SignalNext<ArrayMutation<Element>>) in
			switch result {
			case .success(let mutation):
				mutation.apply(to: &array, equate: equate, compare: compare).forEach { next.send(value: $0) }
			case .failure(let e): next.send(error: e)
			}
		}
	}
}

struct Callback<Value, CallbackValue> {
	let value: Value
	let callback: SignalInput<CallbackValue>?
	
	init(_ value: Value, _ callback: SignalInput<CallbackValue>? = nil) {
		self.value = value
		self.callback = callback
	}
}

extension Signal {
	func callbackBind<CallbackInputInterface: SignalInputInterface>(to callback: CallbackInputInterface) -> Signal<Callback<OutputValue, CallbackInputInterface.InputValue>> {
		return map { value in Callback(value, callback.input) }
	}

	func ignoreCallback<CallbackValue>() -> Signal<Callback<OutputValue, CallbackValue>> {
		return map { value in Callback(value, nil) }
	}
}

/// Instead of offering a single "notification" output signal, like a plain `StateAdapter`, the `FilteredAdapter` is optimized around the idea of multiple filtered views of the output, with subtle questions like "whether to notify immediately upon connecting" handled by the filtered view, rather than a behavior baked into the adapter.
/// A single shared `State` is shared between the `reducer` and filter stages of the pipeline using a manual synchronization context to ensure this remains threadsafe. The `withMutableState` function offers synchronous, threadsafe access to the same storage for serialization and other concerns that might require immediate access.
/// However, there are also some omissions. Unlike `StateAdapter`, this *requires* an initial `State`. There is also no built-in support for `Codable`, since this `FilteredAdapter` would typically be used on data where serialization and persistence are manually handled.
struct FilteredAdapter<Message, State, Notification>: Lifetime, SignalInputInterface {	
	typealias InputValue = Message
	typealias OutputValue = State
	enum PossibleNotification {
		case never
		case suppress
		case value(Notification)
	}
	
	let pair: SignalMultiPair<Message, PossibleNotification>
	var input: SignalInput<Message> { return pair.input }
	
	private let context: DispatchQueueContext
	private let state: MutableBox<State>
	
	/// Construction where the `reducer` function includes a `loopback` parameter
	///
	/// - Parameters:
	///   - initialState: used to initialize the adapter state
	///   - sync: the adapter's execution context can be synchronous or asychronous but otherwise can't be directly specified (true, by default)
	///   - cacheNotification: the last emitted notification can be cached for new observers (false, by default)
	///   - reducer: the reducing function which combines the internal `State` and `Message` on each iteration, emitting a `Notification?` (or throwing in the case of unrecoverable error or close state). A `loopback` parameter is provided which allows the reducing function to schedule asynchronous tasks that may call back into the adapter at a later time.
	init(initialState: State, sync: Bool = true, cacheNotification: Bool = false, reducer: @escaping (_ state: inout State, _ message: Message, _ loopback: SignalMultiInput<Message>) throws -> Notification?) {
		state = MutableBox<State>(initialState)
		context = DispatchQueueContext(sync: sync)
		let channel = Signal<Message>.multiChannel()
		let loopback = channel.input
		pair = channel.reduce(initialState: .never, context: .custom(context)) { [state, loopback] (cache: inout PossibleNotification, message: Message) -> PossibleNotification in
			let notification = try reducer(&state.value, message, loopback)
			if let n = notification {
				if cacheNotification {
					cache = .value(n)
				}
				return .value(n)
			}
			return .suppress
		}
	}
	
	
	/// Construction where the `reducer` function omits the `loopback` parameter
	///
	/// - Parameters:
	///   - initialState: used to initialize the adapter state
	///   - sync: the adapter's execution context can be synchronous or asychronous but otherwise can't be directly specified (true, by default)
	///   - cacheNotification: the last emitted notification can be cached for new observers (false, by default)
	///   - reducer: the reducing function which combines the internal `State` and `Message` on each iteration, emitting a `Notification?` (or throwing in the case of unrecoverable error or close state).
	init(initialState: State, sync: Bool = true, cacheNotification: Bool = false, reducer: @escaping (_ state: inout State, _ input: Message) throws -> Notification?) {
		self.init(initialState: initialState, sync: sync, cacheNotification: cacheNotification) { (state: inout State, input: Message, collector: SignalMultiInput<Message>) -> Notification? in
			return try reducer(&state, input)
		}
	}
	
	/// Cancels the signal graph (no further actions will be possible).
	func cancel() {
		pair.input.cancel()
	}
	
	/// Filters the `PossibleNotification` output signal down to `Notification`, turning the initial `never` into a value using the provided `initial` function. When `PossibleNotification` is `suppress` (i.e. the last reducer invocation returned `nil`) no notification signal will be emitted.
	///
	/// - Returns: the notificationSignal
	func notificationSignal(initial: @escaping (State) -> Notification? = { _ in nil }) -> Signal<Notification> {
		return pair.signal.compactMap { [state] (possibleNotification: PossibleNotification) in
			switch possibleNotification {
			case .never: return initial(state.value)
			case .suppress: return nil
			case .value(let n): return n
			}
		}
	}
	
	var stateSignal: Signal<State> {
		return pair.signal.compactMap { [state] (possibleNotification: PossibleNotification) -> State? in
			if case .suppress = possibleNotification {
				return nil
			}
			return state.value
		}
	}
	
	/// This is the canonical output of the `FilteredAdapter`. On initial connection and each non-nil returning invocation of the adapter, the `processor` provided to this function is given a chance to produce and emit a slice of the `State` to its listeners.
	///
	/// - initialValue: a context value passed into the processor on each invocation
	/// - processor: the function that produces and emits the slice of `State`. The `State` is provided as an `UnsafePointer`, since Swift doesn't have another way to indicate read-only pass-by-reference. The `Notification?` parameter will be `nil` on initial invocation but will never be `nil` again after that point – this distinction allows construction of a specialized slice on initial connection. Output from the function is via the `SignalNext<Processed>` parameter, allowing zero, one or more value outputs or a close, if desired.
	/// - Returns: the signal output from the `processor`
	func filteredSignal<Value, Processed>(initialValue: Value, _ processor: @escaping (inout Value, State, Notification?, SignalNext<Processed>) throws -> Void) -> Signal<Processed> {
		return pair.signal.transform(initialState: initialValue) { [state] (value: inout Value, incoming: Result<PossibleNotification>, next: SignalNext<Processed>) in
			do {
				switch try incoming.unwrap() {
				case .never: try processor(&value, state.value, nil, next)
				case .suppress: break
				case .value(let n): try processor(&value, state.value, n, next)
				}
			} catch {
				next.send(error: error)
			}
		}
	}
	
	/// Same as `filteredSignal(initialValue:_:)` minus the context value
	///
	/// - processor: the function that produces and emits the slice of `State`. The `State` is provided as an `UnsafePointer`, since Swift doesn't have another way to indicate read-only pass-by-reference. The `Notification?` parameter will be `nil` on initial invocation but will never be `nil` again after that point – this distinction allows construction of a specialized slice on initial connection. Output from the function is via the `SignalNext<Processed>` parameter, allowing zero, one or more value outputs or a close, if desired.
	/// - Returns: the signal output from the `processor`
	func filteredSignal<Processed>(_ processor: @escaping (State, Notification?, SignalNext<Processed>) throws -> Void) -> Signal<Processed> {
		return filteredSignal(initialValue: ()) { (value: inout (), state: State, notification: Notification?, next: SignalNext<Processed>) throws in
			try processor(state, notification, next)
		}
	}
	
	/// Allows out-of-stream access to the `State` (for synchronous actions like save). Since this function acquires the context where the signal closures run, do *not* call this from one of the `filterSignal` or `notificationSignal` processing closures as it will deadlock attempting re-entrant access to the context.
	func withMutableState<Value>(_ perform: (inout State) throws -> Value) rethrows -> Value {
		return try context.queue.sync {
			try perform(&state.value)
		}
	}
}

/// Implementation for `BinderStorage` that wraps Cocoa objects.
class ObjectBinderStorage: NSObject, BinderStorage {
	fileprivate var lifetimes: [Lifetime]? = nil
	func setLifetimes(_ lifetimes: [Lifetime]) {
		assert(self.lifetimes == nil, "Bindings should be set once only")
		self.lifetimes = lifetimes
	}
	
	// An `ObjectBinderStorage` is an "internal" object but we don't need to keep it around if it isn't in-use. By default, that means: are we using the object for binding or delegation. Subclasses that store additional properties or implement delegate methods directly (without forwarding to the dynamic delegate) must override this with additional logic.
	var inUse: Bool {
		return lifetimes?.isEmpty == false || dynamicDelegate != nil
	}
	
	/// Explicitly invoke `cancel` on each of the bindings.
	///
	/// WARNING: if `cancel` is invoked outside the main thread, it will be *asynchronously* invoked on the main thread.
	/// Normally, a `cancel` effect is expected to have synchronous effect but it since `cancel` on EnclosingBinder objects is usually used for breaking reference counted loops, it is considered that the synchronous effect of cancel is less important than avoiding deadlocks – and deadlocks would be easy to accidentally trigger if this were synchronously invoked. If you need synchronous effect, ensure that cancel is invoked on the main thread.
	func cancel() {
		if let cs = lifetimes {
			if Thread.isMainThread {
				// `cancel` is mutating so we must use a `for var` (we can't use `forEach`)
				for var c in cs {
					c.cancel()
				}
			} else {
				DispatchQueue.main.async {
					// `cancel` is mutating so we must use a `for var` (we can't use `forEach`)
					for var c in cs {
						c.cancel()
					}
				}
			}
			lifetimes?.removeAll()
		}
	}
	
	deinit {
		cancel()
	}
	
	/// The `dynamicDelegate` is a work-around for the fact that some Cocoa objects change their behavior if you have a delegate that implements a given delegate method. Since Binders will likely implement *all* of their delegate methods, the dynamicDelegate can be used to selectively respond to particular selectors at runtime.
	var dynamicDelegate: DynamicDelegate?
	
	/// An override of the NSObject method so that the dynamicDelegate can work. When the dynamicDelegate states that it can respond to a given selector, that selector is directed to the dynamicDelegate instead. This function will only be involved if Objective-C message sends are sent to the BinderStorage – a rare occurrence outside of deliberate delegate invocations.
	///
	/// - Parameter selector: Objective-C selector that may be implemented by the dynamicDelegate
	/// - Returns: the dynamicDelegate, if it implements the selector
	override func forwardingTarget(for selector: Selector) -> Any? {
		if let dd = dynamicDelegate, dd.implementedSelectors.contains(selector) {
			return dd
		}
		return nil
	}
	
	/// An override of the NSObject method so that the dynamicDelegate can work.
	///
	/// - Parameter selector: Objective-C selector that may be implemented by the dynamicDelegate
	/// - Returns: true if the dynamicDelegate implements the selector, otherwise returns the super implementation
	override func responds(to selector: Selector) -> Bool {
		if let dd = dynamicDelegate, dd.implementedSelectors.contains(selector) {
			return true
		}
		return super.responds(to: selector)
	}
}

/// Used in conjunction with `ObjectBinderStorage`, subclasses of `DynamicDelegate` can implement all delegate methods at compile time but have the `ObjectBinderStorage` report true to `responds(to:)` only in the cases where the delegate method is selected for enabling.
class DynamicDelegate: NSObject {
	var implementedSelectors = Set<Selector>()
	
	@discardableResult
	func addSelector(_ selector: Selector) -> Self {
		implementedSelectors.insert(selector)
		return self
	}
}


/// Most objects managed by a `BinderStorage` are Objective-C objects (`NSView`/`UIView`, `NSApplication`/`UIApplication`, etc). For these objects, we can satisfy the requirement of tying the stateful and binder objects together by storing the binder in the Objective-C "associated object" storage.
private var associatedStorageKey = NSObject()
extension NSObject { 
	func setBinderStorage(_ newValue: BinderStorage?) {
		objc_setAssociatedObject(self, &associatedStorageKey, newValue, objc_AssociationPolicy.OBJC_ASSOCIATION_RETAIN)
	}
	func getBinderStorage<T: BinderStorage>(type: T.Type) -> T? {
		return objc_getAssociatedObject(self, &associatedStorageKey) as? T
	}
}

func embedStorageIfInUse<Storage: BinderStorage>(_ instance: NSObject, _ storage: Storage, _ lifetimes: [Lifetime]) {
	storage.setLifetimes(lifetimes)
	if storage.inUse {
		instance.setBinderStorage(storage)
	}
}

extension Sequence {
	func arrayMutation() -> ArrayMutation<Element> {
		return .reload(self)
	}
	
	func rowMutation() -> TableRowMutation<Element> {
		return TableRowMutation(arrayMutation: arrayMutation())
	}
	
#if os(iOS)
	func sectionMutation(header: String? = nil, footer: String? = nil) -> TableSectionMutation<Element> {
		return rowMutation().sectionMutation(header: header, footer: footer)
	}
	func tableData(header: String? = nil, footer: String? = nil) -> TableData<Element> {
		return rowMutation().sectionMutation(header: header, footer: footer).tableData()
	}
#endif
}

extension ArrayMutation {
	/// Construct a mutation that represents the insertion of a value at an index.
	static func inserted(_ value: Value, at index: Int) -> ArrayMutation<Value> {
		return ArrayMutation(insertedIndex: index, value: value)
	}

	/// Construct a mutation that discards any previous history and simply starts with a completely new array.
	static func reload<S: Sequence>(_ values: S) -> ArrayMutation<Value> where S.Element == Value {
		return ArrayMutation(reload: Array(values))
	}

	/// Construct a mutation that represents the update of a value at an index.
	static func updated(_ value: Value, at index: Int) -> ArrayMutation<Value> {
		return ArrayMutation(updatedIndex: index, value: value)
	}

	/// Construct a mutation that represents the update of a value at an index.
	static func moved(from sourceIndex: Int, to targetIndex: Int) -> ArrayMutation<Value> {
		return ArrayMutation(movedIndex: sourceIndex, targetIndex: targetIndex)
	}
	
	func rowMutation() -> TableRowMutation<Value> {
		return TableRowMutation(arrayMutation: self)
	}
	
#if os(iOS)
	func sectionMutation(header: String? = nil, footer: String? = nil) -> TableSectionMutation<Value> {
		return rowMutation().sectionMutation(header: header, footer: footer)
	}
	
	func tableData(header: String? = nil, footer: String? = nil) -> TableData<Value> {
		return rowMutation().sectionMutation(header: header, footer: footer).tableData()
	}
#endif
}

#if os(iOS)
extension TableRowMutation {
	func sectionMutation(header: String? = nil, footer: String? = nil) -> TableSectionMutation<Value> {
		return TableSectionMutation(header: header, footer: footer, rowMutation: self)
	}
	
	func tableData(header: String? = nil, footer: String? = nil) -> TableData<Value> {
		return sectionMutation(header: header, footer: footer).tableData()
	}
}

extension TableSectionMutation {
	func tableData() -> TableRowMutation<TableSectionMutation<Value>> {
		return TableRowMutation(array: [self])
	}
}

extension TableRowMutation {
	static func tableData<RowData>(sections: [TableSectionMutation<RowData>]) -> TableData<RowData> where TableSectionMutation<RowData> == Value {
		return TableRowMutation(array: sections)
	}

	static func tableDataFromSections<RowData>(_ sections: TableSectionMutation<RowData>...) -> TableData<RowData> where TableSectionMutation<RowData> == Value {
		return TableRowMutation(array: sections)
	}
}
#endif

extension SignalInterface {
	func arrayMutationToRowMutation<Value>() -> Signal<TableRowMutation<Value>> where ArrayMutation<Value> == OutputValue {
		return map(initialState: 0) { (globalCount: inout Int, arrayMutation: ArrayMutation<Value>) -> TableRowMutation<Value> in
			arrayMutation.delta(&globalCount)
			return TableRowMutation(arrayMutation: arrayMutation, localOffset: 0, globalCount: globalCount)
		}
	}
	
#if os(iOS)
	func arrayMutationToSectionMutation<Value>(header: String? = nil, footer: String? = nil) -> Signal<TableSectionMutation<Value>> where ArrayMutation<Value> == OutputValue {
		return map(initialState: 0) { (globalCount: inout Int, arrayMutation: ArrayMutation<Value>) -> TableSectionMutation<Value> in
			arrayMutation.delta(&globalCount)
			return TableSectionMutation(header: header, footer: footer, rowMutation: TableRowMutation(arrayMutation: arrayMutation, localOffset: 0, globalCount: globalCount))
		}
	}

	func tableData<Value>() -> Signal<TableData<Value>> where ArrayMutation<Value> == OutputValue {
		return Signal.sections(Signal.section(rowSignal: signal.map(initialState: 0) { (globalCount: inout Int, arrayMutation: ArrayMutation<Value>) -> TableRowMutation<Value> in
				arrayMutation.delta(&globalCount)
				return TableRowMutation(arrayMutation: arrayMutation, localOffset: 0, globalCount: globalCount)
			})
		)
	}
	
	static func sections<RowData>(signals: [Signal<TableSectionMutation<RowData>>]) -> Signal<TableRowMutation<TableSectionMutation<RowData>>> where TableRowMutation<TableSectionMutation<RowData>> == OutputValue {
		var result: [Signal<TableRowMutation<TableSectionMutation<RowData>>>] = []
		let count = signals.count
		for (index, sectionSignal) in signals.enumerated() {
			result += sectionSignal.map { section in
				let mutation = ArrayMutation<TableSectionMutation<RowData>>(updatedIndex: index, value: section)
				return TableRowMutation(arrayMutation: mutation, localOffset: 0, globalCount: count, animation: noTableViewAnimation)
			}
		}
		let sections = TableRowMutation<TableSectionMutation<RowData>>(arrayMutation: ArrayMutation(insertedRange: 0..<signals.count, values: Array<TableSectionMutation<RowData>>(repeating: TableSectionMutation<RowData>(), count: signals.count)), localOffset: 0, globalCount: signals.count)
		let (mergedInput, mergedSignal) = Signal<TableRowMutation<TableSectionMutation<RowData>>>.createMergedInput()
		for s in result {
			mergedInput.add(s)
		}
		return mergedSignal.startWith(sequence: [sections])
	}

	static func sections<RowData>(_ signals: Signal<TableSectionMutation<RowData>>...) -> Signal<TableRowMutation<TableSectionMutation<RowData>>> where TableRowMutation<TableSectionMutation<RowData>> == OutputValue {
		return sections(signals: signals)
	}

	static func section<Value>(header: String? = nil, footer: String? = nil, rowSignal: Signal<TableRowMutation<Value>>) -> Signal<OutputValue> where TableSectionMutation<Value> == OutputValue {
		return rowSignal.map(initialState: false) { (state: inout Bool, value: TableRowMutation<Value>) -> TableSectionMutation<Value> in
			if !state {
				state = true
				return TableSectionMutation<Value>(header: header, footer: footer, rowMutation: value)
			} else {
				return TableSectionMutation<Value>(rowMutation: value)
			}
		}
	}
#endif
}

import Foundation

extension NSCoder {
	/// Gets the latest value from the signal and encodes the value as JSON data into self using the provided key
	///
	/// - Parameters:
	///   - interface: exposes the signal
	///   - forKey: key used for encoding (is `String.viewStateKey` by default)
	func encodeLatest<Interface>(from interface: Interface, forKey: String = .viewStateKey) where Interface: SignalInterface, Interface.OutputValue: Codable {
		if let data = interface.peekData() {
			_ = self.encode(data, forKey: forKey)
		}
	}

	/// Decodes the JSON data in self, associated with the provided key, and sends into the signal input.
	///
	/// - Parameters:
	///   - inputInterface: exposes the signal input
	///   - forKey: key used for decoding (is `String.viewStateKey` by default)
	func decodeSend<InputInterface>(to inputInterface: InputInterface, forKey: String = .viewStateKey) where InputInterface: SignalInputInterface, InputInterface.InputValue: Codable {
		if let data = self.decodeObject(forKey: forKey) as? Data, let value = try? JSONDecoder().decode(InputInterface.InputValue.self, from: data) {
			inputInterface.input.send(value: value)
		}
	}
}

extension SignalInterface where OutputValue == Data {
	func decode<Target: Decodable>(as decodableType: Target.Type) -> Signal<Target> {
		return transformValues { v, n in n.send(result: Result { try JSONDecoder().decode(decodableType, from: v) }) }
	}
}

extension SignalInterface where OutputValue: Encodable {
	func peekData() -> Data? {
		return peek().flatMap { try? JSONEncoder().encode($0) }
	}

	func data() -> Signal<Data> {
		return transformValues { v, n in n.send(result: Result { try JSONEncoder().encode(v) }) }
	}

	/// This function subscribes to the signal and logs emitted values as JSON data to the console
	///
	/// - Parameter prefix: pre-pended to each JSON value
	/// - Returns: an endpoint which will keep this logger alive
	func logJson(prefix: String = "", outputFormatting: JSONEncoder.OutputFormatting = .prettyPrinted) -> SignalOutput<OutputValue> {
		return subscribe { result in
			switch result {
			case .success(let v):
				let enc = JSONEncoder()
				enc.outputFormatting = outputFormatting
				if let data = try? enc.encode(v), let string = String(data: data, encoding: .utf8) {
					print("\(prefix)\(string)")
				}
			case .failure(let e):
				print("\(prefix)\(e)")
			}
		}
	}
}

extension String {
	static let viewStateKey = "viewStateData"
}

struct NonPersistentStateAdapterState: Codable, Error {}

protocol StateAdapterBehavior {
	associatedtype State
	associatedtype Message
	associatedtype Notification
	associatedtype PersistentState: Codable = NonPersistentStateAdapterState
	
	static func reducer(state: inout State, message: Message) -> Notification?
	static func resume(state: State) -> Notification?
	static func initialize(message: Message) -> (State?, Notification?)
	static func persistentState(_ state: State) -> PersistentState
	static func stateFromPersistentState(_ state: PersistentState) throws -> State
}

extension StateAdapterBehavior where PersistentState == NonPersistentStateAdapterState {
	static func childValues(_ state: State) -> [StateContainer]? {
		return nil
	}
	
	static func persistentState(_ state: State) -> PersistentState {
		return NonPersistentStateAdapterState()
	}
	
	static func stateFromPersistentState(_ state: PersistentState) throws -> State {
		throw NonPersistentStateAdapterState()
	}
}

extension StateAdapterBehavior where PersistentState == State {
	static func persistentState(_ state: State) -> PersistentState {
		return state
	}
	
	static func stateFromPersistentState(_ state: PersistentState) throws -> State {
		return state
	}
}

struct StateAdapter<RB: StateAdapterBehavior>: StateContainer, SignalInputInterface, SignalInterface {
	typealias OutputValue = RB.Notification
	typealias InputValue = RB.Message
	
	private enum Content {
		case none
		case state(RB.State)
		case notification(RB.State?, RB.Notification?)
	}
	
	private let channel: SignalChannel<RB.Message, SignalMultiInput<RB.Message>, Content, SignalMulti<Content>>
	
	var input: SignalInput<RB.Message> { return channel.input }
	var signal: Signal<RB.Notification> { return channel.signal.compactMap {
		switch $0 {
		case .none: return nil
		case .state(let s): return RB.resume(state: s)
		case .notification(_, let n): return n
		}
	} }
	
	private init(initialState: Content) {
		channel = Signal<RB.Message>.multiChannel().reduce(initialState: initialState) { (content: inout Content, message: RB.Message) -> Content in
			switch content {
			case .none, .notification(.none, _):
				let (possibleState, notification) = RB.initialize(message: message)
				if let state = possibleState {
					content = Content.state(state)
				}
				return Content.notification(possibleState, notification)
			case .state(var s):
				let n = RB.reducer(state: &s, message: message)
				content = Content.state(s)
				return Content.notification(s, n)
			case .notification(.some(var s), _):
				let n = RB.reducer(state: &s, message: message)
				content = Content.state(s)
				return Content.notification(s, n)
			}
		}
	}
	
	init(_ initialValue: RB.State) {
		self.init(initialState: Content.state(initialValue))
	}
	
	init() {
		self.init(initialState: Content.none)
	}
	
	func cancel() {
		if RB.State.self is StateContainer.Type, let value = stateSignal.peek(), var sc = value as? StateContainer {
			sc.cancel()
		}
		input.cancel()
	}
	
	var childValues: [StateContainer] {
		if RB.State.self is StateContainer.Type, let value = stateSignal.peek(), let sc = value as? StateContainer {
			return sc.childValues
		}
		return []
	}

	var stateSignal: Signal<RB.State> {
		return channel.signal.compactMap { (content: Content) -> RB.State? in
			switch content {
			case .none, .notification(nil, _): return nil
			case .state(let s): return s
			case .notification(.some(let s), _): return s
			}
		}
	}
	
	var persistentValueChanged: Signal<Void> {
		if RB.PersistentState.self == NonPersistentStateAdapterState.self {
			return Signal<Void>.preclosed()
		}
		
		if !(RB.State.self is StateContainer.Type) {
			return stateSignal.map { _ in () }.dropActivation()
		}
		
		return channel.signal.flatMapLatest { (content: Content) -> Signal<Void> in
			switch content {
			case .state(let s):
				return (s as? StateContainer)?.persistentValueChanged ?? Signal<Void>.preclosed()
			case .notification(let s as StateContainer, _):
				return s.persistentValueChanged.startWith(())
			default: return Signal<Void>.preclosed()
			}
		}.dropActivation()
	}
	
	enum Keys: CodingKey { case `var` }
	
	func encode(to encoder: Encoder) throws {
		if RB.PersistentState.self != NonPersistentStateAdapterState.self, let s = stateSignal.peek() {
			var c = encoder.container(keyedBy: Keys.self)
			try c.encode(RB.persistentState(s), forKey: .var)
		}
	}
	
	init(from decoder: Decoder) throws {
		if RB.PersistentState.self == NonPersistentStateAdapterState.self {
			self.init()
			return
		}
		
		// Decoding must:
		// * Use keyed container
		// * Call `decode`, not `decodeIfPresent`
		// * Catch errors from the `decode` (using try? and optional unwrapping is insufficient)
		// Unless I've missed something, this specific pattern appears to be necessary to correctly decode potentially optional `RB.PersistentState` without *knowing* whether it is defined as an optional – but also handle a situation where it might not be present at all.
		let c = try decoder.container(keyedBy: Keys.self)
		let state = try c.decode(RB.PersistentState.self, forKey: .var)
		try self.init(RB.stateFromPersistentState(state))
	}
}

enum VarChange<Value> {
	case set(Value)
	case update(Value)
	case notify(Value)
}

struct VarBehavior<Value: Codable>: StateAdapterBehavior {
	typealias State = Value
	typealias Message = VarChange<Value>
	typealias Notification = Value
	typealias PersistentState = Value
	
	static func reducer(state: inout State, message: Message) -> Notification? {
		switch message {
		case .set(let v):
			state = v
			return v
		case .update(let v):
			state = v
			return nil
		case .notify(let v):
			return v
		}
	}
	
	static func resume(state: State) -> Notification? {
		return state
	}
	
	static func initialize(message: Message) -> (Value?, Value?) {
		switch message {
		case .set(let v): return (v, v)
		case .update(let v): return (v, nil)
		case .notify(let v): return (nil, v)
		}
	}
}

struct Var<Value: Codable>: StateContainer, SignalInputInterface, SignalInterface {
	typealias OutputValue = Value
	typealias InputValue = Value

	let adapter: StateAdapter<VarBehavior<Value>>
	
	var input: SignalInput<Value> { return Input().map { .set($0) }.bind(to: adapter.input) }
	var signal: Signal<Value> { return adapter.signal }

	init(_ initialValue: Value) {
		adapter = StateAdapter(initialValue)
	}
	var updatingInput: SignalInput<Value> {
		return Input().map { .update($0) }.bind(to: adapter.input)
	}
	
	var notifyingInput: SignalInput<Value> {
		return Input().map { .notify($0) }.bind(to: adapter.input)
	}

	func saveToCoder(_ coder: NSCoder) {
		coder.encodeLatest(from: adapter.stateSignal)
	}
	
	func restoreFromCoder(_ coder: NSCoder) {
		coder.decodeSend(to: input)
	}
	
	var persistentValueChanged: Signal<Void> {
		return adapter.persistentValueChanged
	}
	
	func logJson(prefix: String = "") -> SignalOutput<Var<Value>> {
		return persistentValueChanged.map { _ in
			self
		}.startWith(self).logJson(prefix: prefix)
	}
	
	var childValues: [StateContainer] {
		return adapter.childValues
	}

	func encode(to encoder: Encoder) throws {
		var c = encoder.singleValueContainer()
		try c.encode(adapter)
	}
	
	init(from decoder: Decoder) throws {
		let c = try decoder.singleValueContainer()
		self.adapter = try c.decode(StateAdapter<VarBehavior<Value>>.self)
	}
}

struct TempBehavior<Value>: StateAdapterBehavior {
	typealias State = Value
	typealias Message = Value
	typealias Notification = Value
	
	static func reducer(state: inout State, message: Message) -> Notification? {
		state = message
		return state
	}
	
	static func resume(state: State) -> Notification? {
		return state
	}
	
	static func initialize(message: Message) -> (Value?, Value?) {
		return (message, message)
	}
}

typealias TempVar<Value> = StateAdapter<TempBehavior<Value>>

struct ToggleBehavior: StateAdapterBehavior {
	typealias State = Bool
	typealias Message = ()
	typealias Notification = Bool
	typealias PersistentState = Bool
	
	static func reducer(state: inout State, message: Message) -> Notification? {
		state = !state
		return state
	}
	
	static func resume(state: State) -> Notification? {
		return state
	}
	
	static func initialize(message: Message) -> (State?, State?) {
		return (false, false)
	}
}

typealias ToggleAdapter = StateAdapter<ToggleBehavior>

/// A preparer interprets a set of bindings and applies them to an instance.
protocol BinderPreparer {
	associatedtype EnclosingBinder: BinderChain

	// A preparer must be default constructible (the bindings are the parameters)
	init()
	
	/// A first scan of the bindings. Information about bindings present may be recorded during this time.
	///
	/// - Parameter binding: the binding to apply
	mutating func prepareBinding(_ binding: EnclosingBinder.Binding)
	
	/// Bindings which need to be applied before others can be applied at this special early stage
	///
	/// - Parameters:
	///   - instance: the instance
	///   - storage: the storage
	mutating func prepareInstance(_ instance: EnclosingBinder.Instance, storage: EnclosingBinder.Storage)
	
	/// Apply typical bindings.
	///
	/// - Parameters:
	///   - binding: the binding to apply
	///   - instance: the instance
	///   - storage: the storage
	/// - Returns: If maintaining bindings requires ongoing lifetime management, these lifetimes are maintained by returning instances of `Lifetime`.
	func applyBinding(_ binding: EnclosingBinder.Binding, instance: EnclosingBinder.Instance, storage: EnclosingBinder.Storage) -> Lifetime?
	
	/// Bindings which need to be applied after others can be applied at this last stage.
	///
	/// - Parameters:
	///   - instance: the instance
	///   - storage: the storage
	/// - Returns: If maintaining bindings requires ongoing lifetime management, these lifetimes are maintained by returning instances of `Lifetime`
	mutating func finalizeInstance(_ instance: EnclosingBinder.Instance, storage: EnclosingBinder.Storage) -> Lifetime?
}

/// Preparers are normally linked together in a chain, mimicking the chain of Binders, so Bindings from the linked Binder can be applied to current instance.
protocol DerivedPreparer: BinderPreparer where EnclosingBinder: Binder {
	/// Inherited bindings will be applied by the inherited preparer
	var linkedPreparer: EnclosingBinder.Inherited.Preparer { get set }
}

/// Preparers usually default construct the `Storage` except in specific cases where the storage needs a reference to the instance.
protocol StoragePreparer: DerivedPreparer {
	/// Constructs the `Storage`
	///
	/// - Returns: the storage
	func constructStorage() -> EnclosingBinder.Storage
}

/// Preparers usually construct the `Instance` from a subclass type except in specific cases where additional non-binding parameters are required for instance construction.
protocol ConstructingPreparer: StoragePreparer {
	/// Constructs the `Instance`
	///
	/// - Parameter subclass: subclass of the instance type to use for construction
	/// - Returns: the instance
	func constructInstance(subclass: EnclosingBinder.Instance.Type) -> EnclosingBinder.Instance
}

extension DerivedPreparer {
	/// Invokes `prepareBinding` once with each element of the `bindings`
	///
	/// - Parameter bindings: prepareBinding will be invoked with each element
	mutating func prepareBindings( _ bindings: [EnclosingBinder.Binding]) {
		for b in bindings {
			prepareBinding(b)
		}
	}
	
	/// The default prepare workflow – in either `Binder.binderConstruct` or `Binder.binderApply` is, in order: `prepareBindings` (`constructInstance` for `Binder.binderConstruct`), `constructStorage` and then this function.
	///
	/// - Parameters:
	///   - bindings: from the binder parameters
	///   - instance: the constructed or apply instance
	///   - storage: the constructed storage
	///   - additional: any ad hoc bindings
	///   - combine: link the instance, storage and lifetimes together
	mutating func applyBindings(_ bindings: [EnclosingBinder.Binding], instance: EnclosingBinder.Instance, storage: EnclosingBinder.Storage, additional: ((EnclosingBinder.Instance) -> Lifetime?)?, combine: (EnclosingBinder.Instance, EnclosingBinder.Storage, [Lifetime]) -> Void) {
		// Prepare.
		prepareInstance(instance, storage: storage)
		
		// Apply styles that need to be applied after construction
		var lifetimes = [Lifetime]()
		for b in bindings {
			if let c = applyBinding(b, instance: instance, storage: storage) {
				lifetimes.append(c)
			}
		}
		
		// Finalize the instance
		if let c = finalizeInstance(instance, storage: storage) {
			lifetimes.append(c)
		}
		
		// Append adhoc bindings, if any
		if let a = additional, let c = a(instance) {
			lifetimes.append(c)
		}
		
		// Combine the instance and binder
		combine(instance, storage, lifetimes)
	}

	/// A first scan of the bindings. Information about bindings present may be recorded during this time.
	///
	/// - Parameter binding: the binding to apply
	mutating func prepareBinding(_ binding: EnclosingBinder.Binding) {
		if let ls = EnclosingBinder.bindingToInherited(binding) {
			linkedPreparer.prepareBinding(ls)
		}
	}
	
	/// Bindings which need to be applied before others can be applied at this special early stage
	///
	/// - Parameters:
	///   - instance: the instance
	///   - storage: the storage
	mutating func prepareInstance(_ instance: EnclosingBinder.Instance, storage: EnclosingBinder.Storage) {
		if let i = instance as? EnclosingBinder.Inherited.Instance, let s = storage as? EnclosingBinder.Inherited.Storage {
			linkedPreparer.prepareInstance(i, storage: s)
		}
	}

	/// Apply typical bindings.
	///
	/// - Parameters:
	///   - binding: the binding to apply
	///   - instance: the instance
	///   - storage: the storage
	/// - Returns: If maintaining bindings requires ongoing lifetime management, these lifetimes are maintained by returning instances of `Lifetime`.
	func applyBinding(_ binding: EnclosingBinder.Binding, instance: EnclosingBinder.Instance, storage: EnclosingBinder.Storage) -> Lifetime? {
		if let ls = EnclosingBinder.bindingToInherited(binding), let i = instance as? EnclosingBinder.Inherited.Instance, let s = storage as? EnclosingBinder.Inherited.Storage {
			return linkedPreparer.applyBinding(ls, instance: i, storage: s)
		}
		return nil
	}
	
	/// Bindings which need to be applied after others can be applied at this last stage.
	///
	/// - Parameters:
	///   - instance: the instance
	///   - storage: the storage
	/// - Returns: If maintaining bindings requires ongoing lifetime management, these lifetimes are maintained by returning instances of `Lifetime`
	mutating func finalizeInstance(_ instance: EnclosingBinder.Instance, storage: EnclosingBinder.Storage) -> Lifetime? {
		if let i = instance as? EnclosingBinder.Inherited.Instance, let s = storage as? EnclosingBinder.Inherited.Storage {
			return linkedPreparer.finalizeInstance(i, storage: s)
		}
		return nil
	}
}

/// A simple wrapper around a value used to identify "static" bindings (bindings which are applied only at construction time)
struct Constant<Value> {
	typealias ValueType = Value
	let value: Value
	init(_ value: Value) {
		self.value = value
	}
	static func constant(_ value: Value) -> Constant<Value> {
		return Constant<Value>(value)
	}
}

/// An either type for a value or a signal emitting values of that type. Used for "value" bindings (bindings which set a property on the underlying instance)
enum Dynamic<Value> {
	typealias ValueType = Value
	case constant(Value)
	case dynamic(Signal<Value>)
	
	/// Gets the initial (i.e. used in the constructor) value from the `Dynamic`
	func initialSubsequent() -> InitialSubsequent<Value> {
		switch self {
		case .constant(let v):
			return InitialSubsequent<Value>(initial: v)
		case .dynamic(let signal):
			let sc = signal.capture()
			return InitialSubsequent<Value>(initial: sc.currentValue, subsequent: sc)
		}
	}
	
	/// Gets the initial (i.e. used in the constructor) value from the `Dynamic`
	func captureValues() -> [Value] {
		switch self {
		case .constant(let v): return [v]
		case .dynamic(let signal): return signal.capture().values
		}
	}
	
	/// Converts this `Dynamic` into a signal by returning the `.dynamic` signal or returning the `.constant` wrapped in a signal.
	func signal() -> Signal<Value> {
		switch self {
		case .constant(let v): return Signal<Value>.preclosed(v)
		case .dynamic(let signal): return signal
		}
	}
	
	// Gets the subsequent (i.e. after construction) values from the `Dynamic`
	func apply<I: AnyObject, B: BinderStorage>(_ instance: I, _ storage: B, _ onError: Value? = nil, handler: @escaping (I, B, Value) -> Void) -> Lifetime? {
		switch self {
		case .constant(let v):
			handler(instance, storage, v)
			return nil
		case .dynamic(let signal):
			return signal.subscribe(context: .main) { [weak instance, weak storage] r in
				guard let i = instance, let s = storage else { return }
				switch (r, onError) {
				case (.success(let v), _): handler(i, s, v)
				case (.failure, .some(let v)): handler(i, s, v)
				case (.failure, .none): break
				}
			}
		}
	}
}

struct InitialSubsequent<Value> {
	private var capturedValue: Value?
	var shouldResend: Bool
	let subsequent: SignalCapture<Value>?
	
	init(initial: Value? = nil, shouldResend: Bool = true, subsequent: SignalCapture<Value>? = nil) {
		self.capturedValue = initial
		self.shouldResend = shouldResend
		self.subsequent = subsequent
	}
	
	mutating func initial() -> Value? {
		let c = capturedValue
		capturedValue = nil
		shouldResend = false
		return c
	}

	func resume() -> Signal<Value>? {
		if let s = subsequent {
			return s.resume(resend: shouldResend)
		} else if shouldResend, let i = capturedValue {
			return Signal<Value>.preclosed(i)
		}
		return nil
	}
}

extension Signal {
	func apply<I: AnyObject, B: BinderStorage>(_ instance: I?, _ storage: B?, handler: @escaping (I, B, OutputValue) -> Void) -> Lifetime? {
		return subscribeValues(context: .main) { [weak instance, weak storage] v in
			guard let i = instance, let s = storage else { return }
			handler(i, s, v)
		}
	}
}

extension SignalCapture {
	func apply<I: AnyObject, B: BinderStorage>(_ instance: I, _ storage: B, handler: @escaping (I, B, OutputValue) -> Void) -> Lifetime? {
		return subscribeValues(context: .main) { [weak instance, weak storage] v in
			guard let i = instance, let s = storage else { return }
			handler(i, s, v)
		}
	}
}

extension SignalInterface {
	func adhocBinding<Subclass: AnyObject>(toType: Subclass.Type, using: @escaping (Subclass, OutputValue) -> Void) -> (AnyObject) -> Lifetime? {
		return { (instance: AnyObject) -> Lifetime? in
			return self.signal.subscribeValues(context: .main) { [weak instance] value in
				if let i = instance as? Subclass {
					using(i, value)
				}
			}
		}
	}
}

import Foundation

/// An "Either" type for use in scenarios where "Equatable" and "Codable" are required but there's only ever a single "Master" instance so equality is implied. This is common in Navigation Controller stacks and Split Views.
enum MasterOrDetail<Master: StateContainer, Detail: StateContainer>: StateContainer {
	case master(Master)
	case detail(Detail)
	
	var childValues: [StateContainer] {
		switch self {
		case .master(let tvm): return [tvm]
		case .detail(let dvm): return [dvm]
		}
	}

	enum Keys: CodingKey { case master, detail }
	
	func encode(to encoder: Encoder) throws {
		var c = encoder.container(keyedBy: Keys.self)
		switch self {
		case .master(let tvm): try c.encode(tvm, forKey: .master)
		case .detail(let dvm): try c.encode(dvm, forKey: .detail)
		}
	}
	
	init(from decoder: Decoder) throws {
		let c = try decoder.container(keyedBy: Keys.self)
		if let tvm = try c.decodeIfPresent(Master.self, forKey: .master) {
			self = .master(tvm)
		} else {
			self = .detail(try c.decode(Detail.self, forKey: .detail))
		}
	}
}

/// This "StateAdapter" is a `ModelSignalValue` that manages a stack of navigation items as might be used by a UINavigationController. The adapter converts `push`, `popToCount` and `reload` messages into updates to the array of `PathElement`. The adapter includes convenient input signals, animated output signals and includes automatic implementation of coding and notification protocols.
struct StackAdapterBehavior<PathElement: Codable>: StateAdapterBehavior {
	typealias State = [PathElement]
	typealias Message = StackMutation<PathElement>
	typealias Notification = StackMutation<PathElement>
	typealias PersistentState = State
	
	static func reducer(state: inout State, message: Message) -> Notification? {
		switch message {
		case .push(let e):
			state.append(e)
			return message
		case .pop:
			_ = state.popLast()
			return message
		case .popToCount(let i):
			if i >= 1, i < state.count {
				state.removeLast(state.count - i)
				return message
			}
			return nil
		case .reload(let newStack):
			state = newStack
			return message
		}
	}
	
	static func resume(state: State) -> Notification? {
		return .reload(state)
	}
	
	static func initialize(message: Message) -> (State?, Notification?) {
		var state = [PathElement]()
		let n = reducer(state: &state, message: message)
		return (state, n)
	}
}

extension StateAdapter where RB.State: Collection, RB.Message == StackMutation<RB.State.Element> {
	var pushInput: SignalInput<RB.State.Element> {
		return Signal<RB.State.Element>.channel().map { RB.Message.push($0) }.bind(to: input)
	}

	var poppedToCount: SignalInput<Int> {
		return Signal<Int>.channel().map { RB.Message.popToCount($0) }.bind(to: input)
	}
}

typealias StackAdapter<PathElement: Codable> = StateAdapter<StackAdapterBehavior<PathElement>>

/// A constructing binder can build the instance. As a simplification, this protocol requires that the `Output` and `Instance` types are the same (binders where this is not the case must be built on `Binder`).
protocol ConstructingBinder: Binder where Output == Instance {
	/// Build the instance from the parameters in the binder state or return an already constructed instance. If state is `.consumed` this will trigger a fatal error.
	///
	/// - Parameter additional: ad hoc bindings (this is a chance to apply changes to the instance after construction and establish additional behaviors).
	/// - Returns: the constructed and configured instance (newly created if state was `.pending` or pre-existing if state was `.constructed`)
	func instance(additional: ((Instance) -> Lifetime?)?) -> Instance
}

extension ConstructingBinder where Parameters == BinderSubclassParameters<Instance, Binding>, Preparer: ConstructingPreparer, Instance: NSObject {
	/// Build the instance from the parameters in the binder state or return an already constructed instance. If state is `.consumed` this will trigger a fatal error.
	///
	/// - Parameter additional: ad hoc bindings (this is a chance to apply changes to the instance after construction and establish additional behaviors).
	/// - Returns: the constructed and configured instance (newly created if state was `.pending` or pre-existing if state was `.constructed`)
	func instance(additional: ((Instance) -> Lifetime?)? = nil) -> Instance {
		return binderConstruct(
			additional: additional,
			storageConstructor: { prep, params, i in prep.constructStorage() },
			instanceConstructor: { prep, params in prep.constructInstance(subclass: params.subclass) },
			combine: embedStorageIfInUse,
			output: { i, s in i })
	}
}


#if os(macOS)
	import AppKit
	
	protocol ViewConvertible {
		func nsView() -> Layout.View
	}
	extension Layout.View: ViewConvertible {
		func nsView() -> Layout.View {
			return self
		}
	}
#else
	import UIKit
	
	protocol ViewConvertible {
		func uiView() -> Layout.View
	}
	extension Layout.View: ViewConvertible {
		func uiView() -> Layout.View {
			return self
		}
	}
#endif

/// When a layout is applied, it can animate one of three ways:
///
/// - none: do not animate to the new layout
/// - all: animate to the new layout
/// - subsequent: animate to the new layout only if there was a previous layout
enum AnimationChoice {
	case none
	case all
	case subsequent
}

// This type handles a combination of `layoutMargin` and `safeAreaMargin` inset edges. If a `safeArea` edge is specified, it will be used instead of `layout` edge.
struct MarginEdges: OptionSet {
	static var none: MarginEdges { return MarginEdges(rawValue: 0) }
	static var topLayout: MarginEdges { return MarginEdges(rawValue: 1) }
	static var leadingLayout: MarginEdges { return MarginEdges(rawValue: 2) }
	static var bottomLayout: MarginEdges { return MarginEdges(rawValue: 4) }
	static var trailingLayout: MarginEdges { return MarginEdges(rawValue: 8) }
	static var topSafeArea: MarginEdges { return MarginEdges(rawValue: 16) }
	static var leadingSafeArea: MarginEdges { return MarginEdges(rawValue: 32) }
	static var bottomSafeArea: MarginEdges { return MarginEdges(rawValue: 64) }
	static var trailingSafeArea: MarginEdges { return MarginEdges(rawValue: 128) }
	static var allLayout: MarginEdges { return [.topLayout, .leadingLayout, .bottomLayout, .trailingLayout] }
	static var allSafeArea: MarginEdges { return [.topSafeArea, .leadingSafeArea, .bottomSafeArea, .trailingSafeArea] }
	let rawValue: UInt
	init(rawValue: UInt) {
		self.rawValue = rawValue
	}
}

#if os(macOS)
	extension NSView {
		/// Adds the views contained by `layout` in the arrangment described by the layout to `self`.
		///
		/// - Parameter layout: a set of views and layout descriptions
		func applyLayout(_ layout: Layout?) {
			applyLayoutToView(view: self, params: layout.map { (layout: $0, bounds: Layout.Bounds(view: self, marginEdges: .none)) })
		}
	}
#else
	extension UIView {
		/// Adds the views contained by `layout` in the arrangment described by the layout to `self`.
		///
		/// - Parameter layout: a set of views and layout descriptions
		func applyLayout(_ layout: Layout?) {
			applyLayoutToView(view: self, params: layout.map { (layout: $0, bounds: Layout.Bounds(view: self, marginEdges: $0.marginEdges)) })
		}
	}
	
	extension UIScrollView {
		/// Adds the views contained by `layout` in the arrangment described by the layout to `self`.
		///
		/// - Parameter layout: a set of views and layout descriptions
		func applyContentLayout(_ layout: Layout?) {
			applyLayoutToView(view: self, params: layout.map { (layout: $0, bounds: Layout.Bounds(scrollView: self)) })
		}
	}
#endif

/// A data structure for describing a layout as a series of nested columns and rows.
struct Layout {
	/// A rough equivalent to UIStackViewAlignment, minus baseline cases which aren't handled
	enum Alignment { case leading, trailing, center, fill }
	
	#if os(macOS)
		typealias Axis = NSUserInterfaceLayoutOrientation
		typealias View = NSView
		typealias Guide = NSLayoutGuide
	#else
		typealias Axis = NSLayoutConstraint.Axis
		typealias View = UIView
		typealias Guide = UILayoutGuide
	#endif
	
	/// Layout is either horizontal or vertical (although any element within the layout may be a layout in the perpendicular direction)
	let axis: Axis
	
	/// Within the horizontal row or vertical column, layout entities may fill, center or align-leading or align-trailing
	let align: Alignment
	
	/// The layout may extend to the view bounds or may be limited by the safeAreaMargins or layoutMargins. The safeArea insets supercede the layoutMargins (prior to iOS 11, safeArea is interpreted as UIViewController top/bottom layout guides when laying out within a UIViewController, otherwise it is treated as a synonym for the layoutMargins). This value has no effect on macOS.	
	let marginEdges: MarginEdges
	
	/// When applied to the top level `Layout` passed to 'applyLayout`, then replacing an existing layout on a view, if this variable is true, after applying the new layout, `layoutIfNeeded` will be called inside a `UIView.beginAnimations`/`UIView.endAnimations` block. Has no effect when set on a child `Layout`.
	let animate: AnimationChoice
	
	/// This is the list of views, spaces and sublayouts that will be layed out.
	var entities: [Entity]
	
	/// The default constructor assigns all values. In general, it's easier to use the `.horizontal` or `.vertical` constructor where possible.
	init(axis: Axis, align: Alignment = .fill, marginEdges: MarginEdges = .allSafeArea, animate: AnimationChoice = .subsequent, entities: [Entity]) {
		self.axis = axis
		self.align = align
		self.entities = entities
		self.marginEdges = marginEdges
		self.animate = animate
	}
	
	/// A convenience constructor for a horizontal layout
	static func horizontal(align: Alignment = .fill, marginEdges: MarginEdges = .allSafeArea, animate: AnimationChoice = .subsequent, _ entities: Entity...) -> Layout {
		return Layout(axis: .horizontal, align: align, marginEdges: marginEdges, animate: animate, entities: entities)
	}
	
	/// A convenience constructor for a vertical layout
	static func vertical(align: Alignment = .fill, marginEdges: MarginEdges = .allSafeArea, animate: AnimationChoice = .subsequent, _ entities: Entity...) -> Layout {
		return Layout(axis: .vertical, align: align, marginEdges: marginEdges, animate: animate, entities: entities)
	}
	
	/// A convenience constructor for a vertical layout
	static func single(align: Alignment = .fill, marginEdges: MarginEdges = .allSafeArea, animate: AnimationChoice = .subsequent, length: Dimension? = nil, breadth: Dimension? = nil, relative: Bool = false, _ view: ViewConvertible) -> Layout {
		return Layout(axis: .vertical, align: align, marginEdges: marginEdges, animate: animate, entities: [Entity.view(length: length, breadth: breadth, relative: relative, view)])
	}
	
	// Used for removing all views from their superviews
	fileprivate func forEachView(_ visit: (View) -> Void) {
		entities.forEach { $0.forEachView(visit) }
	}

	/// The `Layout` describes a series of these `Entity`s which may be a space, a view or a sublayout. There is also a special `matched` layout which allows a series of "same length" entities.
	///
	/// - interViewSpace: AppKit and UIKit use an 8 screen unit space as the "standard" space between adjacent views.
	/// - space: an arbitrary space between views
	/// - view: a view with optional width and height (if not specified, the view will use its "intrinsic" size or will fill the available layout space)
	/// - layout: a nested layout which may be parallel or perpedicular to its container and whose size may be specified (like view)
	/// - matched: a sequence of alternating "same size" and independent entities (you can use `.space(0)` if you don't want independent entities).
	struct Entity {
		enum Content {
			case space(Dimension)
			case sizedView(Layout.View, Size?)
			indirect case layout(Layout, size: Size?)
			indirect case matched(Matched)
		}
		let content: Content
		init(_ content: Content) {
			self.content = content
		}
		
		fileprivate func forEachView(_ visit: (Layout.View) -> Void) {
			switch content {
			case .sizedView(let v, _):
				#if os(macOS)
					visit(v.nsView())
				#else
					visit(v.uiView())
				#endif
			case .layout(let l, _): l.forEachView(visit)
			case .matched(let matched):
				matched.first.forEachView(visit)
				matched.subsequent.forEach { element in
					switch element {
					case .free(let entity): entity.forEachView(visit)
					case .dependent(let dependent): dependent.entity.forEachView(visit)
					}
				}
			default: break
			}
		}
		
		static func space(_ dimension: Dimension = .standardSpace) -> Entity {
			return Entity(.space(dimension))
		}
		
		static func view(length: Dimension? = nil, breadth: Dimension? = nil, relative: Bool = false, _ view: ViewConvertible) -> Entity {
			let size = Size(length: length, breadth: breadth, relative: relative)
			#if os(macOS)
				return Entity(.sizedView(view.nsView(), size))
			#else
				return Entity(.sizedView(view.uiView(), size))
			#endif
		}
		
		static func horizontal(align: Alignment = .fill, length: Dimension? = nil, breadth: Dimension? = nil, relative: Bool = false, _ entities: Entity...) -> Entity {
			let size = Size(length: length, breadth: breadth, relative: relative)
			return Entity(.layout(Layout(axis: .horizontal, align: align, marginEdges: .none, entities: entities), size: size))
		}
		
		static func vertical(align: Alignment = .fill, length: Dimension? = nil, breadth: Dimension? = nil, relative: Bool = false, _ entities: Entity...) -> Entity {
			let size = Size(length: length, breadth: breadth, relative: relative)
			return Entity(.layout(Layout(axis: .vertical, align: align, marginEdges: .none, entities: entities), size: size))
		}
		
		static func matchedPair(_ left: Entity, _ right: Entity, separator: Entity = .space(), priority: Dimension.Priority = .required) -> Entity {
			return Entity(.matched(Matched(
				first: left,
				subsequent: [
					.free(separator),
					.dependent(.init(entity: right, dimension: .equalTo(ratio: 1.0, priority: priority)))
				]
			)))
		}
		
		static func matched(_ first: Entity, _ subsequent: [Matched.Element]) -> Entity {
			return Entity(.matched(.init(first: first, subsequent: subsequent)))
		}
	}
	
	/// A `Matched` element in a layout is a first element, followed by an array of free and dependent elements. The dependent elements all have a dimension  relationship to the first element (e.g. same size).
	struct Matched {
		struct Dependent {
			let entity: Entity
			let dimension: Dimension
			init(entity: Entity, dimension: Dimension) {
				self.entity = entity
				self.dimension = dimension
			}
		}
		enum Element {
			case dependent(Dependent)
			case free(Entity)
		}
		let first: Entity
		let subsequent: [Element]
		init(first: Entity, subsequent: [Element]) {
			self.first = first
			self.subsequent = subsequent
		}
	}

	/// A `Size` is the combination of both length (size of a layout object in the direction of layout) or breadth (size of a layout object perpendicular to the layout direction). If the length includes a ratio, it is relative to the parent container but the breadth can be relative to the length, allowing for specifying an aspect ratio.
	struct Size {
		let length: Dimension?
		let breadth: Dimension?
		let relative: Bool
		
		init(length: Dimension? = nil, breadth: Dimension?, relative: Bool = false) {
			self.length = length
			self.breadth = breadth
			self.relative = relative
		}
	}

	/// When length (size of a layout object in the direction of layout) or breadth (size of a layout object perpendicular to the layout direction) is specified, it can be specified:
	///	* relative to the parent container (ratio)
	///	* in raw screen units (constant)
	/// The greater/less than and priority can also be specified.
	struct Dimension: ExpressibleByFloatLiteral, ExpressibleByIntegerLiteral {
		typealias FloatLiteralType = Double
		typealias IntegerLiteralType = Int
		
		#if os(macOS)
			typealias Relation = NSLayoutConstraint.Relation
			typealias Priority = NSLayoutConstraint.Priority
		#else
			typealias Relation = NSLayoutConstraint.Relation
			typealias Priority = UILayoutPriority
		#endif
		
		let ratio: CGFloat
		let constant: CGFloat
		let relationship: Relation
		let priority: Dimension.Priority
		init(ratio: CGFloat = 0, constant: CGFloat = 0, relationship: Dimension.Relation = .equal, priority: Dimension.Priority = .required) {
			self.ratio = ratio
			self.constant = constant
			self.relationship = relationship
			self.priority = priority
		}
		
		init(floatLiteral value: Double) {
			self.init(constant: CGFloat(value))
		}
		
		init(integerLiteral value: Int) {
			self.init(constant: CGFloat(value))
		}
		
		static var standardSpace: Dimension = 8
		
		static func lessThanOrEqualTo(ratio: CGFloat = 0, constant: CGFloat = 0, priority: Dimension.Priority = .required) -> Dimension {
			return Dimension(ratio: ratio, constant: constant, relationship: .lessThanOrEqual, priority: priority)
		}
		
		static func greaterThanOrEqualTo(ratio: CGFloat = 0, constant: CGFloat = 0, priority: Dimension.Priority = .required) -> Dimension {
			return Dimension(ratio: ratio, constant: constant, relationship: .greaterThanOrEqual, priority: priority)
		}
		
		static func equalTo(ratio: CGFloat = 0, constant: CGFloat = 0, priority: Dimension.Priority = .required) -> Dimension {
			return Dimension(ratio: ratio, constant: constant, relationship: .equal, priority: priority)
		}
		
		static var fillRemaining: Dimension {
			return equalTo(ratio: 1, priority: .userMid)
		}
		
		fileprivate func scaledConstraintBetween(first: NSLayoutDimension, second: NSLayoutDimension, constraints: inout [NSLayoutConstraint]) {
			let constraint: NSLayoutConstraint
			switch relationship {
			case .equal: constraint = first.constraint(equalTo: second, multiplier: ratio, constant: constant)
			case .lessThanOrEqual: constraint = first.constraint(lessThanOrEqualTo: second, multiplier: ratio, constant: constant)
			case .greaterThanOrEqual: constraint = first.constraint(greaterThanOrEqualTo: second, multiplier: ratio, constant: constant)
			}
			constraint.priority = priority
			constraints.append(constraint)
			constraint.isActive = true
		}
		
		fileprivate func unscaledConstraintBetween<AnchorType>(first: NSLayoutAnchor<AnchorType>, second: NSLayoutAnchor<AnchorType>, constraints: inout [NSLayoutConstraint], reverse: Bool = false) {
			let constraint: NSLayoutConstraint
			switch (relationship, reverse) {
			case (.equal, _): constraint = first.constraint(equalTo: second, constant: reverse ? -constant: constant)
			case (.lessThanOrEqual, false), (.greaterThanOrEqual, true): constraint = first.constraint(lessThanOrEqualTo: second, constant: reverse ? -constant: constant)
			case (.greaterThanOrEqual, false), (.lessThanOrEqual, true): constraint = first.constraint(greaterThanOrEqualTo: second, constant: reverse ? -constant: constant)
			}
			constraint.priority = priority
			constraints.append(constraint)
			constraint.isActive = true
		}
	}

	/// Bounds are used internally to capture a set of guides and anchors. On the Mac, these are merely copied from a single NSLayoutGuide or an NSView. On iOS, these may be copied from a blend of UIViewController top/bottomLayoutGuides, safeAreaLayoutGuides, layoutMarginsGuides or a UIView.
	fileprivate struct Bounds {
		var leading: NSLayoutXAxisAnchor
		var top: NSLayoutYAxisAnchor
		var trailing: NSLayoutXAxisAnchor
		var bottom: NSLayoutYAxisAnchor
		var width: NSLayoutDimension
		var height: NSLayoutDimension
		var centerX: NSLayoutXAxisAnchor
		var centerY: NSLayoutYAxisAnchor
		
		fileprivate init(box: Layout.Box) {
			leading = box.leadingAnchor
			top = box.topAnchor
			trailing = box.trailingAnchor
			bottom = box.bottomAnchor
			width = box.widthAnchor
			height = box.heightAnchor
			centerX = box.centerXAnchor
			centerY = box.centerYAnchor
		}
		
		#if os(iOS)
			fileprivate init(scrollView: UIScrollView) {
				leading = scrollView.contentLayoutGuide.leadingAnchor
				top = scrollView.contentLayoutGuide.topAnchor
				trailing = scrollView.contentLayoutGuide.trailingAnchor
				bottom = scrollView.contentLayoutGuide.bottomAnchor
				width = scrollView.contentLayoutGuide.widthAnchor
				height = scrollView.contentLayoutGuide.heightAnchor
				centerX = scrollView.contentLayoutGuide.centerXAnchor
				centerY = scrollView.contentLayoutGuide.centerYAnchor
			}
			
			fileprivate init(view: Layout.View, marginEdges: MarginEdges) {
				leading = marginEdges.contains(.leadingSafeArea) ? view.safeAreaLayoutGuide.leadingAnchor : (marginEdges.contains(.leadingLayout) ? view.layoutMarginsGuide.leadingAnchor : view.leadingAnchor)
				top = marginEdges.contains(.topSafeArea) ? view.safeAreaLayoutGuide.topAnchor : (marginEdges.contains(.topLayout) ? view.layoutMarginsGuide.topAnchor : view.topAnchor)
				trailing = marginEdges.contains(.trailingSafeArea) ? view.safeAreaLayoutGuide.trailingAnchor : (marginEdges.contains(.trailingLayout) ? view.layoutMarginsGuide.trailingAnchor : view.trailingAnchor)
				bottom = marginEdges.contains(.bottomSafeArea) ? view.safeAreaLayoutGuide.bottomAnchor : (marginEdges.contains(.bottomLayout) ? view.layoutMarginsGuide.bottomAnchor : view.bottomAnchor)
				width = (marginEdges.contains(.leadingSafeArea) && marginEdges.contains(.trailingSafeArea)) ? view.safeAreaLayoutGuide.widthAnchor : (marginEdges.contains(.leadingLayout) && marginEdges.contains(.trailingLayout) ? view.layoutMarginsGuide.widthAnchor : view.widthAnchor)
				height = (marginEdges.contains(.leadingSafeArea) && marginEdges.contains(.trailingSafeArea)) ? view.safeAreaLayoutGuide.heightAnchor : (marginEdges.contains(.leadingLayout) && marginEdges.contains(.trailingLayout) ? view.layoutMarginsGuide.heightAnchor : view.heightAnchor)
				centerX = (marginEdges.contains(.leadingSafeArea) && marginEdges.contains(.trailingSafeArea)) ? view.safeAreaLayoutGuide.centerXAnchor : (marginEdges.contains(.leadingLayout) && marginEdges.contains(.trailingLayout) ? view.layoutMarginsGuide.centerXAnchor : view.centerXAnchor)
				centerY = (marginEdges.contains(.leadingSafeArea) && marginEdges.contains(.trailingSafeArea)) ? view.safeAreaLayoutGuide.centerYAnchor : (marginEdges.contains(.leadingLayout) && marginEdges.contains(.trailingLayout) ? view.layoutMarginsGuide.centerYAnchor : view.centerYAnchor)
			}
		#else
			fileprivate init(view: Layout.View, marginEdges: MarginEdges) {
				leading = view.leadingAnchor
				top = view.topAnchor
				trailing = view.trailingAnchor
				bottom = view.bottomAnchor
				width = view.widthAnchor
				height = view.heightAnchor
				centerX = view.centerXAnchor
				centerY = view.centerYAnchor
			}
		#endif
	}

	fileprivate struct State {
		let view: View
		let storage: Storage
		
		var dimension: Dimension? = nil
		var previousEntityBounds: Bounds? = nil
		var containerBounds: Bounds
		
		init(containerBounds: Bounds, in view: View, storage: Storage) {
			self.containerBounds = containerBounds
			self.view = view
			self.storage = storage
		}
	}

	fileprivate class Storage: NSObject {
		let layout: Layout
		var constraints: [NSLayoutConstraint] = []
		var boxes: [Layout.Box] = []
		
		init(layout: Layout) {
			self.layout = layout
		}
	}

	fileprivate func twoPointConstraint<First, Second>(firstSource: NSLayoutAnchor<First>, firstTarget: NSLayoutAnchor<First>, secondSource: NSLayoutAnchor<Second>, secondTarget: NSLayoutAnchor<Second>, secondRelationLessThan: Bool? = nil, constraints: inout [NSLayoutConstraint]) {
		let first = firstSource.constraint(equalTo: firstTarget)
		first.priority = .required
		first.isActive = true
		constraints.append(first)
		
		let secondLow = secondSource.constraint(equalTo: secondTarget)
		
		var secondHigh: NSLayoutConstraint? = nil
		if secondRelationLessThan == true {
			secondHigh = secondSource.constraint(lessThanOrEqualTo: secondTarget)
		} else if secondRelationLessThan == false {
			secondHigh = secondSource.constraint(greaterThanOrEqualTo: secondTarget)
		}
		if let high = secondHigh {
			secondLow.priority = .userLow
			high.priority = .userHigh
			high.isActive = true
			constraints.append(high)
		} else {
			secondLow.priority = .userHigh
		}
		secondLow.isActive = true
		constraints.append(secondLow)
	}
	
	fileprivate func constrain(bounds: Bounds, leading: Dimension, length: Dimension?, breadth: Dimension?, relative: Bool, state: inout State) {
		switch axis {
		case .horizontal:
			leading.unscaledConstraintBetween(first: bounds.leading, second: state.containerBounds.leading, constraints: &state.storage.constraints)
			
			if let l = length {
				l.scaledConstraintBetween(first: bounds.width, second: state.containerBounds.width, constraints: &state.storage.constraints)
			}
			if let b = breadth {
				b.scaledConstraintBetween(first: bounds.height, second: relative ? bounds.width : state.containerBounds.height, constraints: &state.storage.constraints)
			}
			
			switch self.align {
			case .leading:
				twoPointConstraint(firstSource: bounds.top, firstTarget: state.containerBounds.top, secondSource: bounds.bottom, secondTarget: state.containerBounds.bottom, secondRelationLessThan: true, constraints: &state.storage.constraints)
			case .trailing:
				twoPointConstraint(firstSource: bounds.bottom, firstTarget: state.containerBounds.bottom, secondSource: bounds.top, secondTarget: state.containerBounds.top, secondRelationLessThan: false, constraints: &state.storage.constraints)
			case .center:
				twoPointConstraint(firstSource: bounds.centerY, firstTarget: state.containerBounds.centerY, secondSource: bounds.height, secondTarget: state.containerBounds.height, secondRelationLessThan: true, constraints: &state.storage.constraints)
			case .fill:
				twoPointConstraint(firstSource: bounds.top, firstTarget: state.containerBounds.top, secondSource: bounds.bottom, secondTarget: state.containerBounds.bottom, secondRelationLessThan: nil, constraints: &state.storage.constraints)
			}
			
			state.containerBounds.leading = bounds.trailing
		case .vertical:
			leading.unscaledConstraintBetween(first: bounds.top, second: state.containerBounds.top, constraints: &state.storage.constraints)
			
			if let l = length {
				l.scaledConstraintBetween(first: bounds.height, second: state.containerBounds.height, constraints: &state.storage.constraints)
			}
			
			if let b = breadth {
				b.scaledConstraintBetween(first: bounds.width, second: relative ? bounds.height : state.containerBounds.width, constraints: &state.storage.constraints)
			}
			
			switch self.align {
			case .leading:
				twoPointConstraint(firstSource: bounds.leading, firstTarget: state.containerBounds.leading, secondSource: bounds.trailing, secondTarget: state.containerBounds.trailing, secondRelationLessThan: true, constraints: &state.storage.constraints)
			case .trailing:
				twoPointConstraint(firstSource: bounds.trailing, firstTarget: state.containerBounds.trailing, secondSource: bounds.leading, secondTarget: state.containerBounds.leading, secondRelationLessThan: false, constraints: &state.storage.constraints)
			case .center:
				twoPointConstraint(firstSource: bounds.centerX, firstTarget: state.containerBounds.centerX, secondSource: bounds.width, secondTarget: state.containerBounds.width, secondRelationLessThan: true, constraints: &state.storage.constraints)
			case .fill:
				twoPointConstraint(firstSource: bounds.leading, firstTarget: state.containerBounds.leading, secondSource: bounds.trailing, secondTarget: state.containerBounds.trailing, secondRelationLessThan: nil, constraints: &state.storage.constraints)
			}
			
			state.containerBounds.top = bounds.bottom
		}
	}
	
	@discardableResult
	fileprivate func layout(entity: Entity, state: inout State, needDimensionAnchor: Bool = false) -> NSLayoutDimension? {
		switch entity.content {
		case .space(let dimension):
			if let d = state.dimension, (d.ratio != 0 || d.constant != 0) {
				let box = Layout.Box()
				state.view.addLayoutBox(box)
				state.storage.boxes.append(box)
				constrain(bounds: Bounds(box: box), leading: Dimension(), length: d, breadth: nil, relative: false, state: &state)
				state.previousEntityBounds = nil
			}
			if dimension.ratio != 0 || needDimensionAnchor {
				let box = Layout.Box()
				state.view.addLayoutBox(box)
				state.storage.boxes.append(box)
				constrain(bounds: Bounds(box: box), leading: Dimension(), length: dimension, breadth: nil, relative: false, state: &state)
				if !needDimensionAnchor {
					state.previousEntityBounds = Bounds(box: box)
				}
				return axis == .horizontal ? box.widthAnchor : box.heightAnchor
			}
			state.dimension = dimension
			return nil
		case .layout(let l, let size):
			let box = Layout.Box()
			state.view.addLayoutBox(box)
			state.storage.boxes.append(box)
			let bounds = Bounds(box: box)
			l.add(to: state.view, containerBounds: bounds, storage: state.storage)
			constrain(bounds: bounds, leading: state.dimension ?? Dimension(), length: size?.length, breadth: size?.breadth, relative: size?.relative ?? false, state: &state)
			state.dimension = nil
			state.previousEntityBounds = bounds
			return needDimensionAnchor ? (axis == .horizontal ? box.widthAnchor : box.heightAnchor) : nil
		case .matched(let matched):
			if needDimensionAnchor {
				let box = Layout.Box()
				state.view.addLayoutBox(box)
				state.storage.boxes.append(box)
				var subState = State(containerBounds: state.containerBounds, in: state.view, storage: state.storage)
				layout(entity: entity, state: &subState)
				state.dimension = nil
				state.previousEntityBounds = Bounds(box: box)
				return axis == .horizontal ? box.widthAnchor : box.heightAnchor
			} else {
				let first = layout(entity: matched.first, state: &state, needDimensionAnchor: true)!
				for element in matched.subsequent {
					switch element {
					case .free(let entity): layout(entity: entity, state: &state)
					case .dependent(let dependent):
						let match = layout(entity: dependent.entity, state: &state, needDimensionAnchor: true)!
						dependent.dimension.scaledConstraintBetween(first: match, second: first, constraints: &state.storage.constraints)
					}
				}
				return nil
			}
		case .sizedView(let v, let size):
			#if os(macOS)
				let view = v.nsView()
			#else
				let view = v.uiView()
			#endif
			view.translatesAutoresizingMaskIntoConstraints = false
			state.view.addSubview(view)
			constrain(bounds: Bounds(view: view, marginEdges: .none), leading: state.dimension ?? Dimension(), length: size?.length, breadth: size?.breadth, relative: size?.relative ?? false, state: &state)
			state.dimension = nil
			state.previousEntityBounds = Bounds(view: view, marginEdges: .none)
			return needDimensionAnchor ? (axis == .horizontal ? view.widthAnchor : view.heightAnchor) : nil
		}
	}
	
	fileprivate func add(to view: Layout.View, containerBounds: Bounds, storage: Storage) {
		var state = State(containerBounds: containerBounds, in: view, storage: storage)
		for entity in entities {
			layout(entity: entity, state: &state)
		}
		if let previous = state.previousEntityBounds {
			switch axis {
			case .horizontal:
				(state.dimension ?? Dimension()).unscaledConstraintBetween(first: previous.trailing, second: state.containerBounds.trailing, constraints: &state.storage.constraints, reverse: true)
			case .vertical:
				(state.dimension ?? Dimension()).unscaledConstraintBetween(first: previous.bottom, second: state.containerBounds.bottom, constraints: &state.storage.constraints, reverse: true)
			}
		}
	}
}

// DEBUGGING TIP:
// As of Xcode 8, the "Debug View Hierarchy" option does not show layout guides, making debugging of constraints involving layout guides tricky. To aid debugging in these cases, set the following condition to `true && DEBUG` and CwlLayout will create views instead of layout guides.
// Otherwise, you can set this to `false && DEBUG`.
#if true && DEBUG
extension Layout {
	fileprivate typealias Box = Layout.View
}
extension Layout.View {
	fileprivate func addLayoutBox(_ layoutBox: Layout.Box) {
		layoutBox.translatesAutoresizingMaskIntoConstraints = false
		self.addSubview(layoutBox)
	}
	fileprivate func removeLayoutBox(_ layoutBox: Layout.Box) {
		layoutBox.removeFromSuperview()
	}
}
#else
extension Layout {
	fileprivate typealias Box = Layout.Guide
}
extension Layout.View {
	fileprivate func addLayoutBox(_ layoutBox: Layout.Box) {
		self.addLayoutGuide(layoutBox)
	}
	fileprivate func removeLayoutBox(_ layoutBox: Layout.Box) {
		self.removeLayoutGuide(layoutBox)
	}
}
#endif

// NOTE:
//
// Views often have their own intrinsic size, and they maintain this size at
// either the `.defaultLow` or `.defaultHigh` priority. Unfortunately, layout
// doesn't work well if this intrinsic priority is perfectly balanced with the
// user-applied layout priority.
//
// For this reason, CwlLayout defaults to using the following layout priorities
// which are scaled to be slightly different to the default priorities. This
// allows you to easily set layout priorities above, between or below the
// intrinisic priorities without always resorting to `.required`.
//
extension Layout.Dimension.Priority {
	#if os(macOS)
		static let userLow = NSLayoutConstraint.Priority(rawValue: 156.25)
		static let userMid = NSLayoutConstraint.Priority(rawValue: 437.5)
		static let userHigh = NSLayoutConstraint.Priority(rawValue: 843.75)
	#else
		static let userLow = UILayoutPriority(rawValue: 156.25)
		static let userMid = UILayoutPriority(rawValue: 437.5)
		static let userHigh = UILayoutPriority(rawValue: 843.75)
	#endif
}

fileprivate var associatedLayoutKey = NSObject()
fileprivate func setLayout(_ newValue: Layout.Storage?, for object: Layout.View) {
	objc_setAssociatedObject(object, &associatedLayoutKey, newValue, objc_AssociationPolicy.OBJC_ASSOCIATION_RETAIN)
}
fileprivate func getLayout(for view: Layout.View) -> Layout.Storage? {
	return objc_getAssociatedObject(view, &associatedLayoutKey) as? Layout.Storage
}

fileprivate extension Layout.View {
	func remove(constraintsAndBoxes previousLayout: Layout.Storage?, subviews: Set<Layout.View>) {
		guard let previous = previousLayout else { return }
		for constraint in previous.constraints {
			constraint.isActive = false
		}
		for box in previous.boxes {
			self.removeLayoutBox(box)
		}
		subviews.forEach { $0.removeFromSuperview() }
	}
}

fileprivate func applyLayoutToView(view: Layout.View, params: (layout: Layout, bounds: Layout.Bounds)?) {
	var removedViews = Set<Layout.View>()
	
	// Check for a previous layout and get the old views
	let previous = getLayout(for: view)
	previous?.layout.forEachView { view in removedViews.insert(view) }
	
	guard let (layout, bounds) = params else {
		// If there's no new layout, remove the old layout and we're done
		view.remove(constraintsAndBoxes: previous, subviews: removedViews)
		return
	}
	
	// Check if this will be animated
	let shouldAnimate = layout.animate != .none && (previous != nil || layout.animate != .subsequent)
	
	// Exclude views in the new layout from the removed set. If we're animating, we'll need animated and added sets too.
	var animatedViews = Set<Layout.View>()
	var addedViews = Set<Layout.View>()
	layout.forEachView { v in
		if let animated = removedViews.remove(v), shouldAnimate {
			animatedViews.insert(animated)
		} else if shouldAnimate {
			addedViews.insert(v)
		}
	}
	
	#if os(macOS)
		view.remove(constraintsAndBoxes: previous, subviews: removedViews)
		let storage = Layout.Storage(layout: layout)
		layout.add(to: view, containerBounds: bounds, storage: storage)
		setLayout(storage, for: view)
		return
	#else
		// Now that we know the precise removed set, remove them.
		if shouldAnimate && addedViews.count == 0 && removedViews.count > 0 {
			// If we're animating the removal of views but not the insertion of views, animate this removal
			UIView.transition(with: view, duration: 0.2, options: [.transitionCrossDissolve, .allowUserInteraction], animations: {
				view.remove(constraintsAndBoxes: previous, subviews: removedViews)
			}, completion: { completed in })
		} else {
			view.remove(constraintsAndBoxes: previous, subviews: removedViews)
		}
		
		// Apply the new layout
		let storage = Layout.Storage(layout: layout)
		layout.add(to: view, containerBounds: bounds, storage: storage)
		
		// If we're not animating, store the layout and we're done.
		if !shouldAnimate {
			setLayout(storage, for: view)
			return
		}
		
		if addedViews.count > 0 {
			// Apply the layout, so new views have a precise size
			view.layoutIfNeeded()
			
			// Remove the new views and revert to the old layout
			view.remove(constraintsAndBoxes: storage, subviews: addedViews)
			if let p = previous {
				let oldStorage = Layout.Storage(layout: layout)
				p.layout.add(to: view, containerBounds: bounds, storage: oldStorage)

				// Immediately remove the old constraints but keep the old views
				view.remove(constraintsAndBoxes: oldStorage, subviews: [])
			}
			
			// Animate the simultaneous removal and addition of new views
			UIView.transition(with: view, duration: 0.2, options: [.transitionCrossDissolve, .allowUserInteraction], animations: {
				removedViews.forEach { $0.removeFromSuperview() }
				addedViews.forEach { view.addSubview($0) }
			}, completion: { completed in })
			
			// Reapply the new layout. Since the new views are already in-place
			let reapplyStorage = Layout.Storage(layout: layout)
			layout.add(to: view, containerBounds: bounds, storage: reapplyStorage)
			setLayout(reapplyStorage, for: view)
		} else {
			setLayout(storage, for: view)
		}
		
		// Animate the frames of the new layout
		UIView.animate(withDuration: 0.2, delay: 0, options: [.allowUserInteraction], animations: {
			view.layoutIfNeeded()
		}, completion: { completed in })
	#endif
}
